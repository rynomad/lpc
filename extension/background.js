(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js
  var init_dirname = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/__dirname.js"() {
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/process.js
  var process_exports = {};
  __export(process_exports, {
    _debugEnd: () => _debugEnd,
    _debugProcess: () => _debugProcess,
    _events: () => _events,
    _eventsCount: () => _eventsCount,
    _exiting: () => _exiting,
    _fatalExceptions: () => _fatalExceptions,
    _getActiveHandles: () => _getActiveHandles,
    _getActiveRequests: () => _getActiveRequests,
    _kill: () => _kill,
    _linkedBinding: () => _linkedBinding,
    _maxListeners: () => _maxListeners,
    _preload_modules: () => _preload_modules,
    _rawDebug: () => _rawDebug,
    _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
    _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
    _tickCallback: () => _tickCallback,
    abort: () => abort,
    addListener: () => addListener,
    allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
    arch: () => arch,
    argv: () => argv,
    argv0: () => argv0,
    assert: () => assert,
    binding: () => binding,
    chdir: () => chdir,
    config: () => config,
    cpuUsage: () => cpuUsage,
    cwd: () => cwd,
    debugPort: () => debugPort,
    default: () => process,
    dlopen: () => dlopen,
    domain: () => domain,
    emit: () => emit,
    emitWarning: () => emitWarning,
    env: () => env,
    execArgv: () => execArgv,
    execPath: () => execPath,
    exit: () => exit,
    features: () => features,
    hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
    hrtime: () => hrtime,
    kill: () => kill,
    listeners: () => listeners,
    memoryUsage: () => memoryUsage,
    moduleLoadList: () => moduleLoadList,
    nextTick: () => nextTick,
    off: () => off,
    on: () => on,
    once: () => once,
    openStdin: () => openStdin,
    pid: () => pid,
    platform: () => platform,
    ppid: () => ppid,
    prependListener: () => prependListener,
    prependOnceListener: () => prependOnceListener,
    reallyExit: () => reallyExit,
    release: () => release,
    removeAllListeners: () => removeAllListeners,
    removeListener: () => removeListener,
    resourceUsage: () => resourceUsage,
    setSourceMapsEnabled: () => setSourceMapsEnabled,
    setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
    stderr: () => stderr,
    stdin: () => stdin,
    stdout: () => stdout,
    title: () => title,
    umask: () => umask,
    uptime: () => uptime,
    version: () => version,
    versions: () => versions
  });
  function unimplemented(name2) {
    throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
  }
  function cleanUpNextTick() {
    if (!draining || !currentQueue)
      return;
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length)
      drainQueue();
  }
  function drainQueue() {
    if (draining)
      return;
    var timeout2 = setTimeout(cleanUpNextTick, 0);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue)
          currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout2);
  }
  function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i7 = 1; i7 < arguments.length; i7++)
        args[i7 - 1] = arguments[i7];
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining)
      setTimeout(drainQueue, 0);
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  function noop() {
  }
  function _linkedBinding(name2) {
    unimplemented("_linkedBinding");
  }
  function dlopen(name2) {
    unimplemented("dlopen");
  }
  function _getActiveRequests() {
    return [];
  }
  function _getActiveHandles() {
    return [];
  }
  function assert(condition, message) {
    if (!condition)
      throw new Error(message || "assertion error");
  }
  function hasUncaughtExceptionCaptureCallback() {
    return false;
  }
  function uptime() {
    return _performance.now() / 1e3;
  }
  function hrtime(previousTimestamp) {
    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
    var clocktime = _performance.now() * 1e-3;
    var seconds = Math.floor(clocktime) + baseNow;
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);
    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];
      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += nanoPerSec;
      }
    }
    return [seconds, nanoseconds];
  }
  function on() {
    return process;
  }
  function listeners(name2) {
    return [];
  }
  var queue, draining, currentQueue, queueIndex, title, arch, platform, env, argv, execArgv, version, versions, emitWarning, binding, umask, cwd, chdir, release, _rawDebug, moduleLoadList, domain, _exiting, config, reallyExit, _kill, cpuUsage, resourceUsage, memoryUsage, kill, exit, openStdin, allowedNodeEnvironmentFlags, features, _fatalExceptions, setUncaughtExceptionCaptureCallback, _tickCallback, _debugProcess, _debugEnd, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, stdout, stderr, stdin, abort, pid, ppid, execPath, debugPort, argv0, _preload_modules, setSourceMapsEnabled, _performance, nowOffset, nanoPerSec, _maxListeners, _events, _eventsCount, addListener, once, off, removeListener, removeAllListeners, emit, prependListener, prependOnceListener, process;
  var init_process = __esm({
    "node_modules/@jspm/core/nodelibs/browser/process.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      queue = [];
      draining = false;
      queueIndex = -1;
      Item.prototype.run = function() {
        this.fun.apply(null, this.array);
      };
      title = "browser";
      arch = "x64";
      platform = "browser";
      env = {
        PATH: "/usr/bin",
        LANG: navigator.language + ".UTF-8",
        PWD: "/",
        HOME: "/home",
        TMP: "/tmp"
      };
      argv = ["/usr/bin/node"];
      execArgv = [];
      version = "v16.8.0";
      versions = {};
      emitWarning = function(message, type) {
        console.warn((type ? type + ": " : "") + message);
      };
      binding = function(name2) {
        unimplemented("binding");
      };
      umask = function(mask) {
        return 0;
      };
      cwd = function() {
        return "/";
      };
      chdir = function(dir) {
      };
      release = {
        name: "node",
        sourceUrl: "",
        headersUrl: "",
        libUrl: ""
      };
      _rawDebug = noop;
      moduleLoadList = [];
      domain = {};
      _exiting = false;
      config = {};
      reallyExit = noop;
      _kill = noop;
      cpuUsage = function() {
        return {};
      };
      resourceUsage = cpuUsage;
      memoryUsage = cpuUsage;
      kill = noop;
      exit = noop;
      openStdin = noop;
      allowedNodeEnvironmentFlags = {};
      features = {
        inspector: false,
        debug: false,
        uv: false,
        ipv6: false,
        tls_alpn: false,
        tls_sni: false,
        tls_ocsp: false,
        tls: false,
        cached_builtins: true
      };
      _fatalExceptions = noop;
      setUncaughtExceptionCaptureCallback = noop;
      _tickCallback = noop;
      _debugProcess = noop;
      _debugEnd = noop;
      _startProfilerIdleNotifier = noop;
      _stopProfilerIdleNotifier = noop;
      stdout = void 0;
      stderr = void 0;
      stdin = void 0;
      abort = noop;
      pid = 2;
      ppid = 1;
      execPath = "/bin/usr/node";
      debugPort = 9229;
      argv0 = "node";
      _preload_modules = [];
      setSourceMapsEnabled = noop;
      _performance = {
        now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
        timing: typeof performance !== "undefined" ? performance.timing : void 0
      };
      if (_performance.now === void 0) {
        nowOffset = Date.now();
        if (_performance.timing && _performance.timing.navigationStart) {
          nowOffset = _performance.timing.navigationStart;
        }
        _performance.now = () => Date.now() - nowOffset;
      }
      nanoPerSec = 1e9;
      hrtime.bigint = function(time) {
        var diff = hrtime(time);
        if (typeof BigInt === "undefined") {
          return diff[0] * nanoPerSec + diff[1];
        }
        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
      };
      _maxListeners = 10;
      _events = {};
      _eventsCount = 0;
      addListener = on;
      once = on;
      off = on;
      removeListener = on;
      removeAllListeners = on;
      emit = noop;
      prependListener = on;
      prependOnceListener = on;
      process = {
        version,
        versions,
        arch,
        platform,
        release,
        _rawDebug,
        moduleLoadList,
        binding,
        _linkedBinding,
        _events,
        _eventsCount,
        _maxListeners,
        on,
        addListener,
        once,
        off,
        removeListener,
        removeAllListeners,
        emit,
        prependListener,
        prependOnceListener,
        listeners,
        domain,
        _exiting,
        config,
        dlopen,
        uptime,
        _getActiveRequests,
        _getActiveHandles,
        reallyExit,
        _kill,
        cpuUsage,
        resourceUsage,
        memoryUsage,
        kill,
        exit,
        openStdin,
        allowedNodeEnvironmentFlags,
        assert,
        features,
        _fatalExceptions,
        setUncaughtExceptionCaptureCallback,
        hasUncaughtExceptionCaptureCallback,
        emitWarning,
        nextTick,
        _tickCallback,
        _debugProcess,
        _debugEnd,
        _startProfilerIdleNotifier,
        _stopProfilerIdleNotifier,
        stdout,
        stdin,
        stderr,
        abort,
        umask,
        chdir,
        cwd,
        env,
        title,
        argv,
        execArgv,
        pid,
        ppid,
        execPath,
        debugPort,
        hrtime,
        argv0,
        _preload_modules,
        setSourceMapsEnabled
      };
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/process.js
  var init_process2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/process.js"() {
      init_process();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/buffer.js
  function dew$2() {
    if (_dewExec$2)
      return exports$3;
    _dewExec$2 = true;
    exports$3.byteLength = byteLength;
    exports$3.toByteArray = toByteArray;
    exports$3.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$3;
  }
  function dew$1() {
    if (_dewExec$1)
      return exports$2;
    _dewExec$1 = true;
    exports$2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d7 = isLE ? -1 : 1;
      var s7 = buffer2[offset + i7];
      i7 += d7;
      e9 = s7 & (1 << -nBits) - 1;
      s7 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d7, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d7, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s7 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s7 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d7 = isLE ? 1 : -1;
      var s7 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt2 / c7;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d7, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d7, e9 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d7] |= s7 * 128;
    };
    return exports$2;
  }
  function dew() {
    if (_dewExec)
      return exports$1;
    _dewExec = true;
    const base64 = dew$2();
    const ieee754 = dew$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$1.Buffer = Buffer3;
    exports$1.SlowBuffer = SlowBuffer;
    exports$1.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$1.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b6 = fromObject(value);
      if (b6)
        return b6;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b6) {
      return b6 != null && b6._isBuffer === true && b6 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a8, b6) {
      if (isInstance(a8, Uint8Array))
        a8 = Buffer3.from(a8, a8.offset, a8.byteLength);
      if (isInstance(b6, Uint8Array))
        b6 = Buffer3.from(b6, b6.offset, b6.byteLength);
      if (!Buffer3.isBuffer(a8) || !Buffer3.isBuffer(b6)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a8 === b6)
        return 0;
      let x4 = a8.length;
      let y6 = b6.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a8[i7] !== b6[i7]) {
          x4 = a8[i7];
          y6 = b6[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b6, n8, m6) {
      const i7 = b6[n8];
      b6[n8] = b6[m6];
      b6[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b6) {
      if (!Buffer3.isBuffer(b6))
        throw new TypeError("Argument must be a Buffer");
      if (this === b6)
        return true;
      return Buffer3.compare(this, b6) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$1.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j5 = 0; j5 < valLength; j5++) {
            if (read2(arr, i7 + j5) !== read2(val, j5)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors2 = {};
    function E5(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E5("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E5("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E5("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j5 = 0; j5 < 16; ++j5) {
          table[i16 + j5] = alphabet[i7] + alphabet[j5];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$1;
  }
  var exports$3, _dewExec$2, exports$2, _dewExec$1, exports$1, _dewExec, exports, Buffer2, INSPECT_MAX_BYTES, kMaxLength;
  var init_buffer = __esm({
    "node_modules/@jspm/core/nodelibs/browser/buffer.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports$3 = {};
      _dewExec$2 = false;
      exports$2 = {};
      _dewExec$1 = false;
      exports$1 = {};
      _dewExec = false;
      exports = dew();
      exports["Buffer"];
      exports["SlowBuffer"];
      exports["INSPECT_MAX_BYTES"];
      exports["kMaxLength"];
      Buffer2 = exports.Buffer;
      INSPECT_MAX_BYTES = exports.INSPECT_MAX_BYTES;
      kMaxLength = exports.kMaxLength;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js
  var init_buffer2 = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js"() {
      init_buffer();
    }
  });

  // node_modules/is-pojo/lib/index.js
  var require_lib = __commonJS({
    "node_modules/is-pojo/lib/index.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var proto = Object.prototype;
      var gpo = Object.getPrototypeOf;
      function isPojo2(obj) {
        if (obj === null || typeof obj !== "object") {
          return false;
        }
        return gpo(obj) === proto;
      }
      module.exports = isPojo2;
    }
  });

  // node_modules/is-pojo/index.js
  var require_is_pojo = __commonJS({
    "node_modules/is-pojo/index.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = require_lib();
    }
  });

  // node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js
  function a(e9) {
    return { all: e9 = e9 || /* @__PURE__ */ new Map(), on: function(f7, i7) {
      var t8 = e9.get(f7);
      t8 ? t8.push(i7) : e9.set(f7, [i7]);
    }, off: function(f7, i7) {
      var t8 = e9.get(f7);
      t8 && (i7 ? t8.splice(t8.indexOf(i7) >>> 0, 1) : e9.set(f7, []));
    }, emit: function(f7, i7) {
      var t8 = e9.get(f7);
      t8 && t8.slice().map(function(o8) {
        o8(i7);
      }), (t8 = e9.get("*")) && t8.slice().map(function(o8) {
        o8(f7, i7);
      });
    } };
  }
  var init_mitt = __esm({
    "node_modules/puppeteer-core/lib/esm/third_party/mitt/mitt.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js
  var disposeSymbol, asyncDisposeSymbol, DisposableStack, AsyncDisposableStack;
  var init_disposable = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/disposable.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Symbol.dispose ??= Symbol("dispose");
      Symbol.asyncDispose ??= Symbol("asyncDispose");
      disposeSymbol = Symbol.dispose;
      asyncDisposeSymbol = Symbol.asyncDispose;
      DisposableStack = class _DisposableStack {
        #disposed = false;
        #stack = [];
        /**
         * Returns a value indicating whether this stack has been disposed.
         */
        get disposed() {
          return this.#disposed;
        }
        /**
         * Disposes each resource in the stack in the reverse order that they were added.
         */
        dispose() {
          if (this.#disposed) {
            return;
          }
          this.#disposed = true;
          for (const resource of this.#stack.reverse()) {
            resource[disposeSymbol]();
          }
        }
        /**
         * Adds a disposable resource to the stack, returning the resource.
         *
         * @param value - The resource to add. `null` and `undefined` will not be added,
         * but will be returned.
         * @returns The provided `value`.
         */
        use(value) {
          if (value) {
            this.#stack.push(value);
          }
          return value;
        }
        /**
         * Adds a value and associated disposal callback as a resource to the stack.
         *
         * @param value - The value to add.
         * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
         * method. Will be invoked with `value` as the first parameter.
         * @returns The provided `value`.
         */
        adopt(value, onDispose) {
          this.#stack.push({
            [disposeSymbol]() {
              onDispose(value);
            }
          });
          return value;
        }
        /**
         * Adds a callback to be invoked when the stack is disposed.
         */
        defer(onDispose) {
          this.#stack.push({
            [disposeSymbol]() {
              onDispose();
            }
          });
        }
        /**
         * Move all resources out of this stack and into a new `DisposableStack`, and
         * marks this stack as disposed.
         *
         * @example
         *
         * ```ts
         * class C {
         *   #res1: Disposable;
         *   #res2: Disposable;
         *   #disposables: DisposableStack;
         *   constructor() {
         *     // stack will be disposed when exiting constructor for any reason
         *     using stack = new DisposableStack();
         *
         *     // get first resource
         *     this.#res1 = stack.use(getResource1());
         *
         *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
         *     this.#res2 = stack.use(getResource2());
         *
         *     // all operations succeeded, move resources out of `stack` so that
         *     // they aren't disposed when constructor exits
         *     this.#disposables = stack.move();
         *   }
         *
         *   [disposeSymbol]() {
         *     this.#disposables.dispose();
         *   }
         * }
         * ```
         */
        move() {
          if (this.#disposed) {
            throw new ReferenceError("a disposed stack can not use anything new");
          }
          const stack = new _DisposableStack();
          stack.#stack = this.#stack;
          this.#disposed = true;
          return stack;
        }
        [disposeSymbol] = this.dispose;
        [Symbol.toStringTag] = "DisposableStack";
      };
      AsyncDisposableStack = class _AsyncDisposableStack {
        #disposed = false;
        #stack = [];
        /**
         * Returns a value indicating whether this stack has been disposed.
         */
        get disposed() {
          return this.#disposed;
        }
        /**
         * Disposes each resource in the stack in the reverse order that they were added.
         */
        async dispose() {
          if (this.#disposed) {
            return;
          }
          this.#disposed = true;
          for (const resource of this.#stack.reverse()) {
            await resource[asyncDisposeSymbol]();
          }
        }
        /**
         * Adds a disposable resource to the stack, returning the resource.
         *
         * @param value - The resource to add. `null` and `undefined` will not be added,
         * but will be returned.
         * @returns The provided `value`.
         */
        use(value) {
          if (value) {
            this.#stack.push(value);
          }
          return value;
        }
        /**
         * Adds a value and associated disposal callback as a resource to the stack.
         *
         * @param value - The value to add.
         * @param onDispose - The callback to use in place of a `[disposeSymbol]()`
         * method. Will be invoked with `value` as the first parameter.
         * @returns The provided `value`.
         */
        adopt(value, onDispose) {
          this.#stack.push({
            [asyncDisposeSymbol]() {
              return onDispose(value);
            }
          });
          return value;
        }
        /**
         * Adds a callback to be invoked when the stack is disposed.
         */
        defer(onDispose) {
          this.#stack.push({
            [asyncDisposeSymbol]() {
              return onDispose();
            }
          });
        }
        /**
         * Move all resources out of this stack and into a new `DisposableStack`, and
         * marks this stack as disposed.
         *
         * @example
         *
         * ```ts
         * class C {
         *   #res1: Disposable;
         *   #res2: Disposable;
         *   #disposables: DisposableStack;
         *   constructor() {
         *     // stack will be disposed when exiting constructor for any reason
         *     using stack = new DisposableStack();
         *
         *     // get first resource
         *     this.#res1 = stack.use(getResource1());
         *
         *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.
         *     this.#res2 = stack.use(getResource2());
         *
         *     // all operations succeeded, move resources out of `stack` so that
         *     // they aren't disposed when constructor exits
         *     this.#disposables = stack.move();
         *   }
         *
         *   [disposeSymbol]() {
         *     this.#disposables.dispose();
         *   }
         * }
         * ```
         */
        move() {
          if (this.#disposed) {
            throw new ReferenceError("a disposed stack can not use anything new");
          }
          const stack = new _AsyncDisposableStack();
          stack.#stack = this.#stack;
          this.#disposed = true;
          return stack;
        }
        [asyncDisposeSymbol] = this.dispose;
        [Symbol.toStringTag] = "AsyncDisposableStack";
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js
  var EventEmitter, EventSubscription;
  var init_EventEmitter = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_mitt();
      init_disposable();
      EventEmitter = class {
        #emitter;
        #handlers = /* @__PURE__ */ new Map();
        /**
         * @internal
         */
        constructor() {
          this.#emitter = a(this.#handlers);
        }
        /**
         * Bind an event listener to fire when an event occurs.
         * @param type - the event type you'd like to listen to. Can be a string or symbol.
         * @param handler - the function to be called when the event occurs.
         * @returns `this` to enable you to chain method calls.
         */
        on(type, handler) {
          this.#emitter.on(type, handler);
          return this;
        }
        /**
         * Remove an event listener from firing.
         * @param type - the event type you'd like to stop listening to.
         * @param handler - the function that should be removed.
         * @returns `this` to enable you to chain method calls.
         */
        off(type, handler) {
          this.#emitter.off(type, handler);
          return this;
        }
        /**
         * Remove an event listener.
         *
         * @deprecated please use {@link EventEmitter.off} instead.
         */
        removeListener(type, handler) {
          this.off(type, handler);
          return this;
        }
        /**
         * Add an event listener.
         *
         * @deprecated please use {@link EventEmitter.on} instead.
         */
        addListener(type, handler) {
          this.on(type, handler);
          return this;
        }
        /**
         * Emit an event and call any associated listeners.
         *
         * @param type - the event you'd like to emit
         * @param eventData - any data you'd like to emit with the event
         * @returns `true` if there are any listeners, `false` if there are not.
         */
        emit(type, event) {
          this.#emitter.emit(type, event);
          return this.listenerCount(type) > 0;
        }
        /**
         * Like `on` but the listener will only be fired once and then it will be removed.
         * @param type - the event you'd like to listen to
         * @param handler - the handler function to run when the event occurs
         * @returns `this` to enable you to chain method calls.
         */
        once(type, handler) {
          const onceHandler = (eventData) => {
            handler(eventData);
            this.off(type, onceHandler);
          };
          return this.on(type, onceHandler);
        }
        /**
         * Gets the number of listeners for a given event.
         *
         * @param type - the event to get the listener count for
         * @returns the number of listeners bound to the given event
         */
        listenerCount(type) {
          return this.#handlers.get(type)?.length || 0;
        }
        /**
         * Removes all listeners. If given an event argument, it will remove only
         * listeners for that event.
         *
         * @param type - the event to remove listeners for.
         * @returns `this` to enable you to chain method calls.
         */
        removeAllListeners(type) {
          if (type === void 0 || type === "*") {
            this.#handlers.clear();
          } else {
            this.#handlers.delete(type);
          }
          return this;
        }
      };
      EventSubscription = class {
        #target;
        #type;
        #handler;
        constructor(target, type, handler) {
          this.#target = target;
          this.#type = type;
          this.#handler = handler;
          this.#target.on(this.#type, this.#handler);
        }
        [disposeSymbol]() {
          this.#target.off(this.#type, this.#handler);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js
  var CDPSessionEvent, CDPSession;
  var init_CDPSession = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/CDPSession.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_EventEmitter();
      (function(CDPSessionEvent2) {
        CDPSessionEvent2.Disconnected = Symbol("CDPSession.Disconnected");
        CDPSessionEvent2.Swapped = Symbol("CDPSession.Swapped");
        CDPSessionEvent2.Ready = Symbol("CDPSession.Ready");
        CDPSessionEvent2.SessionAttached = "sessionattached";
        CDPSessionEvent2.SessionDetached = "sessiondetached";
      })(CDPSessionEvent || (CDPSessionEvent = {}));
      CDPSession = class extends EventEmitter {
        /**
         * @internal
         */
        constructor() {
          super();
        }
        /**
         * Parent session in terms of CDP's auto-attach mechanism.
         *
         * @internal
         */
        parentSession() {
          return void 0;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js
  var CustomError, TimeoutError, ProtocolError, UnsupportedOperation, TargetCloseError, errors;
  var init_Errors = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/Errors.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      CustomError = class extends Error {
        /**
         * @internal
         */
        constructor(message) {
          super(message);
          this.name = this.constructor.name;
        }
        /**
         * @internal
         */
        get [Symbol.toStringTag]() {
          return this.constructor.name;
        }
      };
      TimeoutError = class extends CustomError {
      };
      ProtocolError = class extends CustomError {
        #code;
        #originalMessage = "";
        set code(code) {
          this.#code = code;
        }
        /**
         * @readonly
         * @public
         */
        get code() {
          return this.#code;
        }
        set originalMessage(originalMessage) {
          this.#originalMessage = originalMessage;
        }
        /**
         * @readonly
         * @public
         */
        get originalMessage() {
          return this.#originalMessage;
        }
      };
      UnsupportedOperation = class extends CustomError {
      };
      TargetCloseError = class extends ProtocolError {
      };
      errors = Object.freeze({
        TimeoutError,
        ProtocolError
      });
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js
  var Deferred;
  var init_Deferred = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/Deferred.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Errors();
      Deferred = class _Deferred {
        #isResolved = false;
        #isRejected = false;
        #value;
        #resolver = () => {
        };
        #taskPromise = new Promise((resolve3) => {
          this.#resolver = resolve3;
        });
        #timeoutId;
        #timeoutError;
        constructor(opts) {
          if (opts && opts.timeout > 0) {
            this.#timeoutError = new TimeoutError(opts.message);
            this.#timeoutId = setTimeout(() => {
              this.reject(this.#timeoutError);
            }, opts.timeout);
          }
        }
        #finish(value) {
          clearTimeout(this.#timeoutId);
          this.#value = value;
          this.#resolver();
        }
        resolve(value) {
          if (this.#isRejected || this.#isResolved) {
            return;
          }
          this.#isResolved = true;
          this.#finish(value);
        }
        reject(error) {
          if (this.#isRejected || this.#isResolved) {
            return;
          }
          this.#isRejected = true;
          this.#finish(error);
        }
        resolved() {
          return this.#isResolved;
        }
        finished() {
          return this.#isResolved || this.#isRejected;
        }
        value() {
          return this.#value;
        }
        async valueOrThrow() {
          await this.#taskPromise;
          if (this.#isRejected) {
            throw this.#value;
          }
          return this.#value;
        }
        static create(opts) {
          return new _Deferred(opts);
        }
        static async race(awaitables) {
          const deferredWithTimeout = /* @__PURE__ */ new Set();
          try {
            const promises3 = awaitables.map((value) => {
              if (value instanceof _Deferred) {
                if (value.#timeoutId) {
                  deferredWithTimeout.add(value);
                }
                return value.valueOrThrow();
              }
              return value;
            });
            return await Promise.race(promises3);
          } finally {
            for (const deferred of deferredWithTimeout) {
              deferred.reject(new Error("Timeout cleared"));
            }
          }
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js
  function isErrorLike(obj) {
    return typeof obj === "object" && obj !== null && "name" in obj && "message" in obj;
  }
  function rewriteError(error, message, originalMessage) {
    error.message = message;
    error.originalMessage = originalMessage ?? error.originalMessage;
    return error;
  }
  function createProtocolErrorMessage(object) {
    let message = object.error.message;
    if (object.error && typeof object.error === "object" && "data" in object.error) {
      message += ` ${object.error.data}`;
    }
    return message;
  }
  var init_ErrorLike = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js
  function T(r9, e9) {
    if (typeof e9 != "function" && e9 !== null)
      throw new TypeError("Class extends value " + String(e9) + " is not a constructor or null");
    Sr(r9, e9);
    function t8() {
      this.constructor = r9;
    }
    r9.prototype = e9 === null ? Object.create(e9) : (t8.prototype = e9.prototype, new t8());
  }
  function Rr(r9, e9, t8, o8) {
    function n8(i7) {
      return i7 instanceof t8 ? i7 : new t8(function(f7) {
        f7(i7);
      });
    }
    return new (t8 || (t8 = Promise))(function(i7, f7) {
      function c7(m6) {
        try {
          a8(o8.next(m6));
        } catch (h8) {
          f7(h8);
        }
      }
      function u7(m6) {
        try {
          a8(o8.throw(m6));
        } catch (h8) {
          f7(h8);
        }
      }
      function a8(m6) {
        m6.done ? i7(m6.value) : n8(m6.value).then(c7, u7);
      }
      a8((o8 = o8.apply(r9, e9 || [])).next());
    });
  }
  function $(r9, e9) {
    var t8 = { label: 0, sent: function() {
      if (i7[0] & 1)
        throw i7[1];
      return i7[1];
    }, trys: [], ops: [] }, o8, n8, i7, f7;
    return f7 = { next: c7(0), throw: c7(1), return: c7(2) }, typeof Symbol == "function" && (f7[Symbol.iterator] = function() {
      return this;
    }), f7;
    function c7(a8) {
      return function(m6) {
        return u7([a8, m6]);
      };
    }
    function u7(a8) {
      if (o8)
        throw new TypeError("Generator is already executing.");
      for (; f7 && (f7 = 0, a8[0] && (t8 = 0)), t8; )
        try {
          if (o8 = 1, n8 && (i7 = a8[0] & 2 ? n8.return : a8[0] ? n8.throw || ((i7 = n8.return) && i7.call(n8), 0) : n8.next) && !(i7 = i7.call(n8, a8[1])).done)
            return i7;
          switch (n8 = 0, i7 && (a8 = [a8[0] & 2, i7.value]), a8[0]) {
            case 0:
            case 1:
              i7 = a8;
              break;
            case 4:
              return t8.label++, { value: a8[1], done: false };
            case 5:
              t8.label++, n8 = a8[1], a8 = [0];
              continue;
            case 7:
              a8 = t8.ops.pop(), t8.trys.pop();
              continue;
            default:
              if (i7 = t8.trys, !(i7 = i7.length > 0 && i7[i7.length - 1]) && (a8[0] === 6 || a8[0] === 2)) {
                t8 = 0;
                continue;
              }
              if (a8[0] === 3 && (!i7 || a8[1] > i7[0] && a8[1] < i7[3])) {
                t8.label = a8[1];
                break;
              }
              if (a8[0] === 6 && t8.label < i7[1]) {
                t8.label = i7[1], i7 = a8;
                break;
              }
              if (i7 && t8.label < i7[2]) {
                t8.label = i7[2], t8.ops.push(a8);
                break;
              }
              i7[2] && t8.ops.pop(), t8.trys.pop();
              continue;
          }
          a8 = e9.call(r9, t8);
        } catch (m6) {
          a8 = [6, m6], n8 = 0;
        } finally {
          o8 = i7 = 0;
        }
      if (a8[0] & 5)
        throw a8[1];
      return { value: a8[0] ? a8[1] : void 0, done: true };
    }
  }
  function I(r9) {
    var e9 = typeof Symbol == "function" && Symbol.iterator, t8 = e9 && r9[e9], o8 = 0;
    if (t8)
      return t8.call(r9);
    if (r9 && typeof r9.length == "number")
      return { next: function() {
        return r9 && o8 >= r9.length && (r9 = void 0), { value: r9 && r9[o8++], done: !r9 };
      } };
    throw new TypeError(e9 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function w(r9, e9) {
    var t8 = typeof Symbol == "function" && r9[Symbol.iterator];
    if (!t8)
      return r9;
    var o8 = t8.call(r9), n8, i7 = [], f7;
    try {
      for (; (e9 === void 0 || e9-- > 0) && !(n8 = o8.next()).done; )
        i7.push(n8.value);
    } catch (c7) {
      f7 = { error: c7 };
    } finally {
      try {
        n8 && !n8.done && (t8 = o8.return) && t8.call(o8);
      } finally {
        if (f7)
          throw f7.error;
      }
    }
    return i7;
  }
  function A(r9, e9, t8) {
    if (t8 || arguments.length === 2)
      for (var o8 = 0, n8 = e9.length, i7; o8 < n8; o8++)
        (i7 || !(o8 in e9)) && (i7 || (i7 = Array.prototype.slice.call(e9, 0, o8)), i7[o8] = e9[o8]);
    return r9.concat(i7 || Array.prototype.slice.call(e9));
  }
  function C(r9) {
    return this instanceof C ? (this.v = r9, this) : new C(r9);
  }
  function Lr(r9, e9, t8) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var o8 = t8.apply(r9, e9 || []), n8, i7 = [];
    return n8 = {}, f7("next"), f7("throw"), f7("return"), n8[Symbol.asyncIterator] = function() {
      return this;
    }, n8;
    function f7(l7) {
      o8[l7] && (n8[l7] = function(y6) {
        return new Promise(function(g5, x4) {
          i7.push([l7, y6, g5, x4]) > 1 || c7(l7, y6);
        });
      });
    }
    function c7(l7, y6) {
      try {
        u7(o8[l7](y6));
      } catch (g5) {
        h8(i7[0][3], g5);
      }
    }
    function u7(l7) {
      l7.value instanceof C ? Promise.resolve(l7.value.v).then(a8, m6) : h8(i7[0][2], l7);
    }
    function a8(l7) {
      c7("next", l7);
    }
    function m6(l7) {
      c7("throw", l7);
    }
    function h8(l7, y6) {
      l7(y6), i7.shift(), i7.length && c7(i7[0][0], i7[0][1]);
    }
  }
  function Cr(r9) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var e9 = r9[Symbol.asyncIterator], t8;
    return e9 ? e9.call(r9) : (r9 = typeof I == "function" ? I(r9) : r9[Symbol.iterator](), t8 = {}, o8("next"), o8("throw"), o8("return"), t8[Symbol.asyncIterator] = function() {
      return this;
    }, t8);
    function o8(i7) {
      t8[i7] = r9[i7] && function(f7) {
        return new Promise(function(c7, u7) {
          f7 = r9[i7](f7), n8(c7, u7, f7.done, f7.value);
        });
      };
    }
    function n8(i7, f7, c7, u7) {
      Promise.resolve(u7).then(function(a8) {
        i7({ value: a8, done: c7 });
      }, f7);
    }
  }
  function p(r9) {
    return typeof r9 == "function";
  }
  function B(r9) {
    var e9 = function(o8) {
      Error.call(o8), o8.stack = new Error().stack;
    }, t8 = r9(e9);
    return t8.prototype = Object.create(Error.prototype), t8.prototype.constructor = t8, t8;
  }
  function U(r9, e9) {
    if (r9) {
      var t8 = r9.indexOf(e9);
      0 <= t8 && r9.splice(t8, 1);
    }
  }
  function er(r9) {
    return r9 instanceof W || r9 && "closed" in r9 && p(r9.remove) && p(r9.add) && p(r9.unsubscribe);
  }
  function Ur(r9) {
    p(r9) ? r9() : r9.unsubscribe();
  }
  function tr(r9) {
    D.setTimeout(function() {
      var e9 = P.onUnhandledError;
      if (e9)
        e9(r9);
      else
        throw r9;
    });
  }
  function F() {
  }
  function Wr(r9) {
    return Er("E", void 0, r9);
  }
  function Dr(r9) {
    return Er("N", r9, void 0);
  }
  function Er(r9, e9, t8) {
    return { kind: r9, value: e9, error: t8 };
  }
  function Yr(r9) {
    if (P.useDeprecatedSynchronousErrorHandling) {
      var e9 = !V;
      if (e9 && (V = { errorThrown: false, error: null }), r9(), e9) {
        var t8 = V, o8 = t8.errorThrown, n8 = t8.error;
        if (V = null, o8)
          throw n8;
      }
    } else
      r9();
  }
  function qr(r9) {
    P.useDeprecatedSynchronousErrorHandling && V && (V.errorThrown = true, V.error = r9);
  }
  function Or(r9, e9) {
    return Fe.call(r9, e9);
  }
  function or(r9) {
    P.useDeprecatedSynchronousErrorHandling ? qr(r9) : tr(r9);
  }
  function ke(r9) {
    throw r9;
  }
  function Ar(r9, e9) {
    var t8 = P.onStoppedNotification;
    t8 && D.setTimeout(function() {
      return t8(r9, e9);
    });
  }
  function S(r9) {
    return r9;
  }
  function Nr() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    return _r(r9);
  }
  function _r(r9) {
    return r9.length === 0 ? S : r9.length === 1 ? r9[0] : function(t8) {
      return r9.reduce(function(o8, n8) {
        return n8(o8);
      }, t8);
    };
  }
  function Gr(r9) {
    var e9;
    return (e9 = r9 ?? P.Promise) !== null && e9 !== void 0 ? e9 : Promise;
  }
  function Re(r9) {
    return r9 && p(r9.next) && p(r9.error) && p(r9.complete);
  }
  function Le(r9) {
    return r9 && r9 instanceof K || Re(r9) && er(r9);
  }
  function Ce(r9) {
    return p(r9 == null ? void 0 : r9.lift);
  }
  function d(r9) {
    return function(e9) {
      if (Ce(e9))
        return e9.lift(function(t8) {
          try {
            return r9(t8, this);
          } catch (o8) {
            this.error(o8);
          }
        });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function s(r9, e9, t8, o8, n8) {
    return new Ue(r9, e9, t8, o8, n8);
  }
  function nr(r9) {
    return r9 && p(r9.schedule);
  }
  function Fr(r9) {
    return r9[r9.length - 1];
  }
  function Qr(r9) {
    return p(Fr(r9)) ? r9.pop() : void 0;
  }
  function R(r9) {
    return nr(Fr(r9)) ? r9.pop() : void 0;
  }
  function Xr(r9, e9) {
    return typeof Fr(r9) == "number" ? r9.pop() : e9;
  }
  function ir(r9) {
    return p(r9 == null ? void 0 : r9.then);
  }
  function fr(r9) {
    return p(r9[q]);
  }
  function ar(r9) {
    return Symbol.asyncIterator && p(r9 == null ? void 0 : r9[Symbol.asyncIterator]);
  }
  function ur(r9) {
    return new TypeError("You provided " + (r9 !== null && typeof r9 == "object" ? "an invalid object" : "'" + r9 + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }
  function Ve() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
  }
  function pr(r9) {
    return p(r9 == null ? void 0 : r9[cr]);
  }
  function mr(r9) {
    return Lr(this, arguments, function() {
      var t8, o8, n8, i7;
      return $(this, function(f7) {
        switch (f7.label) {
          case 0:
            t8 = r9.getReader(), f7.label = 1;
          case 1:
            f7.trys.push([1, , 9, 10]), f7.label = 2;
          case 2:
            return [4, C(t8.read())];
          case 3:
            return o8 = f7.sent(), n8 = o8.value, i7 = o8.done, i7 ? [4, C(void 0)] : [3, 5];
          case 4:
            return [2, f7.sent()];
          case 5:
            return [4, C(n8)];
          case 6:
            return [4, f7.sent()];
          case 7:
            return f7.sent(), [3, 2];
          case 8:
            return [3, 10];
          case 9:
            return t8.releaseLock(), [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function sr(r9) {
    return p(r9 == null ? void 0 : r9.getReader);
  }
  function v(r9) {
    if (r9 instanceof b)
      return r9;
    if (r9 != null) {
      if (fr(r9))
        return We(r9);
      if (G(r9))
        return De(r9);
      if (ir(r9))
        return Ye(r9);
      if (ar(r9))
        return Zr(r9);
      if (pr(r9))
        return qe(r9);
      if (sr(r9))
        return Ne(r9);
    }
    throw ur(r9);
  }
  function We(r9) {
    return new b(function(e9) {
      var t8 = r9[q]();
      if (p(t8.subscribe))
        return t8.subscribe(e9);
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function De(r9) {
    return new b(function(e9) {
      for (var t8 = 0; t8 < r9.length && !e9.closed; t8++)
        e9.next(r9[t8]);
      e9.complete();
    });
  }
  function Ye(r9) {
    return new b(function(e9) {
      r9.then(function(t8) {
        e9.closed || (e9.next(t8), e9.complete());
      }, function(t8) {
        return e9.error(t8);
      }).then(null, tr);
    });
  }
  function qe(r9) {
    return new b(function(e9) {
      var t8, o8;
      try {
        for (var n8 = I(r9), i7 = n8.next(); !i7.done; i7 = n8.next()) {
          var f7 = i7.value;
          if (e9.next(f7), e9.closed)
            return;
        }
      } catch (c7) {
        t8 = { error: c7 };
      } finally {
        try {
          i7 && !i7.done && (o8 = n8.return) && o8.call(n8);
        } finally {
          if (t8)
            throw t8.error;
        }
      }
      e9.complete();
    });
  }
  function Zr(r9) {
    return new b(function(e9) {
      Ge(r9, e9).catch(function(t8) {
        return e9.error(t8);
      });
    });
  }
  function Ne(r9) {
    return Zr(mr(r9));
  }
  function Ge(r9, e9) {
    var t8, o8, n8, i7;
    return Rr(this, void 0, void 0, function() {
      var f7, c7;
      return $(this, function(u7) {
        switch (u7.label) {
          case 0:
            u7.trys.push([0, 5, 6, 11]), t8 = Cr(r9), u7.label = 1;
          case 1:
            return [4, t8.next()];
          case 2:
            if (o8 = u7.sent(), !!o8.done)
              return [3, 4];
            if (f7 = o8.value, e9.next(f7), e9.closed)
              return [2];
            u7.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            return c7 = u7.sent(), n8 = { error: c7 }, [3, 11];
          case 6:
            return u7.trys.push([6, , 9, 10]), o8 && !o8.done && (i7 = t8.return) ? [4, i7.call(t8)] : [3, 8];
          case 7:
            u7.sent(), u7.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (n8)
              throw n8.error;
            return [7];
          case 10:
            return [7];
          case 11:
            return e9.complete(), [2];
        }
      });
    });
  }
  function _(r9, e9, t8, o8, n8) {
    o8 === void 0 && (o8 = 0), n8 === void 0 && (n8 = false);
    var i7 = e9.schedule(function() {
      t8(), n8 ? r9.add(this.schedule(null, o8)) : this.unsubscribe();
    }, o8);
    if (r9.add(i7), !n8)
      return i7;
  }
  function lr(r9, e9) {
    return e9 === void 0 && (e9 = 0), d(function(t8, o8) {
      t8.subscribe(s(o8, function(n8) {
        return _(o8, r9, function() {
          return o8.next(n8);
        }, e9);
      }, function() {
        return _(o8, r9, function() {
          return o8.complete();
        }, e9);
      }, function(n8) {
        return _(o8, r9, function() {
          return o8.error(n8);
        }, e9);
      }));
    });
  }
  function dr(r9, e9) {
    return e9 === void 0 && (e9 = 0), d(function(t8, o8) {
      o8.add(r9.schedule(function() {
        return t8.subscribe(o8);
      }, e9));
    });
  }
  function $r(r9, e9) {
    return v(r9).pipe(dr(e9), lr(e9));
  }
  function Br(r9, e9) {
    return v(r9).pipe(dr(e9), lr(e9));
  }
  function re(r9, e9) {
    return new b(function(t8) {
      var o8 = 0;
      return e9.schedule(function() {
        o8 === r9.length ? t8.complete() : (t8.next(r9[o8++]), t8.closed || this.schedule());
      });
    });
  }
  function ee(r9, e9) {
    return new b(function(t8) {
      var o8;
      return _(t8, e9, function() {
        o8 = r9[cr](), _(t8, e9, function() {
          var n8, i7, f7;
          try {
            n8 = o8.next(), i7 = n8.value, f7 = n8.done;
          } catch (c7) {
            t8.error(c7);
            return;
          }
          f7 ? t8.complete() : t8.next(i7);
        }, 0, true);
      }), function() {
        return p(o8 == null ? void 0 : o8.return) && o8.return();
      };
    });
  }
  function hr(r9, e9) {
    if (!r9)
      throw new Error("Iterable cannot be null");
    return new b(function(t8) {
      _(t8, e9, function() {
        var o8 = r9[Symbol.asyncIterator]();
        _(t8, e9, function() {
          o8.next().then(function(n8) {
            n8.done ? t8.complete() : t8.next(n8.value);
          });
        }, 0, true);
      });
    });
  }
  function te(r9, e9) {
    return hr(mr(r9), e9);
  }
  function oe(r9, e9) {
    if (r9 != null) {
      if (fr(r9))
        return $r(r9, e9);
      if (G(r9))
        return re(r9, e9);
      if (ir(r9))
        return Br(r9, e9);
      if (ar(r9))
        return hr(r9, e9);
      if (pr(r9))
        return ee(r9, e9);
      if (sr(r9))
        return te(r9, e9);
    }
    throw ur(r9);
  }
  function j(r9, e9) {
    return e9 ? oe(r9, e9) : v(r9);
  }
  function ne() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    var t8 = R(r9);
    return j(r9, t8);
  }
  function ie(r9, e9) {
    var t8 = typeof e9 == "object";
    return new Promise(function(o8, n8) {
      var i7 = false, f7;
      r9.subscribe({ next: function(c7) {
        f7 = c7, i7 = true;
      }, error: n8, complete: function() {
        i7 ? o8(f7) : t8 ? o8(e9.defaultValue) : n8(new L());
      } });
    });
  }
  function fe(r9, e9) {
    var t8 = typeof e9 == "object";
    return new Promise(function(o8, n8) {
      var i7 = new Y({ next: function(f7) {
        o8(f7), i7.unsubscribe();
      }, error: n8, complete: function() {
        t8 ? o8(e9.defaultValue) : n8(new L());
      } });
      r9.subscribe(i7);
    });
  }
  function ae(r9) {
    return r9 instanceof Date && !isNaN(r9);
  }
  function k(r9, e9) {
    return d(function(t8, o8) {
      var n8 = 0;
      t8.subscribe(s(o8, function(i7) {
        o8.next(r9.call(e9, i7, n8++));
      }));
    });
  }
  function Je(r9, e9) {
    return He(e9) ? r9.apply(void 0, A([], w(e9))) : r9(e9);
  }
  function vr(r9) {
    return k(function(e9) {
      return Je(r9, e9);
    });
  }
  function ue(r9) {
    if (r9.length === 1) {
      var e9 = r9[0];
      if (Ke(e9))
        return { args: e9, keys: null };
      if (Ze(e9)) {
        var t8 = Xe(e9);
        return { args: t8.map(function(o8) {
          return e9[o8];
        }), keys: t8 };
      }
    }
    return { args: r9, keys: null };
  }
  function Ze(r9) {
    return r9 && typeof r9 == "object" && ze(r9) === Qe;
  }
  function ce(r9, e9) {
    return r9.reduce(function(t8, o8, n8) {
      return t8[o8] = e9[n8], t8;
    }, {});
  }
  function pe(r9, e9, t8, o8, n8, i7, f7, c7) {
    var u7 = [], a8 = 0, m6 = 0, h8 = false, l7 = function() {
      h8 && !u7.length && !a8 && e9.complete();
    }, y6 = function(x4) {
      return a8 < o8 ? g5(x4) : u7.push(x4);
    }, g5 = function(x4) {
      i7 && e9.next(x4), a8++;
      var O5 = false;
      v(t8(x4, m6++)).subscribe(s(e9, function(M4) {
        n8 == null || n8(M4), i7 ? y6(M4) : e9.next(M4);
      }, function() {
        O5 = true;
      }, void 0, function() {
        if (O5)
          try {
            a8--;
            for (var M4 = function() {
              var Z3 = u7.shift();
              f7 ? _(e9, f7, function() {
                return g5(Z3);
              }) : g5(Z3);
            }; u7.length && a8 < o8; )
              M4();
            l7();
          } catch (Z3) {
            e9.error(Z3);
          }
      }));
    };
    return r9.subscribe(s(e9, y6, function() {
      h8 = true, l7();
    })), function() {
      c7 == null || c7();
    };
  }
  function E(r9, e9, t8) {
    return t8 === void 0 && (t8 = 1 / 0), p(e9) ? E(function(o8, n8) {
      return k(function(i7, f7) {
        return e9(o8, i7, n8, f7);
      })(v(r9(o8, n8)));
    }, t8) : (typeof e9 == "number" && (t8 = e9), d(function(o8, n8) {
      return pe(o8, n8, r9, t8);
    }));
  }
  function yr(r9) {
    return r9 === void 0 && (r9 = 1 / 0), E(S, r9);
  }
  function me() {
    return yr(1);
  }
  function Q() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    return me()(j(r9, R(r9)));
  }
  function se(r9) {
    return new b(function(e9) {
      v(r9()).subscribe(e9);
    });
  }
  function le() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    var t8 = Qr(r9), o8 = ue(r9), n8 = o8.args, i7 = o8.keys, f7 = new b(function(c7) {
      var u7 = n8.length;
      if (!u7) {
        c7.complete();
        return;
      }
      for (var a8 = new Array(u7), m6 = u7, h8 = u7, l7 = function(g5) {
        var x4 = false;
        v(n8[g5]).subscribe(s(c7, function(O5) {
          x4 || (x4 = true, h8--), a8[g5] = O5;
        }, function() {
          return m6--;
        }, void 0, function() {
          (!m6 || !x4) && (h8 || c7.next(i7 ? ce(i7, a8) : a8), c7.complete());
        }));
      }, y6 = 0; y6 < u7; y6++)
        l7(y6);
    });
    return t8 ? f7.pipe(vr(t8)) : f7;
  }
  function xr(r9, e9, t8, o8) {
    if (p(t8) && (o8 = t8, t8 = void 0), o8)
      return xr(r9, e9, t8).pipe(vr(o8));
    var n8 = w(ot(r9) ? Be.map(function(c7) {
      return function(u7) {
        return r9[c7](e9, u7, t8);
      };
    }) : et(r9) ? $e.map(de(r9, e9)) : tt(r9) ? rt.map(de(r9, e9)) : [], 2), i7 = n8[0], f7 = n8[1];
    if (!i7 && G(r9))
      return E(function(c7) {
        return xr(c7, e9, t8);
      })(v(r9));
    if (!i7)
      throw new TypeError("Invalid event target");
    return new b(function(c7) {
      var u7 = function() {
        for (var a8 = [], m6 = 0; m6 < arguments.length; m6++)
          a8[m6] = arguments[m6];
        return c7.next(1 < a8.length ? a8 : a8[0]);
      };
      return i7(u7), function() {
        return f7(u7);
      };
    });
  }
  function de(r9, e9) {
    return function(t8) {
      return function(o8) {
        return r9[t8](e9, o8);
      };
    };
  }
  function et(r9) {
    return p(r9.addListener) && p(r9.removeListener);
  }
  function tt(r9) {
    return p(r9.on) && p(r9.off);
  }
  function ot(r9) {
    return p(r9.addEventListener) && p(r9.removeEventListener);
  }
  function H(r9, e9, t8) {
    r9 === void 0 && (r9 = 0), t8 === void 0 && (t8 = zr);
    var o8 = -1;
    return e9 != null && (nr(e9) ? t8 = e9 : o8 = e9), new b(function(n8) {
      var i7 = ae(r9) ? +r9 - t8.now() : r9;
      i7 < 0 && (i7 = 0);
      var f7 = 0;
      return t8.schedule(function() {
        n8.closed || (n8.next(f7++), 0 <= o8 ? this.schedule(void 0, o8) : n8.complete());
      }, i7);
    });
  }
  function he() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    var t8 = R(r9), o8 = Xr(r9, 1 / 0), n8 = r9;
    return n8.length ? n8.length === 1 ? v(n8[0]) : yr(o8)(j(n8, t8)) : N;
  }
  function ye(r9) {
    return r9.length === 1 && nt(r9[0]) ? r9[0] : r9;
  }
  function J(r9, e9) {
    return d(function(t8, o8) {
      var n8 = 0;
      t8.subscribe(s(o8, function(i7) {
        return r9.call(e9, i7, n8++) && o8.next(i7);
      }));
    });
  }
  function xe() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    return r9 = ye(r9), r9.length === 1 ? v(r9[0]) : new b(jr(r9));
  }
  function jr(r9) {
    return function(e9) {
      for (var t8 = [], o8 = function(i7) {
        t8.push(v(r9[i7]).subscribe(s(e9, function(f7) {
          if (t8) {
            for (var c7 = 0; c7 < t8.length; c7++)
              c7 !== i7 && t8[c7].unsubscribe();
            t8 = null;
          }
          e9.next(f7);
        })));
      }, n8 = 0; t8 && !e9.closed && n8 < r9.length; n8++)
        o8(n8);
    };
  }
  function be(r9, e9) {
    return e9 === void 0 && (e9 = null), e9 = e9 ?? r9, d(function(t8, o8) {
      var n8 = [], i7 = 0;
      t8.subscribe(s(o8, function(f7) {
        var c7, u7, a8, m6, h8 = null;
        i7++ % e9 === 0 && n8.push([]);
        try {
          for (var l7 = I(n8), y6 = l7.next(); !y6.done; y6 = l7.next()) {
            var g5 = y6.value;
            g5.push(f7), r9 <= g5.length && (h8 = h8 ?? [], h8.push(g5));
          }
        } catch (M4) {
          c7 = { error: M4 };
        } finally {
          try {
            y6 && !y6.done && (u7 = l7.return) && u7.call(l7);
          } finally {
            if (c7)
              throw c7.error;
          }
        }
        if (h8)
          try {
            for (var x4 = I(h8), O5 = x4.next(); !O5.done; O5 = x4.next()) {
              var g5 = O5.value;
              U(n8, g5), o8.next(g5);
            }
          } catch (M4) {
            a8 = { error: M4 };
          } finally {
            try {
              O5 && !O5.done && (m6 = x4.return) && m6.call(x4);
            } finally {
              if (a8)
                throw a8.error;
            }
          }
      }, function() {
        var f7, c7;
        try {
          for (var u7 = I(n8), a8 = u7.next(); !a8.done; a8 = u7.next()) {
            var m6 = a8.value;
            o8.next(m6);
          }
        } catch (h8) {
          f7 = { error: h8 };
        } finally {
          try {
            a8 && !a8.done && (c7 = u7.return) && c7.call(u7);
          } finally {
            if (f7)
              throw f7.error;
          }
        }
        o8.complete();
      }, void 0, function() {
        n8 = null;
      }));
    });
  }
  function kr(r9) {
    return d(function(e9, t8) {
      var o8 = null, n8 = false, i7;
      o8 = e9.subscribe(s(t8, void 0, void 0, function(f7) {
        i7 = v(r9(f7, kr(r9)(e9))), o8 ? (o8.unsubscribe(), o8 = null, i7.subscribe(t8)) : n8 = true;
      })), n8 && (o8.unsubscribe(), o8 = null, i7.subscribe(t8));
    });
  }
  function ge(r9, e9) {
    return p(e9) ? E(r9, e9, 1) : E(r9, 1);
  }
  function br(r9) {
    return d(function(e9, t8) {
      var o8 = false;
      e9.subscribe(s(t8, function(n8) {
        o8 = true, t8.next(n8);
      }, function() {
        o8 || t8.next(r9), t8.complete();
      }));
    });
  }
  function X(r9) {
    return r9 <= 0 ? function() {
      return N;
    } : d(function(e9, t8) {
      var o8 = 0;
      e9.subscribe(s(t8, function(n8) {
        ++o8 <= r9 && (t8.next(n8), r9 <= o8 && t8.complete());
      }));
    });
  }
  function gr() {
    return d(function(r9, e9) {
      r9.subscribe(s(e9, F));
    });
  }
  function we(r9) {
    return k(function() {
      return r9;
    });
  }
  function Mr(r9, e9) {
    return e9 ? function(t8) {
      return Q(e9.pipe(X(1), gr()), t8.pipe(Mr(r9)));
    } : E(function(t8, o8) {
      return v(r9(t8, o8)).pipe(X(1), we(t8));
    });
  }
  function Se(r9, e9) {
    e9 === void 0 && (e9 = Pr);
    var t8 = H(r9, e9);
    return Mr(function() {
      return t8;
    });
  }
  function wr(r9) {
    return r9 === void 0 && (r9 = it), d(function(e9, t8) {
      var o8 = false;
      e9.subscribe(s(t8, function(n8) {
        o8 = true, t8.next(n8);
      }, function() {
        return o8 ? t8.complete() : t8.error(r9());
      }));
    });
  }
  function it() {
    return new L();
  }
  function Ee(r9, e9) {
    var t8 = arguments.length >= 2;
    return function(o8) {
      return o8.pipe(r9 ? J(function(n8, i7) {
        return r9(n8, i7, o8);
      }) : S, X(1), t8 ? br(e9) : wr(function() {
        return new L();
      }));
    };
  }
  function Oe() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    return r9.length ? d(function(t8, o8) {
      jr(A([t8], w(r9)))(o8);
    }) : S;
  }
  function Ae(r9) {
    r9 === void 0 && (r9 = 1 / 0);
    var e9;
    r9 && typeof r9 == "object" ? e9 = r9 : e9 = { count: r9 };
    var t8 = e9.count, o8 = t8 === void 0 ? 1 / 0 : t8, n8 = e9.delay, i7 = e9.resetOnSuccess, f7 = i7 === void 0 ? false : i7;
    return o8 <= 0 ? S : d(function(c7, u7) {
      var a8 = 0, m6, h8 = function() {
        var l7 = false;
        m6 = c7.subscribe(s(u7, function(y6) {
          f7 && (a8 = 0), u7.next(y6);
        }, void 0, function(y6) {
          if (a8++ < o8) {
            var g5 = function() {
              m6 ? (m6.unsubscribe(), m6 = null, h8()) : l7 = true;
            };
            if (n8 != null) {
              var x4 = typeof n8 == "number" ? H(n8) : v(n8(y6, a8)), O5 = s(u7, function() {
                O5.unsubscribe(), g5();
              }, function() {
                u7.complete();
              });
              x4.subscribe(O5);
            } else
              g5();
          } else
            u7.error(y6);
        })), l7 && (m6.unsubscribe(), m6 = null, h8());
      };
      h8();
    });
  }
  function _e() {
    for (var r9 = [], e9 = 0; e9 < arguments.length; e9++)
      r9[e9] = arguments[e9];
    var t8 = R(r9);
    return d(function(o8, n8) {
      (t8 ? Q(r9, o8, t8) : Q(r9, o8)).subscribe(n8);
    });
  }
  function Ie(r9, e9) {
    return d(function(t8, o8) {
      var n8 = null, i7 = 0, f7 = false, c7 = function() {
        return f7 && !n8 && o8.complete();
      };
      t8.subscribe(s(o8, function(u7) {
        n8 == null || n8.unsubscribe();
        var a8 = 0, m6 = i7++;
        v(r9(u7, m6)).subscribe(n8 = s(o8, function(h8) {
          return o8.next(e9 ? e9(u7, h8, m6, a8++) : h8);
        }, function() {
          n8 = null, c7();
        }));
      }, function() {
        f7 = true, c7();
      }));
    });
  }
  function Te(r9) {
    return d(function(e9, t8) {
      v(r9).subscribe(s(t8, function() {
        return t8.complete();
      }, F)), !t8.closed && e9.subscribe(t8);
    });
  }
  function Pe(r9, e9, t8) {
    var o8 = p(r9) || e9 || t8 ? { next: r9, error: e9, complete: t8 } : r9;
    return o8 ? d(function(n8, i7) {
      var f7;
      (f7 = o8.subscribe) === null || f7 === void 0 || f7.call(o8);
      var c7 = true;
      n8.subscribe(s(i7, function(u7) {
        var a8;
        (a8 = o8.next) === null || a8 === void 0 || a8.call(o8, u7), i7.next(u7);
      }, function() {
        var u7;
        c7 = false, (u7 = o8.complete) === null || u7 === void 0 || u7.call(o8), i7.complete();
      }, function(u7) {
        var a8;
        c7 = false, (a8 = o8.error) === null || a8 === void 0 || a8.call(o8, u7), i7.error(u7);
      }, function() {
        var u7, a8;
        c7 && ((u7 = o8.unsubscribe) === null || u7 === void 0 || u7.call(o8)), (a8 = o8.finalize) === null || a8 === void 0 || a8.call(o8);
      }));
    }) : S;
  }
  function Au(r9) {
    return E((e9) => j(Promise.resolve(r9(e9))).pipe(J((t8) => t8), k(() => e9)));
  }
  var Sr, rr, W, vt, P, D, Vr, V, K, Fe, je, Y, Me, q, b, Ue, Ir, Hr, z, Jr, Tr, Kr, Pr, zr, N, G, cr, L, He, Ke, ze, Qe, Xe, $e, Be, rt, ve, nt;
  var init_rxjs = __esm({
    "node_modules/puppeteer-core/lib/esm/third_party/rxjs/rxjs.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Sr = function(r9, e9) {
        return Sr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t8, o8) {
          t8.__proto__ = o8;
        } || function(t8, o8) {
          for (var n8 in o8)
            Object.prototype.hasOwnProperty.call(o8, n8) && (t8[n8] = o8[n8]);
        }, Sr(r9, e9);
      };
      rr = B(function(r9) {
        return function(t8) {
          r9(this), this.message = t8 ? t8.length + ` errors occurred during unsubscription:
` + t8.map(function(o8, n8) {
            return n8 + 1 + ") " + o8.toString();
          }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = t8;
        };
      });
      W = function() {
        function r9(e9) {
          this.initialTeardown = e9, this.closed = false, this._parentage = null, this._finalizers = null;
        }
        return r9.prototype.unsubscribe = function() {
          var e9, t8, o8, n8, i7;
          if (!this.closed) {
            this.closed = true;
            var f7 = this._parentage;
            if (f7)
              if (this._parentage = null, Array.isArray(f7))
                try {
                  for (var c7 = I(f7), u7 = c7.next(); !u7.done; u7 = c7.next()) {
                    var a8 = u7.value;
                    a8.remove(this);
                  }
                } catch (x4) {
                  e9 = { error: x4 };
                } finally {
                  try {
                    u7 && !u7.done && (t8 = c7.return) && t8.call(c7);
                  } finally {
                    if (e9)
                      throw e9.error;
                  }
                }
              else
                f7.remove(this);
            var m6 = this.initialTeardown;
            if (p(m6))
              try {
                m6();
              } catch (x4) {
                i7 = x4 instanceof rr ? x4.errors : [x4];
              }
            var h8 = this._finalizers;
            if (h8) {
              this._finalizers = null;
              try {
                for (var l7 = I(h8), y6 = l7.next(); !y6.done; y6 = l7.next()) {
                  var g5 = y6.value;
                  try {
                    Ur(g5);
                  } catch (x4) {
                    i7 = i7 ?? [], x4 instanceof rr ? i7 = A(A([], w(i7)), w(x4.errors)) : i7.push(x4);
                  }
                }
              } catch (x4) {
                o8 = { error: x4 };
              } finally {
                try {
                  y6 && !y6.done && (n8 = l7.return) && n8.call(l7);
                } finally {
                  if (o8)
                    throw o8.error;
                }
              }
            }
            if (i7)
              throw new rr(i7);
          }
        }, r9.prototype.add = function(e9) {
          var t8;
          if (e9 && e9 !== this)
            if (this.closed)
              Ur(e9);
            else {
              if (e9 instanceof r9) {
                if (e9.closed || e9._hasParent(this))
                  return;
                e9._addParent(this);
              }
              (this._finalizers = (t8 = this._finalizers) !== null && t8 !== void 0 ? t8 : []).push(e9);
            }
        }, r9.prototype._hasParent = function(e9) {
          var t8 = this._parentage;
          return t8 === e9 || Array.isArray(t8) && t8.includes(e9);
        }, r9.prototype._addParent = function(e9) {
          var t8 = this._parentage;
          this._parentage = Array.isArray(t8) ? (t8.push(e9), t8) : t8 ? [t8, e9] : e9;
        }, r9.prototype._removeParent = function(e9) {
          var t8 = this._parentage;
          t8 === e9 ? this._parentage = null : Array.isArray(t8) && U(t8, e9);
        }, r9.prototype.remove = function(e9) {
          var t8 = this._finalizers;
          t8 && U(t8, e9), e9 instanceof r9 && e9._removeParent(this);
        }, r9.EMPTY = function() {
          var e9 = new r9();
          return e9.closed = true, e9;
        }(), r9;
      }();
      vt = W.EMPTY;
      P = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: false, useDeprecatedNextContext: false };
      D = { setTimeout: function(r9, e9) {
        for (var t8 = [], o8 = 2; o8 < arguments.length; o8++)
          t8[o8 - 2] = arguments[o8];
        var n8 = D.delegate;
        return n8 != null && n8.setTimeout ? n8.setTimeout.apply(n8, A([r9, e9], w(t8))) : setTimeout.apply(void 0, A([r9, e9], w(t8)));
      }, clearTimeout: function(r9) {
        var e9 = D.delegate;
        return ((e9 == null ? void 0 : e9.clearTimeout) || clearTimeout)(r9);
      }, delegate: void 0 };
      Vr = function() {
        return Er("C", void 0, void 0);
      }();
      V = null;
      K = function(r9) {
        T(e9, r9);
        function e9(t8) {
          var o8 = r9.call(this) || this;
          return o8.isStopped = false, t8 ? (o8.destination = t8, er(t8) && t8.add(o8)) : o8.destination = Me, o8;
        }
        return e9.create = function(t8, o8, n8) {
          return new Y(t8, o8, n8);
        }, e9.prototype.next = function(t8) {
          this.isStopped ? Ar(Dr(t8), this) : this._next(t8);
        }, e9.prototype.error = function(t8) {
          this.isStopped ? Ar(Wr(t8), this) : (this.isStopped = true, this._error(t8));
        }, e9.prototype.complete = function() {
          this.isStopped ? Ar(Vr, this) : (this.isStopped = true, this._complete());
        }, e9.prototype.unsubscribe = function() {
          this.closed || (this.isStopped = true, r9.prototype.unsubscribe.call(this), this.destination = null);
        }, e9.prototype._next = function(t8) {
          this.destination.next(t8);
        }, e9.prototype._error = function(t8) {
          try {
            this.destination.error(t8);
          } finally {
            this.unsubscribe();
          }
        }, e9.prototype._complete = function() {
          try {
            this.destination.complete();
          } finally {
            this.unsubscribe();
          }
        }, e9;
      }(W);
      Fe = Function.prototype.bind;
      je = function() {
        function r9(e9) {
          this.partialObserver = e9;
        }
        return r9.prototype.next = function(e9) {
          var t8 = this.partialObserver;
          if (t8.next)
            try {
              t8.next(e9);
            } catch (o8) {
              or(o8);
            }
        }, r9.prototype.error = function(e9) {
          var t8 = this.partialObserver;
          if (t8.error)
            try {
              t8.error(e9);
            } catch (o8) {
              or(o8);
            }
          else
            or(e9);
        }, r9.prototype.complete = function() {
          var e9 = this.partialObserver;
          if (e9.complete)
            try {
              e9.complete();
            } catch (t8) {
              or(t8);
            }
        }, r9;
      }();
      Y = function(r9) {
        T(e9, r9);
        function e9(t8, o8, n8) {
          var i7 = r9.call(this) || this, f7;
          if (p(t8) || !t8)
            f7 = { next: t8 ?? void 0, error: o8 ?? void 0, complete: n8 ?? void 0 };
          else {
            var c7;
            i7 && P.useDeprecatedNextContext ? (c7 = Object.create(t8), c7.unsubscribe = function() {
              return i7.unsubscribe();
            }, f7 = { next: t8.next && Or(t8.next, c7), error: t8.error && Or(t8.error, c7), complete: t8.complete && Or(t8.complete, c7) }) : f7 = t8;
          }
          return i7.destination = new je(f7), i7;
        }
        return e9;
      }(K);
      Me = { closed: true, next: F, error: ke, complete: F };
      q = function() {
        return typeof Symbol == "function" && Symbol.observable || "@@observable";
      }();
      b = function() {
        function r9(e9) {
          e9 && (this._subscribe = e9);
        }
        return r9.prototype.lift = function(e9) {
          var t8 = new r9();
          return t8.source = this, t8.operator = e9, t8;
        }, r9.prototype.subscribe = function(e9, t8, o8) {
          var n8 = this, i7 = Le(e9) ? e9 : new Y(e9, t8, o8);
          return Yr(function() {
            var f7 = n8, c7 = f7.operator, u7 = f7.source;
            i7.add(c7 ? c7.call(i7, u7) : u7 ? n8._subscribe(i7) : n8._trySubscribe(i7));
          }), i7;
        }, r9.prototype._trySubscribe = function(e9) {
          try {
            return this._subscribe(e9);
          } catch (t8) {
            e9.error(t8);
          }
        }, r9.prototype.forEach = function(e9, t8) {
          var o8 = this;
          return t8 = Gr(t8), new t8(function(n8, i7) {
            var f7 = new Y({ next: function(c7) {
              try {
                e9(c7);
              } catch (u7) {
                i7(u7), f7.unsubscribe();
              }
            }, error: i7, complete: n8 });
            o8.subscribe(f7);
          });
        }, r9.prototype._subscribe = function(e9) {
          var t8;
          return (t8 = this.source) === null || t8 === void 0 ? void 0 : t8.subscribe(e9);
        }, r9.prototype[q] = function() {
          return this;
        }, r9.prototype.pipe = function() {
          for (var e9 = [], t8 = 0; t8 < arguments.length; t8++)
            e9[t8] = arguments[t8];
          return _r(e9)(this);
        }, r9.prototype.toPromise = function(e9) {
          var t8 = this;
          return e9 = Gr(e9), new e9(function(o8, n8) {
            var i7;
            t8.subscribe(function(f7) {
              return i7 = f7;
            }, function(f7) {
              return n8(f7);
            }, function() {
              return o8(i7);
            });
          });
        }, r9.create = function(e9) {
          return new r9(e9);
        }, r9;
      }();
      Ue = function(r9) {
        T(e9, r9);
        function e9(t8, o8, n8, i7, f7, c7) {
          var u7 = r9.call(this, t8) || this;
          return u7.onFinalize = f7, u7.shouldUnsubscribe = c7, u7._next = o8 ? function(a8) {
            try {
              o8(a8);
            } catch (m6) {
              t8.error(m6);
            }
          } : r9.prototype._next, u7._error = i7 ? function(a8) {
            try {
              i7(a8);
            } catch (m6) {
              t8.error(m6);
            } finally {
              this.unsubscribe();
            }
          } : r9.prototype._error, u7._complete = n8 ? function() {
            try {
              n8();
            } catch (a8) {
              t8.error(a8);
            } finally {
              this.unsubscribe();
            }
          } : r9.prototype._complete, u7;
        }
        return e9.prototype.unsubscribe = function() {
          var t8;
          if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var o8 = this.closed;
            r9.prototype.unsubscribe.call(this), !o8 && ((t8 = this.onFinalize) === null || t8 === void 0 || t8.call(this));
          }
        }, e9;
      }(K);
      Ir = { now: function() {
        return (Ir.delegate || Date).now();
      }, delegate: void 0 };
      Hr = function(r9) {
        T(e9, r9);
        function e9(t8, o8) {
          return r9.call(this) || this;
        }
        return e9.prototype.schedule = function(t8, o8) {
          return o8 === void 0 && (o8 = 0), this;
        }, e9;
      }(W);
      z = { setInterval: function(r9, e9) {
        for (var t8 = [], o8 = 2; o8 < arguments.length; o8++)
          t8[o8 - 2] = arguments[o8];
        var n8 = z.delegate;
        return n8 != null && n8.setInterval ? n8.setInterval.apply(n8, A([r9, e9], w(t8))) : setInterval.apply(void 0, A([r9, e9], w(t8)));
      }, clearInterval: function(r9) {
        var e9 = z.delegate;
        return ((e9 == null ? void 0 : e9.clearInterval) || clearInterval)(r9);
      }, delegate: void 0 };
      Jr = function(r9) {
        T(e9, r9);
        function e9(t8, o8) {
          var n8 = r9.call(this, t8, o8) || this;
          return n8.scheduler = t8, n8.work = o8, n8.pending = false, n8;
        }
        return e9.prototype.schedule = function(t8, o8) {
          var n8;
          if (o8 === void 0 && (o8 = 0), this.closed)
            return this;
          this.state = t8;
          var i7 = this.id, f7 = this.scheduler;
          return i7 != null && (this.id = this.recycleAsyncId(f7, i7, o8)), this.pending = true, this.delay = o8, this.id = (n8 = this.id) !== null && n8 !== void 0 ? n8 : this.requestAsyncId(f7, this.id, o8), this;
        }, e9.prototype.requestAsyncId = function(t8, o8, n8) {
          return n8 === void 0 && (n8 = 0), z.setInterval(t8.flush.bind(t8, this), n8);
        }, e9.prototype.recycleAsyncId = function(t8, o8, n8) {
          if (n8 === void 0 && (n8 = 0), n8 != null && this.delay === n8 && this.pending === false)
            return o8;
          o8 != null && z.clearInterval(o8);
        }, e9.prototype.execute = function(t8, o8) {
          if (this.closed)
            return new Error("executing a cancelled action");
          this.pending = false;
          var n8 = this._execute(t8, o8);
          if (n8)
            return n8;
          this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }, e9.prototype._execute = function(t8, o8) {
          var n8 = false, i7;
          try {
            this.work(t8);
          } catch (f7) {
            n8 = true, i7 = f7 || new Error("Scheduled action threw falsy error");
          }
          if (n8)
            return this.unsubscribe(), i7;
        }, e9.prototype.unsubscribe = function() {
          if (!this.closed) {
            var t8 = this, o8 = t8.id, n8 = t8.scheduler, i7 = n8.actions;
            this.work = this.state = this.scheduler = null, this.pending = false, U(i7, this), o8 != null && (this.id = this.recycleAsyncId(n8, o8, null)), this.delay = null, r9.prototype.unsubscribe.call(this);
          }
        }, e9;
      }(Hr);
      Tr = function() {
        function r9(e9, t8) {
          t8 === void 0 && (t8 = r9.now), this.schedulerActionCtor = e9, this.now = t8;
        }
        return r9.prototype.schedule = function(e9, t8, o8) {
          return t8 === void 0 && (t8 = 0), new this.schedulerActionCtor(this, e9).schedule(o8, t8);
        }, r9.now = Ir.now, r9;
      }();
      Kr = function(r9) {
        T(e9, r9);
        function e9(t8, o8) {
          o8 === void 0 && (o8 = Tr.now);
          var n8 = r9.call(this, t8, o8) || this;
          return n8.actions = [], n8._active = false, n8;
        }
        return e9.prototype.flush = function(t8) {
          var o8 = this.actions;
          if (this._active) {
            o8.push(t8);
            return;
          }
          var n8;
          this._active = true;
          do
            if (n8 = t8.execute(t8.state, t8.delay))
              break;
          while (t8 = o8.shift());
          if (this._active = false, n8) {
            for (; t8 = o8.shift(); )
              t8.unsubscribe();
            throw n8;
          }
        }, e9;
      }(Tr);
      Pr = new Kr(Jr);
      zr = Pr;
      N = new b(function(r9) {
        return r9.complete();
      });
      G = function(r9) {
        return r9 && typeof r9.length == "number" && typeof r9 != "function";
      };
      cr = Ve();
      L = B(function(r9) {
        return function() {
          r9(this), this.name = "EmptyError", this.message = "no elements in sequence";
        };
      });
      He = Array.isArray;
      Ke = Array.isArray;
      ze = Object.getPrototypeOf;
      Qe = Object.prototype;
      Xe = Object.keys;
      $e = ["addListener", "removeListener"];
      Be = ["addEventListener", "removeEventListener"];
      rt = ["on", "off"];
      ve = new b(F);
      nt = Array.isArray;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/environment.js
  var isNode, DEFERRED_PROMISE_DEBUG_TIMEOUT;
  var init_environment = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/environment.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      isNode = !!(typeof process_exports !== "undefined" && process_exports.version);
      DEFERRED_PROMISE_DEBUG_TIMEOUT = typeof process_exports !== "undefined" && typeof process_exports.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"] !== "undefined" ? Number(process_exports.env["PUPPETEER_DEFERRED_PROMISE_DEBUG_TIMEOUT"]) : -1;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js
  var assert2;
  var init_assert = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/assert.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      assert2 = (value, message) => {
        if (!value) {
          throw new Error(message);
        }
      };
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var s7 = 1e3;
      var m6 = s7 * 60;
      var h8 = m6 * 60;
      var d7 = h8 * 24;
      var w5 = d7 * 7;
      var y6 = d7 * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse3(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n8 = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n8 * y6;
          case "weeks":
          case "week":
          case "w":
            return n8 * w5;
          case "days":
          case "day":
          case "d":
            return n8 * d7;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n8 * h8;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n8 * m6;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n8 * s7;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n8;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d7) {
          return Math.round(ms / d7) + "d";
        }
        if (msAbs >= h8) {
          return Math.round(ms / h8) + "h";
        }
        if (msAbs >= m6) {
          return Math.round(ms / m6) + "m";
        }
        if (msAbs >= s7) {
          return Math.round(ms / s7) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d7) {
          return plural(ms, msAbs, d7, "day");
        }
        if (msAbs >= h8) {
          return plural(ms, msAbs, h8, "hour");
        }
        if (msAbs >= m6) {
          return plural(ms, msAbs, m6, "minute");
        }
        if (msAbs >= s7) {
          return plural(ms, msAbs, s7, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n8, name2) {
        var isPlural = msAbs >= n8 * 1.5;
        return Math.round(ms / n8) + " " + name2 + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      function setup(env2) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env2).forEach((key) => {
          createDebug[key] = env2[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i7 = 0; i7 < namespace.length; i7++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i7);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug3(...args) {
            if (!debug3.enabled) {
              return;
            }
            const self2 = debug3;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format5];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug3.namespace = namespace;
          debug3.useColors = createDebug.useColors();
          debug3.color = createDebug.selectColor(namespace);
          debug3.extend = extend;
          debug3.destroy = createDebug.destroy;
          Object.defineProperty(debug3, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v7) => {
              enableOverride = v7;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug3);
          }
          return debug3;
        }
        function extend(namespace, delimiter2) {
          const newDebug = createDebug(this.namespace + (typeof delimiter2 === "undefined" ? ":" : delimiter2) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i7;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i7 = 0; i7 < len; i7++) {
            if (!split[i7]) {
              continue;
            }
            namespaces = split[i7].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name2) {
          if (name2[name2.length - 1] === "*") {
            return true;
          }
          let i7;
          let len;
          for (i7 = 0, len = createDebug.skips.length; i7 < len; i7++) {
            if (createDebug.skips[i7].test(name2)) {
              return false;
            }
          }
          for (i7 = 0, len = createDebug.names.length; i7 < len; i7++) {
            if (createDebug.names[i7].test(name2)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      exports8.formatArgs = formatArgs;
      exports8.save = save;
      exports8.load = load;
      exports8.useColors = useColors;
      exports8.storage = localstorage();
      exports8.destroy = /* @__PURE__ */ (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports8.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c7 = "color: " + this.color;
        args.splice(1, 0, c7, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c7);
      }
      exports8.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports8.storage.setItem("debug", namespaces);
          } else {
            exports8.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r9;
        try {
          r9 = exports8.storage.getItem("debug");
        } catch (error) {
        }
        if (!r9 && typeof process_exports !== "undefined" && "env" in process_exports) {
          r9 = process_exports.env.DEBUG;
        }
        return r9;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports8);
      var { formatters } = module.exports;
      formatters.j = function(v7) {
        try {
          return JSON.stringify(v7);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js
  async function importDebug() {
    if (!debugModule) {
      debugModule = (await Promise.resolve().then(() => __toESM(require_browser(), 1))).default;
    }
    return debugModule;
  }
  var debugModule, debug, capturedLogs, captureLogs;
  var init_Debug = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/Debug.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_environment();
      debugModule = null;
      debug = (prefix) => {
        if (isNode) {
          return async (...logArgs) => {
            if (captureLogs) {
              capturedLogs.push(prefix + logArgs);
            }
            (await importDebug())(prefix)(logArgs);
          };
        }
        return (...logArgs) => {
          const debugLevel = globalThis.__PUPPETEER_DEBUG;
          if (!debugLevel) {
            return;
          }
          const everythingShouldBeLogged = debugLevel === "*";
          const prefixMatchesDebugLevel = everythingShouldBeLogged || /**
           * If the debug level is `foo*`, that means we match any prefix that
           * starts with `foo`. If the level is `foo`, we match only the prefix
           * `foo`.
           */
          (debugLevel.endsWith("*") ? prefix.startsWith(debugLevel) : prefix === debugLevel);
          if (!prefixMatchesDebugLevel) {
            return;
          }
          console.log(`${prefix}:`, ...logArgs);
        };
      };
      capturedLogs = [];
      captureLogs = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js
  function o() {
    o.init.call(this);
  }
  function u(e9) {
    if ("function" != typeof e9)
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e9);
  }
  function f(e9) {
    return void 0 === e9._maxListeners ? o.defaultMaxListeners : e9._maxListeners;
  }
  function v2(e9, t8, n8, r9) {
    var i7, o8, s7, v7;
    if (u(n8), void 0 === (o8 = e9._events) ? (o8 = e9._events = /* @__PURE__ */ Object.create(null), e9._eventsCount = 0) : (void 0 !== o8.newListener && (e9.emit("newListener", t8, n8.listener ? n8.listener : n8), o8 = e9._events), s7 = o8[t8]), void 0 === s7)
      s7 = o8[t8] = n8, ++e9._eventsCount;
    else if ("function" == typeof s7 ? s7 = o8[t8] = r9 ? [n8, s7] : [s7, n8] : r9 ? s7.unshift(n8) : s7.push(n8), (i7 = f(e9)) > 0 && s7.length > i7 && !s7.warned) {
      s7.warned = true;
      var a8 = new Error("Possible EventEmitter memory leak detected. " + s7.length + " " + String(t8) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      a8.name = "MaxListenersExceededWarning", a8.emitter = e9, a8.type = t8, a8.count = s7.length, v7 = a8, console && console.warn && console.warn(v7);
    }
    return e9;
  }
  function a2() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function l(e9, t8, n8) {
    var r9 = { fired: false, wrapFn: void 0, target: e9, type: t8, listener: n8 }, i7 = a2.bind(r9);
    return i7.listener = n8, r9.wrapFn = i7, i7;
  }
  function h(e9, t8, n8) {
    var r9 = e9._events;
    if (void 0 === r9)
      return [];
    var i7 = r9[t8];
    return void 0 === i7 ? [] : "function" == typeof i7 ? n8 ? [i7.listener || i7] : [i7] : n8 ? function(e10) {
      for (var t9 = new Array(e10.length), n9 = 0; n9 < t9.length; ++n9)
        t9[n9] = e10[n9].listener || e10[n9];
      return t9;
    }(i7) : c(i7, i7.length);
  }
  function p2(e9) {
    var t8 = this._events;
    if (void 0 !== t8) {
      var n8 = t8[e9];
      if ("function" == typeof n8)
        return 1;
      if (void 0 !== n8)
        return n8.length;
    }
    return 0;
  }
  function c(e9, t8) {
    for (var n8 = new Array(t8), r9 = 0; r9 < t8; ++r9)
      n8[r9] = e9[r9];
    return n8;
  }
  var e, t, n, r, i, s2, y;
  var init_chunk_4bd36a8f = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4bd36a8f.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      n = "object" == typeof Reflect ? Reflect : null;
      r = n && "function" == typeof n.apply ? n.apply : function(e9, t8, n8) {
        return Function.prototype.apply.call(e9, t8, n8);
      };
      t = n && "function" == typeof n.ownKeys ? n.ownKeys : Object.getOwnPropertySymbols ? function(e9) {
        return Object.getOwnPropertyNames(e9).concat(Object.getOwnPropertySymbols(e9));
      } : function(e9) {
        return Object.getOwnPropertyNames(e9);
      };
      i = Number.isNaN || function(e9) {
        return e9 != e9;
      };
      e = o, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
      s2 = 10;
      Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
        return s2;
      }, set: function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i(e9))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        s2 = e9;
      } }), o.init = function() {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, o.prototype.setMaxListeners = function(e9) {
        if ("number" != typeof e9 || e9 < 0 || i(e9))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e9 + ".");
        return this._maxListeners = e9, this;
      }, o.prototype.getMaxListeners = function() {
        return f(this);
      }, o.prototype.emit = function(e9) {
        for (var t8 = [], n8 = 1; n8 < arguments.length; n8++)
          t8.push(arguments[n8]);
        var i7 = "error" === e9, o8 = this._events;
        if (void 0 !== o8)
          i7 = i7 && void 0 === o8.error;
        else if (!i7)
          return false;
        if (i7) {
          var s7;
          if (t8.length > 0 && (s7 = t8[0]), s7 instanceof Error)
            throw s7;
          var u7 = new Error("Unhandled error." + (s7 ? " (" + s7.message + ")" : ""));
          throw u7.context = s7, u7;
        }
        var f7 = o8[e9];
        if (void 0 === f7)
          return false;
        if ("function" == typeof f7)
          r(f7, this, t8);
        else {
          var v7 = f7.length, a8 = c(f7, v7);
          for (n8 = 0; n8 < v7; ++n8)
            r(a8[n8], this, t8);
        }
        return true;
      }, o.prototype.addListener = function(e9, t8) {
        return v2(this, e9, t8, false);
      }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e9, t8) {
        return v2(this, e9, t8, true);
      }, o.prototype.once = function(e9, t8) {
        return u(t8), this.on(e9, l(this, e9, t8)), this;
      }, o.prototype.prependOnceListener = function(e9, t8) {
        return u(t8), this.prependListener(e9, l(this, e9, t8)), this;
      }, o.prototype.removeListener = function(e9, t8) {
        var n8, r9, i7, o8, s7;
        if (u(t8), void 0 === (r9 = this._events))
          return this;
        if (void 0 === (n8 = r9[e9]))
          return this;
        if (n8 === t8 || n8.listener === t8)
          0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r9[e9], r9.removeListener && this.emit("removeListener", e9, n8.listener || t8));
        else if ("function" != typeof n8) {
          for (i7 = -1, o8 = n8.length - 1; o8 >= 0; o8--)
            if (n8[o8] === t8 || n8[o8].listener === t8) {
              s7 = n8[o8].listener, i7 = o8;
              break;
            }
          if (i7 < 0)
            return this;
          0 === i7 ? n8.shift() : !function(e10, t9) {
            for (; t9 + 1 < e10.length; t9++)
              e10[t9] = e10[t9 + 1];
            e10.pop();
          }(n8, i7), 1 === n8.length && (r9[e9] = n8[0]), void 0 !== r9.removeListener && this.emit("removeListener", e9, s7 || t8);
        }
        return this;
      }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e9) {
        var t8, n8, r9;
        if (void 0 === (n8 = this._events))
          return this;
        if (void 0 === n8.removeListener)
          return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n8[e9] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n8[e9]), this;
        if (0 === arguments.length) {
          var i7, o8 = Object.keys(n8);
          for (r9 = 0; r9 < o8.length; ++r9)
            "removeListener" !== (i7 = o8[r9]) && this.removeAllListeners(i7);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if ("function" == typeof (t8 = n8[e9]))
          this.removeListener(e9, t8);
        else if (void 0 !== t8)
          for (r9 = t8.length - 1; r9 >= 0; r9--)
            this.removeListener(e9, t8[r9]);
        return this;
      }, o.prototype.listeners = function(e9) {
        return h(this, e9, true);
      }, o.prototype.rawListeners = function(e9) {
        return h(this, e9, false);
      }, o.listenerCount = function(e9, t8) {
        return "function" == typeof e9.listenerCount ? e9.listenerCount(t8) : p2.call(e9, t8);
      }, o.prototype.listenerCount = p2, o.prototype.eventNames = function() {
        return this._eventsCount > 0 ? t(this._events) : [];
      };
      y = e;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
      y.EventEmitter;
      y.defaultMaxListeners;
      y.init;
      y.listenerCount;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js
  function i2() {
    throw new Error("setTimeout has not been defined");
  }
  function u2() {
    throw new Error("clearTimeout has not been defined");
  }
  function c2(e9) {
    if (t2 === setTimeout)
      return setTimeout(e9, 0);
    if ((t2 === i2 || !t2) && setTimeout)
      return t2 = setTimeout, setTimeout(e9, 0);
    try {
      return t2(e9, 0);
    } catch (n8) {
      try {
        return t2.call(null, e9, 0);
      } catch (n9) {
        return t2.call(this || r2, e9, 0);
      }
    }
  }
  function h2() {
    f2 && l2 && (f2 = false, l2.length ? s3 = l2.concat(s3) : a3 = -1, s3.length && d2());
  }
  function d2() {
    if (!f2) {
      var e9 = c2(h2);
      f2 = true;
      for (var t8 = s3.length; t8; ) {
        for (l2 = s3, s3 = []; ++a3 < t8; )
          l2 && l2[a3].run();
        a3 = -1, t8 = s3.length;
      }
      l2 = null, f2 = false, function(e10) {
        if (n2 === clearTimeout)
          return clearTimeout(e10);
        if ((n2 === u2 || !n2) && clearTimeout)
          return n2 = clearTimeout, clearTimeout(e10);
        try {
          n2(e10);
        } catch (t9) {
          try {
            return n2.call(null, e10);
          } catch (t10) {
            return n2.call(this || r2, e10);
          }
        }
      }(e9);
    }
  }
  function m(e9, t8) {
    (this || r2).fun = e9, (this || r2).array = t8;
  }
  function p3() {
  }
  var e2, t2, n2, r2, o2, l2, s3, f2, a3, T2;
  var init_chunk_5decc758 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-5decc758.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      r2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      o2 = e2 = {};
      !function() {
        try {
          t2 = "function" == typeof setTimeout ? setTimeout : i2;
        } catch (e9) {
          t2 = i2;
        }
        try {
          n2 = "function" == typeof clearTimeout ? clearTimeout : u2;
        } catch (e9) {
          n2 = u2;
        }
      }();
      s3 = [];
      f2 = false;
      a3 = -1;
      o2.nextTick = function(e9) {
        var t8 = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var n8 = 1; n8 < arguments.length; n8++)
            t8[n8 - 1] = arguments[n8];
        s3.push(new m(e9, t8)), 1 !== s3.length || f2 || c2(d2);
      }, m.prototype.run = function() {
        (this || r2).fun.apply(null, (this || r2).array);
      }, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = p3, o2.addListener = p3, o2.once = p3, o2.off = p3, o2.removeListener = p3, o2.removeAllListeners = p3, o2.emit = p3, o2.prependListener = p3, o2.prependOnceListener = p3, o2.listeners = function(e9) {
        return [];
      }, o2.binding = function(e9) {
        throw new Error("process.binding is not supported");
      }, o2.cwd = function() {
        return "/";
      }, o2.chdir = function(e9) {
        throw new Error("process.chdir is not supported");
      }, o2.umask = function() {
        return 0;
      };
      T2 = e2;
      T2.addListener;
      T2.argv;
      T2.binding;
      T2.browser;
      T2.chdir;
      T2.cwd;
      T2.emit;
      T2.env;
      T2.listeners;
      T2.nextTick;
      T2.off;
      T2.on;
      T2.once;
      T2.prependListener;
      T2.prependOnceListener;
      T2.removeAllListeners;
      T2.removeListener;
      T2.title;
      T2.umask;
      T2.version;
      T2.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js
  function c$1(e9) {
    return e9.call.bind(e9);
  }
  function O(e9, t8) {
    if ("object" != typeof e9)
      return false;
    try {
      return t8(e9), true;
    } catch (e10) {
      return false;
    }
  }
  function S2(e9) {
    return l$1 && y2 ? void 0 !== b2(e9) : B2(e9) || k2(e9) || E2(e9) || D2(e9) || U2(e9) || P2(e9) || x(e9) || I2(e9) || M(e9) || z2(e9) || F2(e9);
  }
  function B2(e9) {
    return l$1 && y2 ? "Uint8Array" === b2(e9) : "[object Uint8Array]" === m2(e9) || u$1(e9) && void 0 !== e9.buffer;
  }
  function k2(e9) {
    return l$1 && y2 ? "Uint8ClampedArray" === b2(e9) : "[object Uint8ClampedArray]" === m2(e9);
  }
  function E2(e9) {
    return l$1 && y2 ? "Uint16Array" === b2(e9) : "[object Uint16Array]" === m2(e9);
  }
  function D2(e9) {
    return l$1 && y2 ? "Uint32Array" === b2(e9) : "[object Uint32Array]" === m2(e9);
  }
  function U2(e9) {
    return l$1 && y2 ? "Int8Array" === b2(e9) : "[object Int8Array]" === m2(e9);
  }
  function P2(e9) {
    return l$1 && y2 ? "Int16Array" === b2(e9) : "[object Int16Array]" === m2(e9);
  }
  function x(e9) {
    return l$1 && y2 ? "Int32Array" === b2(e9) : "[object Int32Array]" === m2(e9);
  }
  function I2(e9) {
    return l$1 && y2 ? "Float32Array" === b2(e9) : "[object Float32Array]" === m2(e9);
  }
  function M(e9) {
    return l$1 && y2 ? "Float64Array" === b2(e9) : "[object Float64Array]" === m2(e9);
  }
  function z2(e9) {
    return l$1 && y2 ? "BigInt64Array" === b2(e9) : "[object BigInt64Array]" === m2(e9);
  }
  function F2(e9) {
    return l$1 && y2 ? "BigUint64Array" === b2(e9) : "[object BigUint64Array]" === m2(e9);
  }
  function T3(e9) {
    return "[object Map]" === m2(e9);
  }
  function N2(e9) {
    return "[object Set]" === m2(e9);
  }
  function W2(e9) {
    return "[object WeakMap]" === m2(e9);
  }
  function $2(e9) {
    return "[object WeakSet]" === m2(e9);
  }
  function C2(e9) {
    return "[object ArrayBuffer]" === m2(e9);
  }
  function V2(e9) {
    return "undefined" != typeof ArrayBuffer && (C2.working ? C2(e9) : e9 instanceof ArrayBuffer);
  }
  function G2(e9) {
    return "[object DataView]" === m2(e9);
  }
  function R2(e9) {
    return "undefined" != typeof DataView && (G2.working ? G2(e9) : e9 instanceof DataView);
  }
  function J2(e9) {
    return "[object SharedArrayBuffer]" === m2(e9);
  }
  function _2(e9) {
    return "undefined" != typeof SharedArrayBuffer && (J2.working ? J2(e9) : e9 instanceof SharedArrayBuffer);
  }
  function H2(e9) {
    return O(e9, h3);
  }
  function Z(e9) {
    return O(e9, j2);
  }
  function q2(e9) {
    return O(e9, A2);
  }
  function K2(e9) {
    return s4 && O(e9, w2);
  }
  function L2(e9) {
    return p4 && O(e9, v3);
  }
  function oe2(e9, t8) {
    var r9 = { seen: [], stylize: fe2 };
    return arguments.length >= 3 && (r9.depth = arguments[2]), arguments.length >= 4 && (r9.colors = arguments[3]), ye2(t8) ? r9.showHidden = t8 : t8 && X2._extend(r9, t8), be2(r9.showHidden) && (r9.showHidden = false), be2(r9.depth) && (r9.depth = 2), be2(r9.colors) && (r9.colors = false), be2(r9.customInspect) && (r9.customInspect = true), r9.colors && (r9.stylize = ue2), ae2(r9, e9, r9.depth);
  }
  function ue2(e9, t8) {
    var r9 = oe2.styles[t8];
    return r9 ? "\x1B[" + oe2.colors[r9][0] + "m" + e9 + "\x1B[" + oe2.colors[r9][1] + "m" : e9;
  }
  function fe2(e9, t8) {
    return e9;
  }
  function ae2(e9, t8, r9) {
    if (e9.customInspect && t8 && we2(t8.inspect) && t8.inspect !== X2.inspect && (!t8.constructor || t8.constructor.prototype !== t8)) {
      var n8 = t8.inspect(r9, e9);
      return ge2(n8) || (n8 = ae2(e9, n8, r9)), n8;
    }
    var i7 = function(e10, t9) {
      if (be2(t9))
        return e10.stylize("undefined", "undefined");
      if (ge2(t9)) {
        var r10 = "'" + JSON.stringify(t9).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e10.stylize(r10, "string");
      }
      if (de2(t9))
        return e10.stylize("" + t9, "number");
      if (ye2(t9))
        return e10.stylize("" + t9, "boolean");
      if (le2(t9))
        return e10.stylize("null", "null");
    }(e9, t8);
    if (i7)
      return i7;
    var o8 = Object.keys(t8), u7 = function(e10) {
      var t9 = {};
      return e10.forEach(function(e11, r10) {
        t9[e11] = true;
      }), t9;
    }(o8);
    if (e9.showHidden && (o8 = Object.getOwnPropertyNames(t8)), Ae2(t8) && (o8.indexOf("message") >= 0 || o8.indexOf("description") >= 0))
      return ce2(t8);
    if (0 === o8.length) {
      if (we2(t8)) {
        var f7 = t8.name ? ": " + t8.name : "";
        return e9.stylize("[Function" + f7 + "]", "special");
      }
      if (me2(t8))
        return e9.stylize(RegExp.prototype.toString.call(t8), "regexp");
      if (je2(t8))
        return e9.stylize(Date.prototype.toString.call(t8), "date");
      if (Ae2(t8))
        return ce2(t8);
    }
    var a8, c7 = "", s7 = false, p8 = ["{", "}"];
    (pe2(t8) && (s7 = true, p8 = ["[", "]"]), we2(t8)) && (c7 = " [Function" + (t8.name ? ": " + t8.name : "") + "]");
    return me2(t8) && (c7 = " " + RegExp.prototype.toString.call(t8)), je2(t8) && (c7 = " " + Date.prototype.toUTCString.call(t8)), Ae2(t8) && (c7 = " " + ce2(t8)), 0 !== o8.length || s7 && 0 != t8.length ? r9 < 0 ? me2(t8) ? e9.stylize(RegExp.prototype.toString.call(t8), "regexp") : e9.stylize("[Object]", "special") : (e9.seen.push(t8), a8 = s7 ? function(e10, t9, r10, n9, i8) {
      for (var o9 = [], u8 = 0, f8 = t9.length; u8 < f8; ++u8)
        ke2(t9, String(u8)) ? o9.push(se2(e10, t9, r10, n9, String(u8), true)) : o9.push("");
      return i8.forEach(function(i9) {
        i9.match(/^\d+$/) || o9.push(se2(e10, t9, r10, n9, i9, true));
      }), o9;
    }(e9, t8, r9, u7, o8) : o8.map(function(n9) {
      return se2(e9, t8, r9, u7, n9, s7);
    }), e9.seen.pop(), function(e10, t9, r10) {
      var n9 = 0;
      if (e10.reduce(function(e11, t10) {
        return n9++, t10.indexOf("\n") >= 0 && n9++, e11 + t10.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0) > 60)
        return r10[0] + ("" === t9 ? "" : t9 + "\n ") + " " + e10.join(",\n  ") + " " + r10[1];
      return r10[0] + t9 + " " + e10.join(", ") + " " + r10[1];
    }(a8, c7, p8)) : p8[0] + c7 + p8[1];
  }
  function ce2(e9) {
    return "[" + Error.prototype.toString.call(e9) + "]";
  }
  function se2(e9, t8, r9, n8, i7, o8) {
    var u7, f7, a8;
    if ((a8 = Object.getOwnPropertyDescriptor(t8, i7) || { value: t8[i7] }).get ? f7 = a8.set ? e9.stylize("[Getter/Setter]", "special") : e9.stylize("[Getter]", "special") : a8.set && (f7 = e9.stylize("[Setter]", "special")), ke2(n8, i7) || (u7 = "[" + i7 + "]"), f7 || (e9.seen.indexOf(a8.value) < 0 ? (f7 = le2(r9) ? ae2(e9, a8.value, null) : ae2(e9, a8.value, r9 - 1)).indexOf("\n") > -1 && (f7 = o8 ? f7.split("\n").map(function(e10) {
      return "  " + e10;
    }).join("\n").substr(2) : "\n" + f7.split("\n").map(function(e10) {
      return "   " + e10;
    }).join("\n")) : f7 = e9.stylize("[Circular]", "special")), be2(u7)) {
      if (o8 && i7.match(/^\d+$/))
        return f7;
      (u7 = JSON.stringify("" + i7)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u7 = u7.substr(1, u7.length - 2), u7 = e9.stylize(u7, "name")) : (u7 = u7.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u7 = e9.stylize(u7, "string"));
    }
    return u7 + ": " + f7;
  }
  function pe2(e9) {
    return Array.isArray(e9);
  }
  function ye2(e9) {
    return "boolean" == typeof e9;
  }
  function le2(e9) {
    return null === e9;
  }
  function de2(e9) {
    return "number" == typeof e9;
  }
  function ge2(e9) {
    return "string" == typeof e9;
  }
  function be2(e9) {
    return void 0 === e9;
  }
  function me2(e9) {
    return he2(e9) && "[object RegExp]" === ve2(e9);
  }
  function he2(e9) {
    return "object" == typeof e9 && null !== e9;
  }
  function je2(e9) {
    return he2(e9) && "[object Date]" === ve2(e9);
  }
  function Ae2(e9) {
    return he2(e9) && ("[object Error]" === ve2(e9) || e9 instanceof Error);
  }
  function we2(e9) {
    return "function" == typeof e9;
  }
  function ve2(e9) {
    return Object.prototype.toString.call(e9);
  }
  function Oe2(e9) {
    return e9 < 10 ? "0" + e9.toString(10) : e9.toString(10);
  }
  function Be2() {
    var e9 = /* @__PURE__ */ new Date(), t8 = [Oe2(e9.getHours()), Oe2(e9.getMinutes()), Oe2(e9.getSeconds())].join(":");
    return [e9.getDate(), Se2[e9.getMonth()], t8].join(" ");
  }
  function ke2(e9, t8) {
    return Object.prototype.hasOwnProperty.call(e9, t8);
  }
  function De2(e9, t8) {
    if (!e9) {
      var r9 = new Error("Promise was rejected with a falsy value");
      r9.reason = e9, e9 = r9;
    }
    return t8(e9);
  }
  var t3, e3, o3, n3, r3, l3, t$1, o$1, n$1, e$1, r$1, c3, u3, i3, t$2, i$1, o$2, u$1, f3, a4, s4, p4, y2, l$1, d3, m2, h3, j2, A2, Q2, X2, Y2, ee2, te2, re2, ne2, ie2, Se2, Ee2;
  var init_chunk_b4205b57 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-b4205b57.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_5decc758();
      t3 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      e3 = Object.prototype.toString;
      o3 = function(o8) {
        return !(t3 && o8 && "object" == typeof o8 && Symbol.toStringTag in o8) && "[object Arguments]" === e3.call(o8);
      };
      n3 = function(t8) {
        return !!o3(t8) || null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Array]" !== e3.call(t8) && "[object Function]" === e3.call(t8.callee);
      };
      r3 = function() {
        return o3(arguments);
      }();
      o3.isLegacyArguments = n3;
      l3 = r3 ? o3 : n3;
      t$1 = Object.prototype.toString;
      o$1 = Function.prototype.toString;
      n$1 = /^\s*(?:function)?\*/;
      e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
      r$1 = Object.getPrototypeOf;
      c3 = function() {
        if (!e$1)
          return false;
        try {
          return Function("return function*() {}")();
        } catch (t8) {
        }
      }();
      u3 = c3 ? r$1(c3) : {};
      i3 = function(c7) {
        return "function" == typeof c7 && (!!n$1.test(o$1.call(c7)) || (e$1 ? r$1(c7) === u3 : "[object GeneratorFunction]" === t$1.call(c7)));
      };
      t$2 = "function" == typeof Object.create ? function(t8, e9) {
        e9 && (t8.super_ = e9, t8.prototype = Object.create(e9.prototype, { constructor: { value: t8, enumerable: false, writable: true, configurable: true } }));
      } : function(t8, e9) {
        if (e9) {
          t8.super_ = e9;
          var o8 = function() {
          };
          o8.prototype = e9.prototype, t8.prototype = new o8(), t8.prototype.constructor = t8;
        }
      };
      i$1 = function(e9) {
        return e9 && "object" == typeof e9 && "function" == typeof e9.copy && "function" == typeof e9.fill && "function" == typeof e9.readUInt8;
      };
      o$2 = {};
      u$1 = i$1;
      f3 = l3;
      a4 = i3;
      s4 = "undefined" != typeof BigInt;
      p4 = "undefined" != typeof Symbol;
      y2 = p4 && void 0 !== Symbol.toStringTag;
      l$1 = "undefined" != typeof Uint8Array;
      d3 = "undefined" != typeof ArrayBuffer;
      if (l$1 && y2)
        var g = Object.getPrototypeOf(Uint8Array.prototype), b2 = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
      m2 = c$1(Object.prototype.toString);
      h3 = c$1(Number.prototype.valueOf);
      j2 = c$1(String.prototype.valueOf);
      A2 = c$1(Boolean.prototype.valueOf);
      if (s4)
        var w2 = c$1(BigInt.prototype.valueOf);
      if (p4)
        var v3 = c$1(Symbol.prototype.valueOf);
      o$2.isArgumentsObject = f3, o$2.isGeneratorFunction = a4, o$2.isPromise = function(e9) {
        return "undefined" != typeof Promise && e9 instanceof Promise || null !== e9 && "object" == typeof e9 && "function" == typeof e9.then && "function" == typeof e9.catch;
      }, o$2.isArrayBufferView = function(e9) {
        return d3 && ArrayBuffer.isView ? ArrayBuffer.isView(e9) : S2(e9) || R2(e9);
      }, o$2.isTypedArray = S2, o$2.isUint8Array = B2, o$2.isUint8ClampedArray = k2, o$2.isUint16Array = E2, o$2.isUint32Array = D2, o$2.isInt8Array = U2, o$2.isInt16Array = P2, o$2.isInt32Array = x, o$2.isFloat32Array = I2, o$2.isFloat64Array = M, o$2.isBigInt64Array = z2, o$2.isBigUint64Array = F2, T3.working = "undefined" != typeof Map && T3(/* @__PURE__ */ new Map()), o$2.isMap = function(e9) {
        return "undefined" != typeof Map && (T3.working ? T3(e9) : e9 instanceof Map);
      }, N2.working = "undefined" != typeof Set && N2(/* @__PURE__ */ new Set()), o$2.isSet = function(e9) {
        return "undefined" != typeof Set && (N2.working ? N2(e9) : e9 instanceof Set);
      }, W2.working = "undefined" != typeof WeakMap && W2(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e9) {
        return "undefined" != typeof WeakMap && (W2.working ? W2(e9) : e9 instanceof WeakMap);
      }, $2.working = "undefined" != typeof WeakSet && $2(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e9) {
        return $2(e9);
      }, C2.working = "undefined" != typeof ArrayBuffer && C2(new ArrayBuffer()), o$2.isArrayBuffer = V2, G2.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G2(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R2, J2.working = "undefined" != typeof SharedArrayBuffer && J2(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _2, o$2.isAsyncFunction = function(e9) {
        return "[object AsyncFunction]" === m2(e9);
      }, o$2.isMapIterator = function(e9) {
        return "[object Map Iterator]" === m2(e9);
      }, o$2.isSetIterator = function(e9) {
        return "[object Set Iterator]" === m2(e9);
      }, o$2.isGeneratorObject = function(e9) {
        return "[object Generator]" === m2(e9);
      }, o$2.isWebAssemblyCompiledModule = function(e9) {
        return "[object WebAssembly.Module]" === m2(e9);
      }, o$2.isNumberObject = H2, o$2.isStringObject = Z, o$2.isBooleanObject = q2, o$2.isBigIntObject = K2, o$2.isSymbolObject = L2, o$2.isBoxedPrimitive = function(e9) {
        return H2(e9) || Z(e9) || q2(e9) || K2(e9) || L2(e9);
      }, o$2.isAnyArrayBuffer = function(e9) {
        return l$1 && (V2(e9) || _2(e9));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e9) {
        Object.defineProperty(o$2, e9, { enumerable: false, value: function() {
          throw new Error(e9 + " is not supported in userland");
        } });
      });
      Q2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
      X2 = {};
      Y2 = T2;
      ee2 = Object.getOwnPropertyDescriptors || function(e9) {
        for (var t8 = Object.keys(e9), r9 = {}, n8 = 0; n8 < t8.length; n8++)
          r9[t8[n8]] = Object.getOwnPropertyDescriptor(e9, t8[n8]);
        return r9;
      };
      te2 = /%[sdj%]/g;
      X2.format = function(e9) {
        if (!ge2(e9)) {
          for (var t8 = [], r9 = 0; r9 < arguments.length; r9++)
            t8.push(oe2(arguments[r9]));
          return t8.join(" ");
        }
        r9 = 1;
        for (var n8 = arguments, i7 = n8.length, o8 = String(e9).replace(te2, function(e10) {
          if ("%%" === e10)
            return "%";
          if (r9 >= i7)
            return e10;
          switch (e10) {
            case "%s":
              return String(n8[r9++]);
            case "%d":
              return Number(n8[r9++]);
            case "%j":
              try {
                return JSON.stringify(n8[r9++]);
              } catch (e11) {
                return "[Circular]";
              }
            default:
              return e10;
          }
        }), u7 = n8[r9]; r9 < i7; u7 = n8[++r9])
          le2(u7) || !he2(u7) ? o8 += " " + u7 : o8 += " " + oe2(u7);
        return o8;
      }, X2.deprecate = function(e9, t8) {
        if (void 0 !== Y2 && true === Y2.noDeprecation)
          return e9;
        if (void 0 === Y2)
          return function() {
            return X2.deprecate(e9, t8).apply(this || Q2, arguments);
          };
        var r9 = false;
        return function() {
          if (!r9) {
            if (Y2.throwDeprecation)
              throw new Error(t8);
            Y2.traceDeprecation ? console.trace(t8) : console.error(t8), r9 = true;
          }
          return e9.apply(this || Q2, arguments);
        };
      };
      re2 = {};
      ne2 = /^$/;
      if (Y2.env.NODE_DEBUG) {
        ie2 = Y2.env.NODE_DEBUG;
        ie2 = ie2.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne2 = new RegExp("^" + ie2 + "$", "i");
      }
      X2.debuglog = function(e9) {
        if (e9 = e9.toUpperCase(), !re2[e9])
          if (ne2.test(e9)) {
            var t8 = Y2.pid;
            re2[e9] = function() {
              var r9 = X2.format.apply(X2, arguments);
              console.error("%s %d: %s", e9, t8, r9);
            };
          } else
            re2[e9] = function() {
            };
        return re2[e9];
      }, X2.inspect = oe2, oe2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X2.types = o$2, X2.isArray = pe2, X2.isBoolean = ye2, X2.isNull = le2, X2.isNullOrUndefined = function(e9) {
        return null == e9;
      }, X2.isNumber = de2, X2.isString = ge2, X2.isSymbol = function(e9) {
        return "symbol" == typeof e9;
      }, X2.isUndefined = be2, X2.isRegExp = me2, X2.types.isRegExp = me2, X2.isObject = he2, X2.isDate = je2, X2.types.isDate = je2, X2.isError = Ae2, X2.types.isNativeError = Ae2, X2.isFunction = we2, X2.isPrimitive = function(e9) {
        return null === e9 || "boolean" == typeof e9 || "number" == typeof e9 || "string" == typeof e9 || "symbol" == typeof e9 || void 0 === e9;
      }, X2.isBuffer = i$1;
      Se2 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      X2.log = function() {
        console.log("%s - %s", Be2(), X2.format.apply(X2, arguments));
      }, X2.inherits = t$2, X2._extend = function(e9, t8) {
        if (!t8 || !he2(t8))
          return e9;
        for (var r9 = Object.keys(t8), n8 = r9.length; n8--; )
          e9[r9[n8]] = t8[r9[n8]];
        return e9;
      };
      Ee2 = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
      X2.promisify = function(e9) {
        if ("function" != typeof e9)
          throw new TypeError('The "original" argument must be of type Function');
        if (Ee2 && e9[Ee2]) {
          var t8;
          if ("function" != typeof (t8 = e9[Ee2]))
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
          return Object.defineProperty(t8, Ee2, { value: t8, enumerable: false, writable: false, configurable: true }), t8;
        }
        function t8() {
          for (var t9, r9, n8 = new Promise(function(e10, n9) {
            t9 = e10, r9 = n9;
          }), i7 = [], o8 = 0; o8 < arguments.length; o8++)
            i7.push(arguments[o8]);
          i7.push(function(e10, n9) {
            e10 ? r9(e10) : t9(n9);
          });
          try {
            e9.apply(this || Q2, i7);
          } catch (e10) {
            r9(e10);
          }
          return n8;
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Ee2 && Object.defineProperty(t8, Ee2, { value: t8, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t8, ee2(e9));
      }, X2.promisify.custom = Ee2, X2.callbackify = function(e9) {
        if ("function" != typeof e9)
          throw new TypeError('The "original" argument must be of type Function');
        function t8() {
          for (var t9 = [], r9 = 0; r9 < arguments.length; r9++)
            t9.push(arguments[r9]);
          var n8 = t9.pop();
          if ("function" != typeof n8)
            throw new TypeError("The last argument must be of type Function");
          var i7 = this || Q2, o8 = function() {
            return n8.apply(i7, arguments);
          };
          e9.apply(this || Q2, t9).then(function(e10) {
            Y2.nextTick(o8.bind(null, null, e10));
          }, function(e10) {
            Y2.nextTick(De2.bind(null, e10, o8));
          });
        }
        return Object.setPrototypeOf(t8, Object.getPrototypeOf(e9)), Object.defineProperties(t8, ee2(e9)), t8;
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js
  var _extend, callbackify, debuglog, deprecate, format, inherits, inspect, isArray, isBoolean, isBuffer, isDate, isError, isFunction, isNull, isNullOrUndefined, isNumber, isObject, isPrimitive, isRegExp, isString, isSymbol, isUndefined, log, promisify, types, TextEncoder2, TextDecoder2;
  var init_chunk_ce0fbc82 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-ce0fbc82.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      X2._extend;
      X2.callbackify;
      X2.debuglog;
      X2.deprecate;
      X2.format;
      X2.inherits;
      X2.inspect;
      X2.isArray;
      X2.isBoolean;
      X2.isBuffer;
      X2.isDate;
      X2.isError;
      X2.isFunction;
      X2.isNull;
      X2.isNullOrUndefined;
      X2.isNumber;
      X2.isObject;
      X2.isPrimitive;
      X2.isRegExp;
      X2.isString;
      X2.isSymbol;
      X2.isUndefined;
      X2.log;
      X2.promisify;
      _extend = X2._extend;
      callbackify = X2.callbackify;
      debuglog = X2.debuglog;
      deprecate = X2.deprecate;
      format = X2.format;
      inherits = X2.inherits;
      inspect = X2.inspect;
      isArray = X2.isArray;
      isBoolean = X2.isBoolean;
      isBuffer = X2.isBuffer;
      isDate = X2.isDate;
      isError = X2.isError;
      isFunction = X2.isFunction;
      isNull = X2.isNull;
      isNullOrUndefined = X2.isNullOrUndefined;
      isNumber = X2.isNumber;
      isObject = X2.isObject;
      isPrimitive = X2.isPrimitive;
      isRegExp = X2.isRegExp;
      isString = X2.isString;
      isSymbol = X2.isSymbol;
      isUndefined = X2.isUndefined;
      log = X2.log;
      promisify = X2.promisify;
      types = X2.types;
      TextEncoder2 = self.TextEncoder;
      TextDecoder2 = self.TextDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js
  function dew2() {
    if (_dewExec2)
      return exports2;
    _dewExec2 = true;
    var process3 = exports2 = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e9) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e9) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e9) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e10) {
          return cachedSetTimeout.call(this || _global, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e9) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e10) {
          return cachedClearTimeout.call(this || _global, marker);
        }
      }
    }
    var queue2 = [];
    var draining2 = false;
    var currentQueue2;
    var queueIndex2 = -1;
    function cleanUpNextTick2() {
      if (!draining2 || !currentQueue2) {
        return;
      }
      draining2 = false;
      if (currentQueue2.length) {
        queue2 = currentQueue2.concat(queue2);
      } else {
        queueIndex2 = -1;
      }
      if (queue2.length) {
        drainQueue2();
      }
    }
    function drainQueue2() {
      if (draining2) {
        return;
      }
      var timeout2 = runTimeout(cleanUpNextTick2);
      draining2 = true;
      var len = queue2.length;
      while (len) {
        currentQueue2 = queue2;
        queue2 = [];
        while (++queueIndex2 < len) {
          if (currentQueue2) {
            currentQueue2[queueIndex2].run();
          }
        }
        queueIndex2 = -1;
        len = queue2.length;
      }
      currentQueue2 = null;
      draining2 = false;
      runClearTimeout(timeout2);
    }
    process3.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i7 = 1; i7 < arguments.length; i7++) {
          args[i7 - 1] = arguments[i7];
        }
      }
      queue2.push(new Item2(fun, args));
      if (queue2.length === 1 && !draining2) {
        runTimeout(drainQueue2);
      }
    };
    function Item2(fun, array) {
      (this || _global).fun = fun;
      (this || _global).array = array;
    }
    Item2.prototype.run = function() {
      (this || _global).fun.apply(null, (this || _global).array);
    };
    process3.title = "browser";
    process3.browser = true;
    process3.env = {};
    process3.argv = [];
    process3.version = "";
    process3.versions = {};
    function noop2() {
    }
    process3.on = noop2;
    process3.addListener = noop2;
    process3.once = noop2;
    process3.off = noop2;
    process3.removeListener = noop2;
    process3.removeAllListeners = noop2;
    process3.emit = noop2;
    process3.prependListener = noop2;
    process3.prependOnceListener = noop2;
    process3.listeners = function(name2) {
      return [];
    };
    process3.binding = function(name2) {
      throw new Error("process.binding is not supported");
    };
    process3.cwd = function() {
      return "/";
    };
    process3.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process3.umask = function() {
      return 0;
    };
    return exports2;
  }
  var exports2, _dewExec2, _global, process2;
  var init_chunk_2eac56ff = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-2eac56ff.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      exports2 = {};
      _dewExec2 = false;
      _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      process2 = dew2();
      process2.platform = "browser";
      process2.addListener;
      process2.argv;
      process2.binding;
      process2.browser;
      process2.chdir;
      process2.cwd;
      process2.emit;
      process2.env;
      process2.listeners;
      process2.nextTick;
      process2.off;
      process2.on;
      process2.once;
      process2.prependListener;
      process2.prependOnceListener;
      process2.removeAllListeners;
      process2.removeListener;
      process2.title;
      process2.umask;
      process2.version;
      process2.versions;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js
  function u$2(r9) {
    var t8 = r9.length;
    if (t8 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var e9 = r9.indexOf("=");
    return -1 === e9 && (e9 = t8), [e9, e9 === t8 ? 0 : 4 - e9 % 4];
  }
  function c$12(r9, e9, n8) {
    for (var o8, a8, h8 = [], u7 = e9; u7 < n8; u7 += 3)
      o8 = (r9[u7] << 16 & 16711680) + (r9[u7 + 1] << 8 & 65280) + (255 & r9[u7 + 2]), h8.push(t$13[(a8 = o8) >> 18 & 63] + t$13[a8 >> 12 & 63] + t$13[a8 >> 6 & 63] + t$13[63 & a8]);
    return h8.join("");
  }
  function f$2(t8) {
    if (t8 > 2147483647)
      throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
    var r9 = new Uint8Array(t8);
    return Object.setPrototypeOf(r9, u$1$1.prototype), r9;
  }
  function u$1$1(t8, r9, e9) {
    if ("number" == typeof t8) {
      if ("string" == typeof r9)
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return a$2(t8);
    }
    return s$1(t8, r9, e9);
  }
  function s$1(t8, r9, e9) {
    if ("string" == typeof t8)
      return function(t9, r10) {
        "string" == typeof r10 && "" !== r10 || (r10 = "utf8");
        if (!u$1$1.isEncoding(r10))
          throw new TypeError("Unknown encoding: " + r10);
        var e10 = 0 | y3(t9, r10), n9 = f$2(e10), i8 = n9.write(t9, r10);
        i8 !== e10 && (n9 = n9.slice(0, i8));
        return n9;
      }(t8, r9);
    if (ArrayBuffer.isView(t8))
      return p5(t8);
    if (null == t8)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
    if (F3(t8, ArrayBuffer) || t8 && F3(t8.buffer, ArrayBuffer))
      return c$1$1(t8, r9, e9);
    if ("undefined" != typeof SharedArrayBuffer && (F3(t8, SharedArrayBuffer) || t8 && F3(t8.buffer, SharedArrayBuffer)))
      return c$1$1(t8, r9, e9);
    if ("number" == typeof t8)
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var n8 = t8.valueOf && t8.valueOf();
    if (null != n8 && n8 !== t8)
      return u$1$1.from(n8, r9, e9);
    var i7 = function(t9) {
      if (u$1$1.isBuffer(t9)) {
        var r10 = 0 | l$12(t9.length), e10 = f$2(r10);
        return 0 === e10.length || t9.copy(e10, 0, 0, r10), e10;
      }
      if (void 0 !== t9.length)
        return "number" != typeof t9.length || N3(t9.length) ? f$2(0) : p5(t9);
      if ("Buffer" === t9.type && Array.isArray(t9.data))
        return p5(t9.data);
    }(t8);
    if (i7)
      return i7;
    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t8[Symbol.toPrimitive])
      return u$1$1.from(t8[Symbol.toPrimitive]("string"), r9, e9);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t8);
  }
  function h$1$1(t8) {
    if ("number" != typeof t8)
      throw new TypeError('"size" argument must be of type number');
    if (t8 < 0)
      throw new RangeError('The value "' + t8 + '" is invalid for option "size"');
  }
  function a$2(t8) {
    return h$1$1(t8), f$2(t8 < 0 ? 0 : 0 | l$12(t8));
  }
  function p5(t8) {
    for (var r9 = t8.length < 0 ? 0 : 0 | l$12(t8.length), e9 = f$2(r9), n8 = 0; n8 < r9; n8 += 1)
      e9[n8] = 255 & t8[n8];
    return e9;
  }
  function c$1$1(t8, r9, e9) {
    if (r9 < 0 || t8.byteLength < r9)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t8.byteLength < r9 + (e9 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var n8;
    return n8 = void 0 === r9 && void 0 === e9 ? new Uint8Array(t8) : void 0 === e9 ? new Uint8Array(t8, r9) : new Uint8Array(t8, r9, e9), Object.setPrototypeOf(n8, u$1$1.prototype), n8;
  }
  function l$12(t8) {
    if (t8 >= 2147483647)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
    return 0 | t8;
  }
  function y3(t8, r9) {
    if (u$1$1.isBuffer(t8))
      return t8.length;
    if (ArrayBuffer.isView(t8) || F3(t8, ArrayBuffer))
      return t8.byteLength;
    if ("string" != typeof t8)
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t8);
    var e9 = t8.length, n8 = arguments.length > 2 && true === arguments[2];
    if (!n8 && 0 === e9)
      return 0;
    for (var i7 = false; ; )
      switch (r9) {
        case "ascii":
        case "latin1":
        case "binary":
          return e9;
        case "utf8":
        case "utf-8":
          return _3(t8).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * e9;
        case "hex":
          return e9 >>> 1;
        case "base64":
          return z3(t8).length;
        default:
          if (i7)
            return n8 ? -1 : _3(t8).length;
          r9 = ("" + r9).toLowerCase(), i7 = true;
      }
  }
  function g2(t8, r9, e9) {
    var n8 = false;
    if ((void 0 === r9 || r9 < 0) && (r9 = 0), r9 > this.length)
      return "";
    if ((void 0 === e9 || e9 > this.length) && (e9 = this.length), e9 <= 0)
      return "";
    if ((e9 >>>= 0) <= (r9 >>>= 0))
      return "";
    for (t8 || (t8 = "utf8"); ; )
      switch (t8) {
        case "hex":
          return O2(this, r9, e9);
        case "utf8":
        case "utf-8":
          return I3(this, r9, e9);
        case "ascii":
          return S3(this, r9, e9);
        case "latin1":
        case "binary":
          return R3(this, r9, e9);
        case "base64":
          return T4(this, r9, e9);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return L3(this, r9, e9);
        default:
          if (n8)
            throw new TypeError("Unknown encoding: " + t8);
          t8 = (t8 + "").toLowerCase(), n8 = true;
      }
  }
  function w3(t8, r9, e9) {
    var n8 = t8[r9];
    t8[r9] = t8[e9], t8[e9] = n8;
  }
  function d4(t8, r9, e9, n8, i7) {
    if (0 === t8.length)
      return -1;
    if ("string" == typeof e9 ? (n8 = e9, e9 = 0) : e9 > 2147483647 ? e9 = 2147483647 : e9 < -2147483648 && (e9 = -2147483648), N3(e9 = +e9) && (e9 = i7 ? 0 : t8.length - 1), e9 < 0 && (e9 = t8.length + e9), e9 >= t8.length) {
      if (i7)
        return -1;
      e9 = t8.length - 1;
    } else if (e9 < 0) {
      if (!i7)
        return -1;
      e9 = 0;
    }
    if ("string" == typeof r9 && (r9 = u$1$1.from(r9, n8)), u$1$1.isBuffer(r9))
      return 0 === r9.length ? -1 : v4(t8, r9, e9, n8, i7);
    if ("number" == typeof r9)
      return r9 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i7 ? Uint8Array.prototype.indexOf.call(t8, r9, e9) : Uint8Array.prototype.lastIndexOf.call(t8, r9, e9) : v4(t8, [r9], e9, n8, i7);
    throw new TypeError("val must be string, number or Buffer");
  }
  function v4(t8, r9, e9, n8, i7) {
    var o8, f7 = 1, u7 = t8.length, s7 = r9.length;
    if (void 0 !== n8 && ("ucs2" === (n8 = String(n8).toLowerCase()) || "ucs-2" === n8 || "utf16le" === n8 || "utf-16le" === n8)) {
      if (t8.length < 2 || r9.length < 2)
        return -1;
      f7 = 2, u7 /= 2, s7 /= 2, e9 /= 2;
    }
    function h8(t9, r10) {
      return 1 === f7 ? t9[r10] : t9.readUInt16BE(r10 * f7);
    }
    if (i7) {
      var a8 = -1;
      for (o8 = e9; o8 < u7; o8++)
        if (h8(t8, o8) === h8(r9, -1 === a8 ? 0 : o8 - a8)) {
          if (-1 === a8 && (a8 = o8), o8 - a8 + 1 === s7)
            return a8 * f7;
        } else
          -1 !== a8 && (o8 -= o8 - a8), a8 = -1;
    } else
      for (e9 + s7 > u7 && (e9 = u7 - s7), o8 = e9; o8 >= 0; o8--) {
        for (var p8 = true, c7 = 0; c7 < s7; c7++)
          if (h8(t8, o8 + c7) !== h8(r9, c7)) {
            p8 = false;
            break;
          }
        if (p8)
          return o8;
      }
    return -1;
  }
  function b3(t8, r9, e9, n8) {
    e9 = Number(e9) || 0;
    var i7 = t8.length - e9;
    n8 ? (n8 = Number(n8)) > i7 && (n8 = i7) : n8 = i7;
    var o8 = r9.length;
    n8 > o8 / 2 && (n8 = o8 / 2);
    for (var f7 = 0; f7 < n8; ++f7) {
      var u7 = parseInt(r9.substr(2 * f7, 2), 16);
      if (N3(u7))
        return f7;
      t8[e9 + f7] = u7;
    }
    return f7;
  }
  function m3(t8, r9, e9, n8) {
    return D3(_3(r9, t8.length - e9), t8, e9, n8);
  }
  function E3(t8, r9, e9, n8) {
    return D3(function(t9) {
      for (var r10 = [], e10 = 0; e10 < t9.length; ++e10)
        r10.push(255 & t9.charCodeAt(e10));
      return r10;
    }(r9), t8, e9, n8);
  }
  function B3(t8, r9, e9, n8) {
    return E3(t8, r9, e9, n8);
  }
  function A3(t8, r9, e9, n8) {
    return D3(z3(r9), t8, e9, n8);
  }
  function U3(t8, r9, e9, n8) {
    return D3(function(t9, r10) {
      for (var e10, n9, i7, o8 = [], f7 = 0; f7 < t9.length && !((r10 -= 2) < 0); ++f7)
        e10 = t9.charCodeAt(f7), n9 = e10 >> 8, i7 = e10 % 256, o8.push(i7), o8.push(n9);
      return o8;
    }(r9, t8.length - e9), t8, e9, n8);
  }
  function T4(t8, r9, e9) {
    return 0 === r9 && e9 === t8.length ? n$1$1.fromByteArray(t8) : n$1$1.fromByteArray(t8.slice(r9, e9));
  }
  function I3(t8, r9, e9) {
    e9 = Math.min(t8.length, e9);
    for (var n8 = [], i7 = r9; i7 < e9; ) {
      var o8, f7, u7, s7, h8 = t8[i7], a8 = null, p8 = h8 > 239 ? 4 : h8 > 223 ? 3 : h8 > 191 ? 2 : 1;
      if (i7 + p8 <= e9)
        switch (p8) {
          case 1:
            h8 < 128 && (a8 = h8);
            break;
          case 2:
            128 == (192 & (o8 = t8[i7 + 1])) && (s7 = (31 & h8) << 6 | 63 & o8) > 127 && (a8 = s7);
            break;
          case 3:
            o8 = t8[i7 + 1], f7 = t8[i7 + 2], 128 == (192 & o8) && 128 == (192 & f7) && (s7 = (15 & h8) << 12 | (63 & o8) << 6 | 63 & f7) > 2047 && (s7 < 55296 || s7 > 57343) && (a8 = s7);
            break;
          case 4:
            o8 = t8[i7 + 1], f7 = t8[i7 + 2], u7 = t8[i7 + 3], 128 == (192 & o8) && 128 == (192 & f7) && 128 == (192 & u7) && (s7 = (15 & h8) << 18 | (63 & o8) << 12 | (63 & f7) << 6 | 63 & u7) > 65535 && s7 < 1114112 && (a8 = s7);
        }
      null === a8 ? (a8 = 65533, p8 = 1) : a8 > 65535 && (a8 -= 65536, n8.push(a8 >>> 10 & 1023 | 55296), a8 = 56320 | 1023 & a8), n8.push(a8), i7 += p8;
    }
    return function(t9) {
      var r10 = t9.length;
      if (r10 <= 4096)
        return String.fromCharCode.apply(String, t9);
      var e10 = "", n9 = 0;
      for (; n9 < r10; )
        e10 += String.fromCharCode.apply(String, t9.slice(n9, n9 += 4096));
      return e10;
    }(n8);
  }
  function S3(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7)
      n8 += String.fromCharCode(127 & t8[i7]);
    return n8;
  }
  function R3(t8, r9, e9) {
    var n8 = "";
    e9 = Math.min(t8.length, e9);
    for (var i7 = r9; i7 < e9; ++i7)
      n8 += String.fromCharCode(t8[i7]);
    return n8;
  }
  function O2(t8, r9, e9) {
    var n8 = t8.length;
    (!r9 || r9 < 0) && (r9 = 0), (!e9 || e9 < 0 || e9 > n8) && (e9 = n8);
    for (var i7 = "", o8 = r9; o8 < e9; ++o8)
      i7 += Y3[t8[o8]];
    return i7;
  }
  function L3(t8, r9, e9) {
    for (var n8 = t8.slice(r9, e9), i7 = "", o8 = 0; o8 < n8.length; o8 += 2)
      i7 += String.fromCharCode(n8[o8] + 256 * n8[o8 + 1]);
    return i7;
  }
  function x2(t8, r9, e9) {
    if (t8 % 1 != 0 || t8 < 0)
      throw new RangeError("offset is not uint");
    if (t8 + r9 > e9)
      throw new RangeError("Trying to access beyond buffer length");
  }
  function C3(t8, r9, e9, n8, i7, o8) {
    if (!u$1$1.isBuffer(t8))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r9 > i7 || r9 < o8)
      throw new RangeError('"value" argument is out of bounds');
    if (e9 + n8 > t8.length)
      throw new RangeError("Index out of range");
  }
  function P3(t8, r9, e9, n8, i7, o8) {
    if (e9 + n8 > t8.length)
      throw new RangeError("Index out of range");
    if (e9 < 0)
      throw new RangeError("Index out of range");
  }
  function k3(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P3(t8, 0, e9, 4), i$12.write(t8, r9, e9, n8, 23, 4), e9 + 4;
  }
  function M2(t8, r9, e9, n8, o8) {
    return r9 = +r9, e9 >>>= 0, o8 || P3(t8, 0, e9, 8), i$12.write(t8, r9, e9, n8, 52, 8), e9 + 8;
  }
  function _3(t8, r9) {
    var e9;
    r9 = r9 || 1 / 0;
    for (var n8 = t8.length, i7 = null, o8 = [], f7 = 0; f7 < n8; ++f7) {
      if ((e9 = t8.charCodeAt(f7)) > 55295 && e9 < 57344) {
        if (!i7) {
          if (e9 > 56319) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          if (f7 + 1 === n8) {
            (r9 -= 3) > -1 && o8.push(239, 191, 189);
            continue;
          }
          i7 = e9;
          continue;
        }
        if (e9 < 56320) {
          (r9 -= 3) > -1 && o8.push(239, 191, 189), i7 = e9;
          continue;
        }
        e9 = 65536 + (i7 - 55296 << 10 | e9 - 56320);
      } else
        i7 && (r9 -= 3) > -1 && o8.push(239, 191, 189);
      if (i7 = null, e9 < 128) {
        if ((r9 -= 1) < 0)
          break;
        o8.push(e9);
      } else if (e9 < 2048) {
        if ((r9 -= 2) < 0)
          break;
        o8.push(e9 >> 6 | 192, 63 & e9 | 128);
      } else if (e9 < 65536) {
        if ((r9 -= 3) < 0)
          break;
        o8.push(e9 >> 12 | 224, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      } else {
        if (!(e9 < 1114112))
          throw new Error("Invalid code point");
        if ((r9 -= 4) < 0)
          break;
        o8.push(e9 >> 18 | 240, e9 >> 12 & 63 | 128, e9 >> 6 & 63 | 128, 63 & e9 | 128);
      }
    }
    return o8;
  }
  function z3(t8) {
    return n$1$1.toByteArray(function(t9) {
      if ((t9 = (t9 = t9.split("=")[0]).trim().replace(j3, "")).length < 2)
        return "";
      for (; t9.length % 4 != 0; )
        t9 += "=";
      return t9;
    }(t8));
  }
  function D3(t8, r9, e9, n8) {
    for (var i7 = 0; i7 < n8 && !(i7 + e9 >= r9.length || i7 >= t8.length); ++i7)
      r9[i7 + e9] = t8[i7];
    return i7;
  }
  function F3(t8, r9) {
    return t8 instanceof r9 || null != t8 && null != t8.constructor && null != t8.constructor.name && t8.constructor.name === r9.name;
  }
  function N3(t8) {
    return t8 != t8;
  }
  function t4(r9, e9) {
    for (var n8 in r9)
      e9[n8] = r9[n8];
  }
  function f4(r9, e9, n8) {
    return o4(r9, e9, n8);
  }
  function a5(t8) {
    var e9;
    switch (this.encoding = function(t9) {
      var e10 = function(t10) {
        if (!t10)
          return "utf8";
        for (var e11; ; )
          switch (t10) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return t10;
            default:
              if (e11)
                return;
              t10 = ("" + t10).toLowerCase(), e11 = true;
          }
      }(t9);
      if ("string" != typeof e10 && (s5.isEncoding === i4 || !i4(t9)))
        throw new Error("Unknown encoding: " + t9);
      return e10 || t9;
    }(t8), this.encoding) {
      case "utf16le":
        this.text = h4, this.end = l4, e9 = 4;
        break;
      case "utf8":
        this.fillLast = n$12, e9 = 4;
        break;
      case "base64":
        this.text = u$12, this.end = o$12, e9 = 3;
        break;
      default:
        return this.write = f$1, this.end = c4, void 0;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s5.allocUnsafe(e9);
  }
  function r4(t8) {
    return t8 <= 127 ? 0 : t8 >> 5 == 6 ? 2 : t8 >> 4 == 14 ? 3 : t8 >> 3 == 30 ? 4 : t8 >> 6 == 2 ? -1 : -2;
  }
  function n$12(t8) {
    var e9 = this.lastTotal - this.lastNeed, s7 = function(t9, e10, s8) {
      if (128 != (192 & e10[0]))
        return t9.lastNeed = 0, "\uFFFD";
      if (t9.lastNeed > 1 && e10.length > 1) {
        if (128 != (192 & e10[1]))
          return t9.lastNeed = 1, "\uFFFD";
        if (t9.lastNeed > 2 && e10.length > 2 && 128 != (192 & e10[2]))
          return t9.lastNeed = 2, "\uFFFD";
      }
    }(this, t8);
    return void 0 !== s7 ? s7 : this.lastNeed <= t8.length ? (t8.copy(this.lastChar, e9, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t8.copy(this.lastChar, e9, 0, t8.length), this.lastNeed -= t8.length, void 0);
  }
  function h4(t8, e9) {
    if ((t8.length - e9) % 2 == 0) {
      var s7 = t8.toString("utf16le", e9);
      if (s7) {
        var i7 = s7.charCodeAt(s7.length - 1);
        if (i7 >= 55296 && i7 <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1], s7.slice(0, -1);
      }
      return s7;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t8[t8.length - 1], t8.toString("utf16le", e9, t8.length - 1);
  }
  function l4(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    if (this.lastNeed) {
      var s7 = this.lastTotal - this.lastNeed;
      return e9 + this.lastChar.toString("utf16le", 0, s7);
    }
    return e9;
  }
  function u$12(t8, e9) {
    var s7 = (t8.length - e9) % 3;
    return 0 === s7 ? t8.toString("base64", e9) : (this.lastNeed = 3 - s7, this.lastTotal = 3, 1 === s7 ? this.lastChar[0] = t8[t8.length - 1] : (this.lastChar[0] = t8[t8.length - 2], this.lastChar[1] = t8[t8.length - 1]), t8.toString("base64", e9, t8.length - s7));
  }
  function o$12(t8) {
    var e9 = t8 && t8.length ? this.write(t8) : "";
    return this.lastNeed ? e9 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e9;
  }
  function f$1(t8) {
    return t8.toString(this.encoding);
  }
  function c4(t8) {
    return t8 && t8.length ? this.write(t8) : "";
  }
  var r$13, t$13, e$22, n$22, o$23, a$12, h$12, a$1$1, e$1$1, n$1$1, i$12, o$1$1, j3, Y3, e4, n4, o4, u4, e$12, s5, i4;
  var init_chunk_4ccc3a29 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-4ccc3a29.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      for (r$13 = { byteLength: function(r9) {
        var t8 = u$2(r9), e9 = t8[0], n8 = t8[1];
        return 3 * (e9 + n8) / 4 - n8;
      }, toByteArray: function(r9) {
        var t8, o8, a8 = u$2(r9), h8 = a8[0], c7 = a8[1], d7 = new n$22(function(r10, t9, e9) {
          return 3 * (t9 + e9) / 4 - e9;
        }(0, h8, c7)), f7 = 0, A5 = c7 > 0 ? h8 - 4 : h8;
        for (o8 = 0; o8 < A5; o8 += 4)
          t8 = e$22[r9.charCodeAt(o8)] << 18 | e$22[r9.charCodeAt(o8 + 1)] << 12 | e$22[r9.charCodeAt(o8 + 2)] << 6 | e$22[r9.charCodeAt(o8 + 3)], d7[f7++] = t8 >> 16 & 255, d7[f7++] = t8 >> 8 & 255, d7[f7++] = 255 & t8;
        2 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 2 | e$22[r9.charCodeAt(o8 + 1)] >> 4, d7[f7++] = 255 & t8);
        1 === c7 && (t8 = e$22[r9.charCodeAt(o8)] << 10 | e$22[r9.charCodeAt(o8 + 1)] << 4 | e$22[r9.charCodeAt(o8 + 2)] >> 2, d7[f7++] = t8 >> 8 & 255, d7[f7++] = 255 & t8);
        return d7;
      }, fromByteArray: function(r9) {
        for (var e9, n8 = r9.length, o8 = n8 % 3, a8 = [], h8 = 0, u7 = n8 - o8; h8 < u7; h8 += 16383)
          a8.push(c$12(r9, h8, h8 + 16383 > u7 ? u7 : h8 + 16383));
        1 === o8 ? (e9 = r9[n8 - 1], a8.push(t$13[e9 >> 2] + t$13[e9 << 4 & 63] + "==")) : 2 === o8 && (e9 = (r9[n8 - 2] << 8) + r9[n8 - 1], a8.push(t$13[e9 >> 10] + t$13[e9 >> 4 & 63] + t$13[e9 << 2 & 63] + "="));
        return a8.join("");
      } }, t$13 = [], e$22 = [], n$22 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$23 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$12 = 0, h$12 = o$23.length; a$12 < h$12; ++a$12)
        t$13[a$12] = o$23[a$12], e$22[o$23.charCodeAt(a$12)] = a$12;
      e$22["-".charCodeAt(0)] = 62, e$22["_".charCodeAt(0)] = 63;
      a$1$1 = { read: function(a8, t8, o8, r9, h8) {
        var M4, f7, p8 = 8 * h8 - r9 - 1, w5 = (1 << p8) - 1, e9 = w5 >> 1, i7 = -7, N5 = o8 ? h8 - 1 : 0, n8 = o8 ? -1 : 1, u7 = a8[t8 + N5];
        for (N5 += n8, M4 = u7 & (1 << -i7) - 1, u7 >>= -i7, i7 += p8; i7 > 0; M4 = 256 * M4 + a8[t8 + N5], N5 += n8, i7 -= 8)
          ;
        for (f7 = M4 & (1 << -i7) - 1, M4 >>= -i7, i7 += r9; i7 > 0; f7 = 256 * f7 + a8[t8 + N5], N5 += n8, i7 -= 8)
          ;
        if (0 === M4)
          M4 = 1 - e9;
        else {
          if (M4 === w5)
            return f7 ? NaN : 1 / 0 * (u7 ? -1 : 1);
          f7 += Math.pow(2, r9), M4 -= e9;
        }
        return (u7 ? -1 : 1) * f7 * Math.pow(2, M4 - r9);
      }, write: function(a8, t8, o8, r9, h8, M4) {
        var f7, p8, w5, e9 = 8 * M4 - h8 - 1, i7 = (1 << e9) - 1, N5 = i7 >> 1, n8 = 23 === h8 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u7 = r9 ? 0 : M4 - 1, l7 = r9 ? 1 : -1, s7 = t8 < 0 || 0 === t8 && 1 / t8 < 0 ? 1 : 0;
        for (t8 = Math.abs(t8), isNaN(t8) || t8 === 1 / 0 ? (p8 = isNaN(t8) ? 1 : 0, f7 = i7) : (f7 = Math.floor(Math.log(t8) / Math.LN2), t8 * (w5 = Math.pow(2, -f7)) < 1 && (f7--, w5 *= 2), (t8 += f7 + N5 >= 1 ? n8 / w5 : n8 * Math.pow(2, 1 - N5)) * w5 >= 2 && (f7++, w5 /= 2), f7 + N5 >= i7 ? (p8 = 0, f7 = i7) : f7 + N5 >= 1 ? (p8 = (t8 * w5 - 1) * Math.pow(2, h8), f7 += N5) : (p8 = t8 * Math.pow(2, N5 - 1) * Math.pow(2, h8), f7 = 0)); h8 >= 8; a8[o8 + u7] = 255 & p8, u7 += l7, p8 /= 256, h8 -= 8)
          ;
        for (f7 = f7 << h8 | p8, e9 += h8; e9 > 0; a8[o8 + u7] = 255 & f7, u7 += l7, f7 /= 256, e9 -= 8)
          ;
        a8[o8 + u7 - l7] |= 128 * s7;
      } };
      e$1$1 = {};
      n$1$1 = r$13;
      i$12 = a$1$1;
      o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
      e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t8) {
        +t8 != t8 && (t8 = 0);
        return u$1$1.alloc(+t8);
      }, e$1$1.INSPECT_MAX_BYTES = 50;
      e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
        try {
          var t8 = new Uint8Array(1), r9 = { foo: function() {
            return 42;
          } };
          return Object.setPrototypeOf(r9, Uint8Array.prototype), Object.setPrototypeOf(t8, r9), 42 === t8.foo();
        } catch (t9) {
          return false;
        }
      }(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.buffer;
      } }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
        if (u$1$1.isBuffer(this))
          return this.byteOffset;
      } }), u$1$1.poolSize = 8192, u$1$1.from = function(t8, r9, e9) {
        return s$1(t8, r9, e9);
      }, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t8, r9, e9) {
        return function(t9, r10, e10) {
          return h$1$1(t9), t9 <= 0 ? f$2(t9) : void 0 !== r10 ? "string" == typeof e10 ? f$2(t9).fill(r10, e10) : f$2(t9).fill(r10) : f$2(t9);
        }(t8, r9, e9);
      }, u$1$1.allocUnsafe = function(t8) {
        return a$2(t8);
      }, u$1$1.allocUnsafeSlow = function(t8) {
        return a$2(t8);
      }, u$1$1.isBuffer = function(t8) {
        return null != t8 && true === t8._isBuffer && t8 !== u$1$1.prototype;
      }, u$1$1.compare = function(t8, r9) {
        if (F3(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), F3(r9, Uint8Array) && (r9 = u$1$1.from(r9, r9.offset, r9.byteLength)), !u$1$1.isBuffer(t8) || !u$1$1.isBuffer(r9))
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (t8 === r9)
          return 0;
        for (var e9 = t8.length, n8 = r9.length, i7 = 0, o8 = Math.min(e9, n8); i7 < o8; ++i7)
          if (t8[i7] !== r9[i7]) {
            e9 = t8[i7], n8 = r9[i7];
            break;
          }
        return e9 < n8 ? -1 : n8 < e9 ? 1 : 0;
      }, u$1$1.isEncoding = function(t8) {
        switch (String(t8).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, u$1$1.concat = function(t8, r9) {
        if (!Array.isArray(t8))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t8.length)
          return u$1$1.alloc(0);
        var e9;
        if (void 0 === r9)
          for (r9 = 0, e9 = 0; e9 < t8.length; ++e9)
            r9 += t8[e9].length;
        var n8 = u$1$1.allocUnsafe(r9), i7 = 0;
        for (e9 = 0; e9 < t8.length; ++e9) {
          var o8 = t8[e9];
          if (F3(o8, Uint8Array) && (o8 = u$1$1.from(o8)), !u$1$1.isBuffer(o8))
            throw new TypeError('"list" argument must be an Array of Buffers');
          o8.copy(n8, i7), i7 += o8.length;
        }
        return n8;
      }, u$1$1.byteLength = y3, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
        var t8 = this.length;
        if (t8 % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var r9 = 0; r9 < t8; r9 += 2)
          w3(this, r9, r9 + 1);
        return this;
      }, u$1$1.prototype.swap32 = function() {
        var t8 = this.length;
        if (t8 % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var r9 = 0; r9 < t8; r9 += 4)
          w3(this, r9, r9 + 3), w3(this, r9 + 1, r9 + 2);
        return this;
      }, u$1$1.prototype.swap64 = function() {
        var t8 = this.length;
        if (t8 % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var r9 = 0; r9 < t8; r9 += 8)
          w3(this, r9, r9 + 7), w3(this, r9 + 1, r9 + 6), w3(this, r9 + 2, r9 + 5), w3(this, r9 + 3, r9 + 4);
        return this;
      }, u$1$1.prototype.toString = function() {
        var t8 = this.length;
        return 0 === t8 ? "" : 0 === arguments.length ? I3(this, 0, t8) : g2.apply(this, arguments);
      }, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t8) {
        if (!u$1$1.isBuffer(t8))
          throw new TypeError("Argument must be a Buffer");
        return this === t8 || 0 === u$1$1.compare(this, t8);
      }, u$1$1.prototype.inspect = function() {
        var t8 = "", r9 = e$1$1.INSPECT_MAX_BYTES;
        return t8 = this.toString("hex", 0, r9).replace(/(.{2})/g, "$1 ").trim(), this.length > r9 && (t8 += " ... "), "<Buffer " + t8 + ">";
      }, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t8, r9, e9, n8, i7) {
        if (F3(t8, Uint8Array) && (t8 = u$1$1.from(t8, t8.offset, t8.byteLength)), !u$1$1.isBuffer(t8))
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t8);
        if (void 0 === r9 && (r9 = 0), void 0 === e9 && (e9 = t8 ? t8.length : 0), void 0 === n8 && (n8 = 0), void 0 === i7 && (i7 = this.length), r9 < 0 || e9 > t8.length || n8 < 0 || i7 > this.length)
          throw new RangeError("out of range index");
        if (n8 >= i7 && r9 >= e9)
          return 0;
        if (n8 >= i7)
          return -1;
        if (r9 >= e9)
          return 1;
        if (this === t8)
          return 0;
        for (var o8 = (i7 >>>= 0) - (n8 >>>= 0), f7 = (e9 >>>= 0) - (r9 >>>= 0), s7 = Math.min(o8, f7), h8 = this.slice(n8, i7), a8 = t8.slice(r9, e9), p8 = 0; p8 < s7; ++p8)
          if (h8[p8] !== a8[p8]) {
            o8 = h8[p8], f7 = a8[p8];
            break;
          }
        return o8 < f7 ? -1 : f7 < o8 ? 1 : 0;
      }, u$1$1.prototype.includes = function(t8, r9, e9) {
        return -1 !== this.indexOf(t8, r9, e9);
      }, u$1$1.prototype.indexOf = function(t8, r9, e9) {
        return d4(this, t8, r9, e9, true);
      }, u$1$1.prototype.lastIndexOf = function(t8, r9, e9) {
        return d4(this, t8, r9, e9, false);
      }, u$1$1.prototype.write = function(t8, r9, e9, n8) {
        if (void 0 === r9)
          n8 = "utf8", e9 = this.length, r9 = 0;
        else if (void 0 === e9 && "string" == typeof r9)
          n8 = r9, e9 = this.length, r9 = 0;
        else {
          if (!isFinite(r9))
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          r9 >>>= 0, isFinite(e9) ? (e9 >>>= 0, void 0 === n8 && (n8 = "utf8")) : (n8 = e9, e9 = void 0);
        }
        var i7 = this.length - r9;
        if ((void 0 === e9 || e9 > i7) && (e9 = i7), t8.length > 0 && (e9 < 0 || r9 < 0) || r9 > this.length)
          throw new RangeError("Attempt to write outside buffer bounds");
        n8 || (n8 = "utf8");
        for (var o8 = false; ; )
          switch (n8) {
            case "hex":
              return b3(this, t8, r9, e9);
            case "utf8":
            case "utf-8":
              return m3(this, t8, r9, e9);
            case "ascii":
              return E3(this, t8, r9, e9);
            case "latin1":
            case "binary":
              return B3(this, t8, r9, e9);
            case "base64":
              return A3(this, t8, r9, e9);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return U3(this, t8, r9, e9);
            default:
              if (o8)
                throw new TypeError("Unknown encoding: " + n8);
              n8 = ("" + n8).toLowerCase(), o8 = true;
          }
      }, u$1$1.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      u$1$1.prototype.slice = function(t8, r9) {
        var e9 = this.length;
        (t8 = ~~t8) < 0 ? (t8 += e9) < 0 && (t8 = 0) : t8 > e9 && (t8 = e9), (r9 = void 0 === r9 ? e9 : ~~r9) < 0 ? (r9 += e9) < 0 && (r9 = 0) : r9 > e9 && (r9 = e9), r9 < t8 && (r9 = t8);
        var n8 = this.subarray(t8, r9);
        return Object.setPrototypeOf(n8, u$1$1.prototype), n8;
      }, u$1$1.prototype.readUIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
          n8 += this[t8 + o8] * i7;
        return n8;
      }, u$1$1.prototype.readUIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8 + --r9], i7 = 1; r9 > 0 && (i7 *= 256); )
          n8 += this[t8 + --r9] * i7;
        return n8;
      }, u$1$1.prototype.readUInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 1, this.length), this[t8];
      }, u$1$1.prototype.readUInt16LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] | this[t8 + 1] << 8;
      }, u$1$1.prototype.readUInt16BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 2, this.length), this[t8] << 8 | this[t8 + 1];
      }, u$1$1.prototype.readUInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), (this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16) + 16777216 * this[t8 + 3];
      }, u$1$1.prototype.readUInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), 16777216 * this[t8] + (this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3]);
      }, u$1$1.prototype.readIntLE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = this[t8], i7 = 1, o8 = 0; ++o8 < r9 && (i7 *= 256); )
          n8 += this[t8 + o8] * i7;
        return n8 >= (i7 *= 128) && (n8 -= Math.pow(2, 8 * r9)), n8;
      }, u$1$1.prototype.readIntBE = function(t8, r9, e9) {
        t8 >>>= 0, r9 >>>= 0, e9 || x2(t8, r9, this.length);
        for (var n8 = r9, i7 = 1, o8 = this[t8 + --n8]; n8 > 0 && (i7 *= 256); )
          o8 += this[t8 + --n8] * i7;
        return o8 >= (i7 *= 128) && (o8 -= Math.pow(2, 8 * r9)), o8;
      }, u$1$1.prototype.readInt8 = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 1, this.length), 128 & this[t8] ? -1 * (255 - this[t8] + 1) : this[t8];
      }, u$1$1.prototype.readInt16LE = function(t8, r9) {
        t8 >>>= 0, r9 || x2(t8, 2, this.length);
        var e9 = this[t8] | this[t8 + 1] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt16BE = function(t8, r9) {
        t8 >>>= 0, r9 || x2(t8, 2, this.length);
        var e9 = this[t8 + 1] | this[t8] << 8;
        return 32768 & e9 ? 4294901760 | e9 : e9;
      }, u$1$1.prototype.readInt32LE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] | this[t8 + 1] << 8 | this[t8 + 2] << 16 | this[t8 + 3] << 24;
      }, u$1$1.prototype.readInt32BE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), this[t8] << 24 | this[t8 + 1] << 16 | this[t8 + 2] << 8 | this[t8 + 3];
      }, u$1$1.prototype.readFloatLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, true, 23, 4);
      }, u$1$1.prototype.readFloatBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 4, this.length), i$12.read(this, t8, false, 23, 4);
      }, u$1$1.prototype.readDoubleLE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, true, 52, 8);
      }, u$1$1.prototype.readDoubleBE = function(t8, r9) {
        return t8 >>>= 0, r9 || x2(t8, 8, this.length), i$12.read(this, t8, false, 52, 8);
      }, u$1$1.prototype.writeUIntLE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C3(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = 1, o8 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (i7 *= 256); )
          this[r9 + o8] = t8 / i7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUIntBE = function(t8, r9, e9, n8) {
        (t8 = +t8, r9 >>>= 0, e9 >>>= 0, n8) || C3(this, t8, r9, e9, Math.pow(2, 8 * e9) - 1, 0);
        var i7 = e9 - 1, o8 = 1;
        for (this[r9 + i7] = 255 & t8; --i7 >= 0 && (o8 *= 256); )
          this[r9 + i7] = t8 / o8 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeUInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 1, 255, 0), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeUInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 65535, 0), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeUInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 65535, 0), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeUInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 4294967295, 0), this[r9 + 3] = t8 >>> 24, this[r9 + 2] = t8 >>> 16, this[r9 + 1] = t8 >>> 8, this[r9] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeUInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 4294967295, 0), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeIntLE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C3(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = 0, f7 = 1, u7 = 0;
        for (this[r9] = 255 & t8; ++o8 < e9 && (f7 *= 256); )
          t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 - 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeIntBE = function(t8, r9, e9, n8) {
        if (t8 = +t8, r9 >>>= 0, !n8) {
          var i7 = Math.pow(2, 8 * e9 - 1);
          C3(this, t8, r9, e9, i7 - 1, -i7);
        }
        var o8 = e9 - 1, f7 = 1, u7 = 0;
        for (this[r9 + o8] = 255 & t8; --o8 >= 0 && (f7 *= 256); )
          t8 < 0 && 0 === u7 && 0 !== this[r9 + o8 + 1] && (u7 = 1), this[r9 + o8] = (t8 / f7 >> 0) - u7 & 255;
        return r9 + e9;
      }, u$1$1.prototype.writeInt8 = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 1, 127, -128), t8 < 0 && (t8 = 255 + t8 + 1), this[r9] = 255 & t8, r9 + 1;
      }, u$1$1.prototype.writeInt16LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 32767, -32768), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, r9 + 2;
      }, u$1$1.prototype.writeInt16BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 2, 32767, -32768), this[r9] = t8 >>> 8, this[r9 + 1] = 255 & t8, r9 + 2;
      }, u$1$1.prototype.writeInt32LE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 2147483647, -2147483648), this[r9] = 255 & t8, this[r9 + 1] = t8 >>> 8, this[r9 + 2] = t8 >>> 16, this[r9 + 3] = t8 >>> 24, r9 + 4;
      }, u$1$1.prototype.writeInt32BE = function(t8, r9, e9) {
        return t8 = +t8, r9 >>>= 0, e9 || C3(this, t8, r9, 4, 2147483647, -2147483648), t8 < 0 && (t8 = 4294967295 + t8 + 1), this[r9] = t8 >>> 24, this[r9 + 1] = t8 >>> 16, this[r9 + 2] = t8 >>> 8, this[r9 + 3] = 255 & t8, r9 + 4;
      }, u$1$1.prototype.writeFloatLE = function(t8, r9, e9) {
        return k3(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeFloatBE = function(t8, r9, e9) {
        return k3(this, t8, r9, false, e9);
      }, u$1$1.prototype.writeDoubleLE = function(t8, r9, e9) {
        return M2(this, t8, r9, true, e9);
      }, u$1$1.prototype.writeDoubleBE = function(t8, r9, e9) {
        return M2(this, t8, r9, false, e9);
      }, u$1$1.prototype.copy = function(t8, r9, e9, n8) {
        if (!u$1$1.isBuffer(t8))
          throw new TypeError("argument should be a Buffer");
        if (e9 || (e9 = 0), n8 || 0 === n8 || (n8 = this.length), r9 >= t8.length && (r9 = t8.length), r9 || (r9 = 0), n8 > 0 && n8 < e9 && (n8 = e9), n8 === e9)
          return 0;
        if (0 === t8.length || 0 === this.length)
          return 0;
        if (r9 < 0)
          throw new RangeError("targetStart out of bounds");
        if (e9 < 0 || e9 >= this.length)
          throw new RangeError("Index out of range");
        if (n8 < 0)
          throw new RangeError("sourceEnd out of bounds");
        n8 > this.length && (n8 = this.length), t8.length - r9 < n8 - e9 && (n8 = t8.length - r9 + e9);
        var i7 = n8 - e9;
        if (this === t8 && "function" == typeof Uint8Array.prototype.copyWithin)
          this.copyWithin(r9, e9, n8);
        else if (this === t8 && e9 < r9 && r9 < n8)
          for (var o8 = i7 - 1; o8 >= 0; --o8)
            t8[o8 + r9] = this[o8 + e9];
        else
          Uint8Array.prototype.set.call(t8, this.subarray(e9, n8), r9);
        return i7;
      }, u$1$1.prototype.fill = function(t8, r9, e9, n8) {
        if ("string" == typeof t8) {
          if ("string" == typeof r9 ? (n8 = r9, r9 = 0, e9 = this.length) : "string" == typeof e9 && (n8 = e9, e9 = this.length), void 0 !== n8 && "string" != typeof n8)
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n8 && !u$1$1.isEncoding(n8))
            throw new TypeError("Unknown encoding: " + n8);
          if (1 === t8.length) {
            var i7 = t8.charCodeAt(0);
            ("utf8" === n8 && i7 < 128 || "latin1" === n8) && (t8 = i7);
          }
        } else
          "number" == typeof t8 ? t8 &= 255 : "boolean" == typeof t8 && (t8 = Number(t8));
        if (r9 < 0 || this.length < r9 || this.length < e9)
          throw new RangeError("Out of range index");
        if (e9 <= r9)
          return this;
        var o8;
        if (r9 >>>= 0, e9 = void 0 === e9 ? this.length : e9 >>> 0, t8 || (t8 = 0), "number" == typeof t8)
          for (o8 = r9; o8 < e9; ++o8)
            this[o8] = t8;
        else {
          var f7 = u$1$1.isBuffer(t8) ? t8 : u$1$1.from(t8, n8), s7 = f7.length;
          if (0 === s7)
            throw new TypeError('The value "' + t8 + '" is invalid for argument "value"');
          for (o8 = 0; o8 < e9 - r9; ++o8)
            this[o8 + r9] = f7[o8 % s7];
        }
        return this;
      };
      j3 = /[^+/0-9A-Za-z-_]/g;
      Y3 = function() {
        for (var t8 = new Array(256), r9 = 0; r9 < 16; ++r9)
          for (var e9 = 16 * r9, n8 = 0; n8 < 16; ++n8)
            t8[e9 + n8] = "0123456789abcdef"[r9] + "0123456789abcdef"[n8];
        return t8;
      }();
      e$1$1.Buffer;
      e$1$1.INSPECT_MAX_BYTES;
      e$1$1.kMaxLength;
      e4 = {};
      n4 = e$1$1;
      o4 = n4.Buffer;
      o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e4 = n4 : (t4(n4, e4), e4.Buffer = f4), f4.prototype = Object.create(o4.prototype), t4(o4, f4), f4.from = function(r9, e9, n8) {
        if ("number" == typeof r9)
          throw new TypeError("Argument must not be a number");
        return o4(r9, e9, n8);
      }, f4.alloc = function(r9, e9, n8) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        var t8 = o4(r9);
        return void 0 !== e9 ? "string" == typeof n8 ? t8.fill(e9, n8) : t8.fill(e9) : t8.fill(0), t8;
      }, f4.allocUnsafe = function(r9) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        return o4(r9);
      }, f4.allocUnsafeSlow = function(r9) {
        if ("number" != typeof r9)
          throw new TypeError("Argument must be a number");
        return n4.SlowBuffer(r9);
      };
      u4 = e4;
      e$12 = {};
      s5 = u4.Buffer;
      i4 = s5.isEncoding || function(t8) {
        switch ((t8 = "" + t8) && t8.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return true;
          default:
            return false;
        }
      };
      e$12.StringDecoder = a5, a5.prototype.write = function(t8) {
        if (0 === t8.length)
          return "";
        var e9, s7;
        if (this.lastNeed) {
          if (void 0 === (e9 = this.fillLast(t8)))
            return "";
          s7 = this.lastNeed, this.lastNeed = 0;
        } else
          s7 = 0;
        return s7 < t8.length ? e9 ? e9 + this.text(t8, s7) : this.text(t8, s7) : e9 || "";
      }, a5.prototype.end = function(t8) {
        var e9 = t8 && t8.length ? this.write(t8) : "";
        return this.lastNeed ? e9 + "\uFFFD" : e9;
      }, a5.prototype.text = function(t8, e9) {
        var s7 = function(t9, e10, s8) {
          var i8 = e10.length - 1;
          if (i8 < s8)
            return 0;
          var a8 = r4(e10[i8]);
          if (a8 >= 0)
            return a8 > 0 && (t9.lastNeed = a8 - 1), a8;
          if (--i8 < s8 || -2 === a8)
            return 0;
          if ((a8 = r4(e10[i8])) >= 0)
            return a8 > 0 && (t9.lastNeed = a8 - 2), a8;
          if (--i8 < s8 || -2 === a8)
            return 0;
          if ((a8 = r4(e10[i8])) >= 0)
            return a8 > 0 && (2 === a8 ? a8 = 0 : t9.lastNeed = a8 - 3), a8;
          return 0;
        }(this, t8, e9);
        if (!this.lastNeed)
          return t8.toString("utf8", e9);
        this.lastTotal = s7;
        var i7 = t8.length - (s7 - this.lastNeed);
        return t8.copy(this.lastChar, 0, i7), t8.toString("utf8", e9, i7);
      }, a5.prototype.fillLast = function(t8) {
        if (this.lastNeed <= t8.length)
          return t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        t8.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t8.length), this.lastNeed -= t8.length;
      };
      e$12.StringDecoder;
      e$12.StringDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js
  function dew$2$1() {
    if (_dewExec$2$1)
      return exports$2$1;
    _dewExec$2$1 = true;
    exports$2$1.byteLength = byteLength;
    exports$2$1.toByteArray = toByteArray;
    exports$2$1.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i7 = 0, len = code.length; i7 < len; ++i7) {
      lookup[i7] = code[i7];
      revLookup[code.charCodeAt(i7)] = i7;
    }
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i8;
      for (i8 = 0; i8 < len2; i8 += 4) {
        tmp = revLookup[b64.charCodeAt(i8)] << 18 | revLookup[b64.charCodeAt(i8 + 1)] << 12 | revLookup[b64.charCodeAt(i8 + 2)] << 6 | revLookup[b64.charCodeAt(i8 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i8)] << 2 | revLookup[b64.charCodeAt(i8 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i8)] << 10 | revLookup[b64.charCodeAt(i8 + 1)] << 4 | revLookup[b64.charCodeAt(i8 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i8 = start; i8 < end; i8 += 3) {
        tmp = (uint8[i8] << 16 & 16711680) + (uint8[i8 + 1] << 8 & 65280) + (uint8[i8 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i8 = 0, len22 = len2 - extraBytes; i8 < len22; i8 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i8, i8 + maxChunkLength > len22 ? len22 : i8 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
    return exports$2$1;
  }
  function dew$1$1() {
    if (_dewExec$1$1)
      return exports$1$1;
    _dewExec$1$1 = true;
    exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e9, m6;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i7 = isLE ? nBytes - 1 : 0;
      var d7 = isLE ? -1 : 1;
      var s7 = buffer2[offset + i7];
      i7 += d7;
      e9 = s7 & (1 << -nBits) - 1;
      s7 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e9 = e9 * 256 + buffer2[offset + i7], i7 += d7, nBits -= 8) {
      }
      m6 = e9 & (1 << -nBits) - 1;
      e9 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m6 = m6 * 256 + buffer2[offset + i7], i7 += d7, nBits -= 8) {
      }
      if (e9 === 0) {
        e9 = 1 - eBias;
      } else if (e9 === eMax) {
        return m6 ? NaN : (s7 ? -1 : 1) * Infinity;
      } else {
        m6 = m6 + Math.pow(2, mLen);
        e9 = e9 - eBias;
      }
      return (s7 ? -1 : 1) * m6 * Math.pow(2, e9 - mLen);
    };
    exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e9, m6, c7;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i7 = isLE ? 0 : nBytes - 1;
      var d7 = isLE ? 1 : -1;
      var s7 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m6 = isNaN(value) ? 1 : 0;
        e9 = eMax;
      } else {
        e9 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c7 = Math.pow(2, -e9)) < 1) {
          e9--;
          c7 *= 2;
        }
        if (e9 + eBias >= 1) {
          value += rt2 / c7;
        } else {
          value += rt2 * Math.pow(2, 1 - eBias);
        }
        if (value * c7 >= 2) {
          e9++;
          c7 /= 2;
        }
        if (e9 + eBias >= eMax) {
          m6 = 0;
          e9 = eMax;
        } else if (e9 + eBias >= 1) {
          m6 = (value * c7 - 1) * Math.pow(2, mLen);
          e9 = e9 + eBias;
        } else {
          m6 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e9 = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i7] = m6 & 255, i7 += d7, m6 /= 256, mLen -= 8) {
      }
      e9 = e9 << mLen | m6;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i7] = e9 & 255, i7 += d7, e9 /= 256, eLen -= 8) {
      }
      buffer2[offset + i7 - d7] |= s7 * 128;
    };
    return exports$1$1;
  }
  function dew$g() {
    if (_dewExec$g)
      return exports$g;
    _dewExec$g = true;
    const base64 = dew$2$1();
    const ieee754 = dew$1$1();
    const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports$g.Buffer = Buffer3;
    exports$g.SlowBuffer = SlowBuffer;
    exports$g.INSPECT_MAX_BYTES = 50;
    const K_MAX_LENGTH = 2147483647;
    exports$g.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = {
          foo: function() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e9) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b6 = fromObject(value);
      if (b6)
        return b6;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i7 = 0; i7 < length; i7 += 1) {
        buf[i7] = array[i7] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer3(b6) {
      return b6 != null && b6._isBuffer === true && b6 !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a8, b6) {
      if (isInstance(a8, Uint8Array))
        a8 = Buffer3.from(a8, a8.offset, a8.byteLength);
      if (isInstance(b6, Uint8Array))
        b6 = Buffer3.from(b6, b6.offset, b6.byteLength);
      if (!Buffer3.isBuffer(a8) || !Buffer3.isBuffer(b6)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a8 === b6)
        return 0;
      let x4 = a8.length;
      let y6 = b6.length;
      for (let i7 = 0, len = Math.min(x4, y6); i7 < len; ++i7) {
        if (a8[i7] !== b6[i7]) {
          x4 = a8[i7];
          y6 = b6[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i7;
      if (length === void 0) {
        length = 0;
        for (i7 = 0; i7 < list.length; ++i7) {
          length += list[i7].length;
        }
      }
      const buffer2 = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i7 = 0; i7 < list.length; ++i7) {
        let buf = list[i7];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer2.length) {
            if (!Buffer3.isBuffer(buf))
              buf = Buffer3.from(buf);
            buf.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf, pos);
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer2, pos);
        }
        pos += buf.length;
      }
      return buffer2;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b6, n8, m6) {
      const i7 = b6[n8];
      b6[n8] = b6[m6];
      b6[m6] = i7;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 2) {
        swap(this, i7, i7 + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 4) {
        swap(this, i7, i7 + 3);
        swap(this, i7 + 1, i7 + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i7 = 0; i7 < len; i7 += 8) {
        swap(this, i7, i7 + 7);
        swap(this, i7 + 1, i7 + 6);
        swap(this, i7 + 2, i7 + 5);
        swap(this, i7 + 3, i7 + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b6) {
      if (!Buffer3.isBuffer(b6))
        throw new TypeError("Argument must be a Buffer");
      if (this === b6)
        return true;
      return Buffer3.compare(this, b6) === 0;
    };
    Buffer3.prototype.inspect = function inspect3() {
      let str = "";
      const max = exports$g.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x4 = thisEnd - thisStart;
      let y6 = end - start;
      const len = Math.min(x4, y6);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i7 = 0; i7 < len; ++i7) {
        if (thisCopy[i7] !== targetCopy[i7]) {
          x4 = thisCopy[i7];
          y6 = targetCopy[i7];
          break;
        }
      }
      if (x4 < y6)
        return -1;
      if (y6 < x4)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i8) {
        if (indexSize === 1) {
          return buf[i8];
        } else {
          return buf.readUInt16BE(i8 * indexSize);
        }
      }
      let i7;
      if (dir) {
        let foundIndex = -1;
        for (i7 = byteOffset; i7 < arrLength; i7++) {
          if (read2(arr, i7) === read2(val, foundIndex === -1 ? 0 : i7 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i7;
            if (i7 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i7 -= i7 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i7 = byteOffset; i7 >= 0; i7--) {
          let found = true;
          for (let j5 = 0; j5 < valLength; j5++) {
            if (read2(arr, i7 + j5) !== read2(val, j5)) {
              found = false;
              break;
            }
          }
          if (found)
            return i7;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        const parsed = parseInt(string.substr(i7 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i7;
        buf[offset + i7] = parsed;
      }
      return i7;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i7 = start;
      while (i7 < end) {
        const firstByte = buf[i7];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i7 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i7 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i7 + 1];
              thirdByte = buf[i7 + 2];
              fourthByte = buf[i7 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i7 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    const MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i7 = 0;
      while (i7 < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i7, i7 += MAX_ARGUMENTS_LENGTH));
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i7 = start; i7 < end; ++i7) {
        ret += String.fromCharCode(buf[i7]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i7 = start; i7 < end; ++i7) {
        out += hexSliceLookupTable[buf[i7]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i7 = 0; i7 < bytes.length - 1; i7 += 2) {
        res += String.fromCharCode(bytes[i7] + bytes[i7 + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i7 = 0;
      while (++i7 < byteLength2 && (mul *= 256)) {
        val += this[offset + i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i7 = byteLength2;
      let mul = 1;
      let val = this[offset + --i7];
      while (i7 > 0 && (mul *= 256)) {
        val += this[offset + --i7] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i7 = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        this[offset + i7] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i7 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i7 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i7] = value & 255;
      while (--i7 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i7 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i7] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i7;
      if (typeof val === "number") {
        for (i7 = start; i7 < end; ++i7) {
          this[i7] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i7 = 0; i7 < end - start; ++i7) {
          this[i7 + start] = bytes[i7 % len];
        }
      }
      return this;
    };
    const errors2 = {};
    function E5(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E5("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E5("ERR_INVALID_ARG_TYPE", function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E5("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i7 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i7 >= start + 4; i7 -= 3) {
        res = `_${val.slice(i7 - 3, i7)}${res}`;
      }
      return `${val.slice(0, i7)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n8 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n8} and < 2${n8} ** ${(byteLength2 + 1) * 8}${n8}`;
          } else {
            range = `>= -(2${n8} ** ${(byteLength2 + 1) * 8 - 1}${n8}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n8}`;
          }
        } else {
          range = `>= ${min}${n8} and <= ${max}${n8}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name2) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
    }
    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i7 = 0; i7 < length; ++i7) {
        codePoint = string.charCodeAt(i7);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i7 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        byteArray.push(str.charCodeAt(i7) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c7, hi, lo;
      const byteArray = [];
      for (let i7 = 0; i7 < str.length; ++i7) {
        if ((units -= 2) < 0)
          break;
        c7 = str.charCodeAt(i7);
        hi = c7 >> 8;
        lo = c7 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i7;
      for (i7 = 0; i7 < length; ++i7) {
        if (i7 + offset >= dst.length || i7 >= src.length)
          break;
        dst[i7 + offset] = src[i7];
      }
      return i7;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    const hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i7 = 0; i7 < 16; ++i7) {
        const i16 = i7 * 16;
        for (let j5 = 0; j5 < 16; ++j5) {
          table[i16 + j5] = alphabet[i7] + alphabet[j5];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    return exports$g;
  }
  function dew$f() {
    if (_dewExec$f)
      return exports$f;
    _dewExec$f = true;
    if (typeof Object.create === "function") {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      exports$f = function inherits3(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
    return exports$f;
  }
  function dew$e() {
    if (_dewExec$e)
      return exports$e;
    _dewExec$e = true;
    exports$e = y.EventEmitter;
    return exports$e;
  }
  function dew$d() {
    if (_dewExec$d)
      return exports$d;
    _dewExec$d = true;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i7 = 1; i7 < arguments.length; i7++) {
        var source2 = arguments[i7] != null ? arguments[i7] : {};
        if (i7 % 2) {
          ownKeys(Object(source2), true).forEach(function(key) {
            _defineProperty(target, key, source2[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
        } else {
          ownKeys(Object(source2)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i7 = 0; i7 < props.length; i7++) {
        var descriptor = props[i7];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = buffer, Buffer3 = _require.Buffer;
    var _require2 = X2, inspect3 = _require2.inspect;
    var custom = inspect3 && inspect3.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer3.prototype.copy.call(src, target, offset);
    }
    exports$d = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v7) {
          var entry = {
            data: v7,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v7) {
          var entry = {
            data: v7,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s7) {
          if (this.length === 0)
            return "";
          var p8 = this.head;
          var ret = "" + p8.data;
          while (p8 = p8.next) {
            ret += s7 + p8.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n8) {
          if (this.length === 0)
            return Buffer3.alloc(0);
          var ret = Buffer3.allocUnsafe(n8 >>> 0);
          var p8 = this.head;
          var i7 = 0;
          while (p8) {
            copyBuffer(p8.data, ret, i7);
            i7 += p8.data.length;
            p8 = p8.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n8, hasStrings) {
          var ret;
          if (n8 < this.head.data.length) {
            ret = this.head.data.slice(0, n8);
            this.head.data = this.head.data.slice(n8);
          } else if (n8 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n8) : this._getBuffer(n8);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n8) {
          var p8 = this.head;
          var c7 = 1;
          var ret = p8.data;
          n8 -= ret.length;
          while (p8 = p8.next) {
            var str = p8.data;
            var nb = n8 > str.length ? str.length : n8;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n8);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === str.length) {
                ++c7;
                if (p8.next)
                  this.head = p8.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p8;
                p8.data = str.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n8) {
          var ret = Buffer3.allocUnsafe(n8);
          var p8 = this.head;
          var c7 = 1;
          p8.data.copy(ret);
          n8 -= p8.data.length;
          while (p8 = p8.next) {
            var buf = p8.data;
            var nb = n8 > buf.length ? buf.length : n8;
            buf.copy(ret, ret.length - n8, 0, nb);
            n8 -= nb;
            if (n8 === 0) {
              if (nb === buf.length) {
                ++c7;
                if (p8.next)
                  this.head = p8.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p8;
                p8.data = buf.slice(nb);
              }
              break;
            }
            ++c7;
          }
          this.length -= c7;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value(_5, options) {
          return inspect3(this, _objectSpread({}, options, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
    return exports$d;
  }
  function dew$c() {
    if (_dewExec$c)
      return exports$c;
    _dewExec$c = true;
    var process$1 = process2;
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process$1.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process$1.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process$1.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process$1.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    exports$c = {
      destroy,
      undestroy,
      errorOrDestroy
    };
    return exports$c;
  }
  function dew$b() {
    if (_dewExec$b)
      return exports$b;
    _dewExec$b = true;
    const codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i7) => String(i7));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + value + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name2, " argument")) {
        msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name2, ".") ? "property" : "argument";
        msg = `The "${name2}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    exports$b.codes = codes;
    return exports$b;
  }
  function dew$a() {
    if (_dewExec$a)
      return exports$a;
    _dewExec$a = true;
    var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    exports$a = {
      getHighWaterMark
    };
    return exports$a;
  }
  function dew$9() {
    if (_dewExec$9)
      return exports$9;
    _dewExec$9 = true;
    exports$9 = deprecate3;
    function deprecate3(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this || _global$2, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!_global$2.localStorage)
          return false;
      } catch (_5) {
        return false;
      }
      var val = _global$2.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
    return exports$9;
  }
  function dew$8() {
    if (_dewExec$8)
      return exports$8;
    _dewExec$8 = true;
    var process$1 = process2;
    exports$8 = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex2;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: dew$9()
    };
    var Stream2 = dew$e();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global$1.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    dew$f()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er2) {
        onwrite(stream, er2);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_5) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex2 = Duplex2 || dew$7();
      var isDuplex = this instanceof Duplex2;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er2 = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er2);
      process$1.nextTick(cb, er2);
    }
    function validChunk(stream, state, chunk, cb) {
      var er2;
      if (chunk === null) {
        er2 = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er2) {
        errorOrDestroy(stream, er2);
        process$1.nextTick(cb, er2);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer3.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer3.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev2)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er2, cb) {
      --state.pendingcb;
      if (sync) {
        process$1.nextTick(cb, er2);
        process$1.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
      } else {
        cb(er2);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er2);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er2) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er2)
        onwriteError(stream, state, sync, er2, cb);
      else {
        var finished2 = needFinish(state) || stream.destroyed;
        if (!finished2 && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process$1.nextTick(afterWrite, stream, state, finished2, cb);
        } else {
          afterWrite(stream, state, finished2, cb);
        }
      }
    }
    function afterWrite(stream, state, finished2, cb) {
      if (!finished2)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l7 = state.bufferedRequestCount;
        var buffer2 = new Array(l7);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process$1.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process$1.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    return exports$8;
  }
  function dew$7() {
    if (_dewExec$7)
      return exports$7;
    _dewExec$7 = true;
    var process$1 = process2;
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    exports$7 = Duplex2;
    var Readable2 = dew$3();
    var Writable2 = dew$8();
    dew$f()(Duplex2, Readable2);
    {
      var keys = objectKeys(Writable2.prototype);
      for (var v7 = 0; v7 < keys.length; v7++) {
        var method = keys[v7];
        if (!Duplex2.prototype[method])
          Duplex2.prototype[method] = Writable2.prototype[method];
      }
    }
    function Duplex2(options) {
      if (!(this instanceof Duplex2))
        return new Duplex2(options);
      Readable2.call(this, options);
      Writable2.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process$1.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    return exports$7;
  }
  function dew$6() {
    if (_dewExec$6)
      return exports$6;
    _dewExec$6 = true;
    var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once3(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    exports$6 = eos;
    return exports$6;
  }
  function dew$5() {
    if (_dewExec$5)
      return exports$5;
    _dewExec$5 = true;
    var process$1 = process2;
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished2 = dew$6();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult2(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve3 = iter[kLastResolve];
      if (resolve3 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve3(createIterResult2(data, false));
        }
      }
    }
    function onReadable(iter) {
      process$1.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve3, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve3(createIterResult2(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve3, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult2(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve3, reject) {
            process$1.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve3(createIterResult2(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult2(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve3, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve3(createIterResult2(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve3, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve3(createIterResult2(data, false));
          } else {
            iterator[kLastResolve] = resolve3;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished2(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve3 = iterator[kLastResolve];
        if (resolve3 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult2(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    exports$5 = createReadableStreamAsyncIterator;
    return exports$5;
  }
  function dew$4() {
    if (_dewExec$4)
      return exports$4;
    _dewExec$4 = true;
    exports$4 = function() {
      throw new Error("Readable.from is not available in the browser");
    };
    return exports$4;
  }
  function dew$3() {
    if (_dewExec$3)
      return exports$32;
    _dewExec$3 = true;
    var process$1 = process2;
    exports$32 = Readable2;
    var Duplex2;
    Readable2.ReadableState = ReadableState;
    y.EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = dew$e();
    var Buffer3 = buffer.Buffer;
    var OurUint8Array = _global2.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer3.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = X2;
    var debug3;
    if (debugUtil && debugUtil.debuglog) {
      debug3 = debugUtil.debuglog("stream");
    } else {
      debug3 = function debug4() {
      };
    }
    var BufferList = dew$d();
    var destroyImpl = dew$c();
    var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    dew$f()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener2(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex2 = Duplex2 || dew$7();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex2;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = e$12.StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex2 = Duplex2 || dew$7();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex2;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer3.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug3("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er2;
        if (!skipChunkCheck)
          er2 = chunkInvalid(state, chunk);
        if (er2) {
          errorOrDestroy(stream, er2);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er2;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er2 = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er2;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = e$12.StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p8 = this._readableState.buffer.head;
      var content = "";
      while (p8 !== null) {
        content += decoder.write(p8.data);
        p8 = p8.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n8) {
      if (n8 >= MAX_HWM) {
        n8 = MAX_HWM;
      } else {
        n8--;
        n8 |= n8 >>> 1;
        n8 |= n8 >>> 2;
        n8 |= n8 >>> 4;
        n8 |= n8 >>> 8;
        n8 |= n8 >>> 16;
        n8++;
      }
      return n8;
    }
    function howMuchToRead(n8, state) {
      if (n8 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n8 !== n8) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n8 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n8);
      if (n8 <= state.length)
        return n8;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n8) {
      debug3("read", n8);
      n8 = parseInt(n8, 10);
      var state = this._readableState;
      var nOrig = n8;
      if (n8 !== 0)
        state.emittedReadable = false;
      if (n8 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug3("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n8 = howMuchToRead(n8, state);
      if (n8 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug3("need readable", doRead);
      if (state.length === 0 || state.length - n8 < state.highWaterMark) {
        doRead = true;
        debug3("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug3("reading or ended", doRead);
      } else if (doRead) {
        debug3("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n8 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n8 > 0)
        ret = fromList(n8, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n8 = 0;
      } else {
        state.length -= n8;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n8 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug3("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug3("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug3("emitReadable", state.flowing);
        state.emittedReadable = true;
        process$1.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug3("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process$1.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug3("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n8) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug3("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process$1.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug3("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug3("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug3("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug3("ondata");
        var ret = dest.write(chunk);
        debug3("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug3("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er2) {
        debug3("onerror", er2);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er2);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug3("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug3("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug3("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug3("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i7 = 0; i7 < len; i7++) {
          dests[i7].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug3("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process$1.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process$1.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug3("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug3("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process$1.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug3("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug3("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug3("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug3("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug3("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug3("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i7 in stream) {
        if (this[i7] === void 0 && typeof stream[i7] === "function") {
          this[i7] = /* @__PURE__ */ function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i7);
        }
      }
      for (var n8 = 0; n8 < kProxyEvents.length; n8++) {
        stream.on(kProxyEvents[n8], this.emit.bind(this, kProxyEvents[n8]));
      }
      this._read = function(n9) {
        debug3("wrapped _read", n9);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = dew$5();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n8, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n8 || n8 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n8, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug3("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process$1.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug3("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = dew$4();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x4) {
      for (var i7 = 0, l7 = xs.length; i7 < l7; i7++) {
        if (xs[i7] === x4)
          return i7;
      }
      return -1;
    }
    return exports$32;
  }
  function dew$22() {
    if (_dewExec$22)
      return exports$22;
    _dewExec$22 = true;
    exports$22 = Transform2;
    var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex2 = dew$7();
    dew$f()(Transform2, Duplex2);
    function afterTransform(er2, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er2);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex2.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er2, data) {
          done(_this, er2, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex2.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n8) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex2.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er2, data) {
      if (er2)
        return stream.emit("error", er2);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    return exports$22;
  }
  function dew$12() {
    if (_dewExec$12)
      return exports$12;
    _dewExec$12 = true;
    exports$12 = PassThrough2;
    var Transform2 = dew$22();
    dew$f()(PassThrough2, Transform2);
    function PassThrough2(options) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options);
      Transform2.call(this, options);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
    return exports$12;
  }
  function dew3() {
    if (_dewExec3)
      return exports3;
    _dewExec3 = true;
    var eos;
    function once3(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once3(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = dew$6();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline2() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i7) {
        var reading = i7 < streams.length - 1;
        var writing = i7 > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    exports3 = pipeline2;
    return exports3;
  }
  var exports$2$1, _dewExec$2$1, exports$1$1, _dewExec$1$1, exports$g, _dewExec$g, buffer, exports$f, _dewExec$f, exports$e, _dewExec$e, exports$d, _dewExec$d, exports$c, _dewExec$c, exports$b, _dewExec$b, exports$a, _dewExec$a, exports$9, _dewExec$9, _global$2, exports$8, _dewExec$8, _global$1, exports$7, _dewExec$7, exports$6, _dewExec$6, exports$5, _dewExec$5, exports$4, _dewExec$4, exports$32, _dewExec$3, _global2, exports$22, _dewExec$22, exports$12, _dewExec$12, exports3, _dewExec3;
  var init_chunk_44e51b61 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-44e51b61.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      exports$2$1 = {};
      _dewExec$2$1 = false;
      exports$1$1 = {};
      _dewExec$1$1 = false;
      exports$g = {};
      _dewExec$g = false;
      buffer = dew$g();
      buffer.Buffer;
      buffer.INSPECT_MAX_BYTES;
      buffer.kMaxLength;
      exports$f = {};
      _dewExec$f = false;
      exports$e = {};
      _dewExec$e = false;
      exports$d = {};
      _dewExec$d = false;
      exports$c = {};
      _dewExec$c = false;
      exports$b = {};
      _dewExec$b = false;
      exports$a = {};
      _dewExec$a = false;
      exports$9 = {};
      _dewExec$9 = false;
      _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$8 = {};
      _dewExec$8 = false;
      _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$7 = {};
      _dewExec$7 = false;
      exports$6 = {};
      _dewExec$6 = false;
      exports$5 = {};
      _dewExec$5 = false;
      exports$4 = {};
      _dewExec$4 = false;
      exports$32 = {};
      _dewExec$3 = false;
      _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$22 = {};
      _dewExec$22 = false;
      exports$12 = {};
      _dewExec$12 = false;
      exports3 = {};
      _dewExec3 = false;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/assert.js
  function e5(e9, r9) {
    if (null == e9)
      throw new TypeError("Cannot convert first argument to object");
    for (var t8 = Object(e9), n8 = 1; n8 < arguments.length; n8++) {
      var o8 = arguments[n8];
      if (null != o8)
        for (var a8 = Object.keys(Object(o8)), l7 = 0, i7 = a8.length; l7 < i7; l7++) {
          var c7 = a8[l7], b6 = Object.getOwnPropertyDescriptor(o8, c7);
          void 0 !== b6 && b6.enumerable && (t8[c7] = o8[c7]);
        }
    }
    return t8;
  }
  function i$5() {
    if (a$6)
      return c$4;
    function e9(t8) {
      return (e9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    function n8(t8, n9) {
      return !n9 || "object" !== e9(n9) && "function" != typeof n9 ? function(t9) {
        if (void 0 === t9)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t9;
      }(t8) : n9;
    }
    function r9(t8) {
      return (r9 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function o8(t8, e10) {
      return (o8 = Object.setPrototypeOf || function(t9, e11) {
        return t9.__proto__ = e11, t9;
      })(t8, e10);
    }
    a$6 = true;
    var i7, u7, l7 = {};
    function f7(t8, e10, c7) {
      c7 || (c7 = Error);
      var a8 = function(c8) {
        function a9(o9, c9, i8) {
          var u8;
          return !function(t9, e11) {
            if (!(t9 instanceof e11))
              throw new TypeError("Cannot call a class as a function");
          }(this, a9), (u8 = n8(this, r9(a9).call(this, function(t9, n9, r10) {
            return "string" == typeof e10 ? e10 : e10(t9, n9, r10);
          }(o9, c9, i8)))).code = t8, u8;
        }
        return !function(t9, e11) {
          if ("function" != typeof e11 && null !== e11)
            throw new TypeError("Super expression must either be null or a function");
          t9.prototype = Object.create(e11 && e11.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e11 && o8(t9, e11);
        }(a9, c8), a9;
      }(c7);
      l7[t8] = a8;
    }
    function s7(t8, e10) {
      if (Array.isArray(t8)) {
        var n9 = t8.length;
        return t8 = t8.map(function(t9) {
          return String(t9);
        }), n9 > 2 ? "one of ".concat(e10, " ").concat(t8.slice(0, n9 - 1).join(", "), ", or ") + t8[n9 - 1] : 2 === n9 ? "one of ".concat(e10, " ").concat(t8[0], " or ").concat(t8[1]) : "of ".concat(e10, " ").concat(t8[0]);
      }
      return "of ".concat(e10, " ").concat(String(t8));
    }
    return f7("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f7("ERR_INVALID_ARG_TYPE", function(t8, n9, r10) {
      var o9, c7, u8;
      if (void 0 === i7 && (i7 = tt2()), i7("string" == typeof t8, "'name' must be a string"), "string" == typeof n9 && (c7 = "not ", n9.substr(0, c7.length) === c7) ? (o9 = "must not be", n9 = n9.replace(/^not /, "")) : o9 = "must be", function(t9, e10, n10) {
        return (void 0 === n10 || n10 > t9.length) && (n10 = t9.length), t9.substring(n10 - e10.length, n10) === e10;
      }(t8, " argument"))
        u8 = "The ".concat(t8, " ").concat(o9, " ").concat(s7(n9, "type"));
      else {
        var l8 = function(t9, e10, n10) {
          return "number" != typeof n10 && (n10 = 0), !(n10 + e10.length > t9.length) && -1 !== t9.indexOf(e10, n10);
        }(t8, ".") ? "property" : "argument";
        u8 = 'The "'.concat(t8, '" ').concat(l8, " ").concat(o9, " ").concat(s7(n9, "type"));
      }
      return u8 += ". Received type ".concat(e9(r10));
    }, TypeError), f7("ERR_INVALID_ARG_VALUE", function(e10, n9) {
      var r10 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
      void 0 === u7 && (u7 = X2);
      var o9 = u7.inspect(n9);
      return o9.length > 128 && (o9 = "".concat(o9.slice(0, 128), "...")), "The argument '".concat(e10, "' ").concat(r10, ". Received ").concat(o9);
    }, TypeError), f7("ERR_INVALID_RETURN_VALUE", function(t8, n9, r10) {
      var o9;
      return o9 = r10 && r10.constructor && r10.constructor.name ? "instance of ".concat(r10.constructor.name) : "type ".concat(e9(r10)), "Expected ".concat(t8, ' to be returned from the "').concat(n9, '"') + " function but got ".concat(o9, ".");
    }, TypeError), f7("ERR_MISSING_ARGS", function() {
      for (var t8 = arguments.length, e10 = new Array(t8), n9 = 0; n9 < t8; n9++)
        e10[n9] = arguments[n9];
      void 0 === i7 && (i7 = tt2()), i7(e10.length > 0, "At least one arg needs to be specified");
      var r10 = "The ", o9 = e10.length;
      switch (e10 = e10.map(function(t9) {
        return '"'.concat(t9, '"');
      }), o9) {
        case 1:
          r10 += "".concat(e10[0], " argument");
          break;
        case 2:
          r10 += "".concat(e10[0], " and ").concat(e10[1], " arguments");
          break;
        default:
          r10 += e10.slice(0, o9 - 1).join(", "), r10 += ", and ".concat(e10[o9 - 1], " arguments");
      }
      return "".concat(r10, " must be specified");
    }, TypeError), c$4.codes = l7, c$4;
  }
  function f$6() {
    if (l$6)
      return u$5;
    l$6 = true;
    var n8 = T2;
    function r9(t8, e9, n9) {
      return e9 in t8 ? Object.defineProperty(t8, e9, { value: n9, enumerable: true, configurable: true, writable: true }) : t8[e9] = n9, t8;
    }
    function o8(t8, e9) {
      for (var n9 = 0; n9 < e9.length; n9++) {
        var r10 = e9[n9];
        r10.enumerable = r10.enumerable || false, r10.configurable = true, "value" in r10 && (r10.writable = true), Object.defineProperty(t8, r10.key, r10);
      }
    }
    function c7(t8, e9) {
      return !e9 || "object" !== y6(e9) && "function" != typeof e9 ? a8(t8) : e9;
    }
    function a8(t8) {
      if (void 0 === t8)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t8;
    }
    function f7(t8) {
      var e9 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return (f7 = function(t9) {
        if (null === t9 || (n9 = t9, -1 === Function.toString.call(n9).indexOf("[native code]")))
          return t9;
        var n9;
        if ("function" != typeof t9)
          throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== e9) {
          if (e9.has(t9))
            return e9.get(t9);
          e9.set(t9, r10);
        }
        function r10() {
          return p8(t9, arguments, h8(this).constructor);
        }
        return r10.prototype = Object.create(t9.prototype, { constructor: { value: r10, enumerable: false, writable: true, configurable: true } }), g5(r10, t9);
      })(t8);
    }
    function s7() {
      if ("undefined" == typeof Reflect || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if ("function" == typeof Proxy)
        return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        })), true;
      } catch (t8) {
        return false;
      }
    }
    function p8(t8, e9, n9) {
      return (p8 = s7() ? Reflect.construct : function(t9, e10, n10) {
        var r10 = [null];
        r10.push.apply(r10, e10);
        var o9 = new (Function.bind.apply(t9, r10))();
        return n10 && g5(o9, n10.prototype), o9;
      }).apply(null, arguments);
    }
    function g5(t8, e9) {
      return (g5 = Object.setPrototypeOf || function(t9, e10) {
        return t9.__proto__ = e10, t9;
      })(t8, e9);
    }
    function h8(t8) {
      return (h8 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t9) {
        return t9.__proto__ || Object.getPrototypeOf(t9);
      })(t8);
    }
    function y6(t8) {
      return (y6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var b6 = X2.inspect, v7 = i$5().codes.ERR_INVALID_ARG_TYPE;
    function d7(t8, e9, n9) {
      return (void 0 === n9 || n9 > t8.length) && (n9 = t8.length), t8.substring(n9 - e9.length, n9) === e9;
    }
    var m6 = "", E5 = "", w5 = "", S5 = "", j5 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
    function O5(t8) {
      var e9 = Object.keys(t8), n9 = Object.create(Object.getPrototypeOf(t8));
      return e9.forEach(function(e10) {
        n9[e10] = t8[e10];
      }), Object.defineProperty(n9, "message", { value: t8.message }), n9;
    }
    function x4(t8) {
      return b6(t8, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function q4(t8, e9, r10) {
      var o9 = "", c8 = "", a9 = 0, i7 = "", u7 = false, l7 = x4(t8), f8 = l7.split("\n"), s8 = x4(e9).split("\n"), p9 = 0, g6 = "";
      if ("strictEqual" === r10 && "object" === y6(t8) && "object" === y6(e9) && null !== t8 && null !== e9 && (r10 = "strictEqualObject"), 1 === f8.length && 1 === s8.length && f8[0] !== s8[0]) {
        var h9 = f8[0].length + s8[0].length;
        if (h9 <= 10) {
          if (!("object" === y6(t8) && null !== t8 || "object" === y6(e9) && null !== e9 || 0 === t8 && 0 === e9))
            return "".concat(j5[r10], "\n\n") + "".concat(f8[0], " !== ").concat(s8[0], "\n");
        } else if ("strictEqualObject" !== r10) {
          if (h9 < (n8.stderr && n8.stderr.isTTY ? n8.stderr.columns : 80)) {
            for (; f8[0][p9] === s8[0][p9]; )
              p9++;
            p9 > 2 && (g6 = "\n  ".concat(function(t9, e10) {
              if (e10 = Math.floor(e10), 0 == t9.length || 0 == e10)
                return "";
              var n9 = t9.length * e10;
              for (e10 = Math.floor(Math.log(e10) / Math.log(2)); e10; )
                t9 += t9, e10--;
              return t9 += t9.substring(0, n9 - t9.length);
            }(" ", p9), "^"), p9 = 0);
          }
        }
      }
      for (var b7 = f8[f8.length - 1], v8 = s8[s8.length - 1]; b7 === v8 && (p9++ < 2 ? i7 = "\n  ".concat(b7).concat(i7) : o9 = b7, f8.pop(), s8.pop(), 0 !== f8.length && 0 !== s8.length); )
        b7 = f8[f8.length - 1], v8 = s8[s8.length - 1];
      var O6 = Math.max(f8.length, s8.length);
      if (0 === O6) {
        var q5 = l7.split("\n");
        if (q5.length > 30)
          for (q5[26] = "".concat(m6, "...").concat(S5); q5.length > 27; )
            q5.pop();
        return "".concat(j5.notIdentical, "\n\n").concat(q5.join("\n"), "\n");
      }
      p9 > 3 && (i7 = "\n".concat(m6, "...").concat(S5).concat(i7), u7 = true), "" !== o9 && (i7 = "\n  ".concat(o9).concat(i7), o9 = "");
      var R6 = 0, A5 = j5[r10] + "\n".concat(E5, "+ actual").concat(S5, " ").concat(w5, "- expected").concat(S5), k5 = " ".concat(m6, "...").concat(S5, " Lines skipped");
      for (p9 = 0; p9 < O6; p9++) {
        var _5 = p9 - a9;
        if (f8.length < p9 + 1)
          _5 > 1 && p9 > 2 && (_5 > 4 ? (c8 += "\n".concat(m6, "...").concat(S5), u7 = true) : _5 > 3 && (c8 += "\n  ".concat(s8[p9 - 2]), R6++), c8 += "\n  ".concat(s8[p9 - 1]), R6++), a9 = p9, o9 += "\n".concat(w5, "-").concat(S5, " ").concat(s8[p9]), R6++;
        else if (s8.length < p9 + 1)
          _5 > 1 && p9 > 2 && (_5 > 4 ? (c8 += "\n".concat(m6, "...").concat(S5), u7 = true) : _5 > 3 && (c8 += "\n  ".concat(f8[p9 - 2]), R6++), c8 += "\n  ".concat(f8[p9 - 1]), R6++), a9 = p9, c8 += "\n".concat(E5, "+").concat(S5, " ").concat(f8[p9]), R6++;
        else {
          var T6 = s8[p9], P5 = f8[p9], I5 = P5 !== T6 && (!d7(P5, ",") || P5.slice(0, -1) !== T6);
          I5 && d7(T6, ",") && T6.slice(0, -1) === P5 && (I5 = false, P5 += ","), I5 ? (_5 > 1 && p9 > 2 && (_5 > 4 ? (c8 += "\n".concat(m6, "...").concat(S5), u7 = true) : _5 > 3 && (c8 += "\n  ".concat(f8[p9 - 2]), R6++), c8 += "\n  ".concat(f8[p9 - 1]), R6++), a9 = p9, c8 += "\n".concat(E5, "+").concat(S5, " ").concat(P5), o9 += "\n".concat(w5, "-").concat(S5, " ").concat(T6), R6 += 2) : (c8 += o9, o9 = "", 1 !== _5 && 0 !== p9 || (c8 += "\n  ".concat(P5), R6++));
        }
        if (R6 > 20 && p9 < O6 - 2)
          return "".concat(A5).concat(k5, "\n").concat(c8, "\n").concat(m6, "...").concat(S5).concat(o9, "\n") + "".concat(m6, "...").concat(S5);
      }
      return "".concat(A5).concat(u7 ? k5 : "", "\n").concat(c8).concat(o9).concat(i7).concat(g6);
    }
    var R5 = function(t8) {
      function e9(t9) {
        var r10;
        if (!function(t10, e10) {
          if (!(t10 instanceof e10))
            throw new TypeError("Cannot call a class as a function");
        }(this, e9), "object" !== y6(t9) || null === t9)
          throw new v7("options", "Object", t9);
        var o9 = t9.message, i8 = t9.operator, u8 = t9.stackStartFn, l7 = t9.actual, f8 = t9.expected, s8 = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, null != o9)
          r10 = c7(this, h8(e9).call(this, String(o9)));
        else if (n8.stderr && n8.stderr.isTTY && (n8.stderr && n8.stderr.getColorDepth && 1 !== n8.stderr.getColorDepth() ? (m6 = "\x1B[34m", E5 = "\x1B[32m", S5 = "\x1B[39m", w5 = "\x1B[31m") : (m6 = "", E5 = "", S5 = "", w5 = "")), "object" === y6(l7) && null !== l7 && "object" === y6(f8) && null !== f8 && "stack" in l7 && l7 instanceof Error && "stack" in f8 && f8 instanceof Error && (l7 = O5(l7), f8 = O5(f8)), "deepStrictEqual" === i8 || "strictEqual" === i8)
          r10 = c7(this, h8(e9).call(this, q4(l7, f8, i8)));
        else if ("notDeepStrictEqual" === i8 || "notStrictEqual" === i8) {
          var p9 = j5[i8], g6 = x4(l7).split("\n");
          if ("notStrictEqual" === i8 && "object" === y6(l7) && null !== l7 && (p9 = j5.notStrictEqualObject), g6.length > 30)
            for (g6[26] = "".concat(m6, "...").concat(S5); g6.length > 27; )
              g6.pop();
          r10 = 1 === g6.length ? c7(this, h8(e9).call(this, "".concat(p9, " ").concat(g6[0]))) : c7(this, h8(e9).call(this, "".concat(p9, "\n\n").concat(g6.join("\n"), "\n")));
        } else {
          var b7 = x4(l7), d8 = "", R6 = j5[i8];
          "notDeepEqual" === i8 || "notEqual" === i8 ? (b7 = "".concat(j5[i8], "\n\n").concat(b7)).length > 1024 && (b7 = "".concat(b7.slice(0, 1021), "...")) : (d8 = "".concat(x4(f8)), b7.length > 512 && (b7 = "".concat(b7.slice(0, 509), "...")), d8.length > 512 && (d8 = "".concat(d8.slice(0, 509), "...")), "deepEqual" === i8 || "equal" === i8 ? b7 = "".concat(R6, "\n\n").concat(b7, "\n\nshould equal\n\n") : d8 = " ".concat(i8, " ").concat(d8)), r10 = c7(this, h8(e9).call(this, "".concat(b7).concat(d8)));
        }
        return Error.stackTraceLimit = s8, r10.generatedMessage = !o9, Object.defineProperty(a8(r10), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r10.code = "ERR_ASSERTION", r10.actual = l7, r10.expected = f8, r10.operator = i8, Error.captureStackTrace && Error.captureStackTrace(a8(r10), u8), r10.stack, r10.name = "AssertionError", c7(r10);
      }
      var i7, u7;
      return !function(t9, e10) {
        if ("function" != typeof e10 && null !== e10)
          throw new TypeError("Super expression must either be null or a function");
        t9.prototype = Object.create(e10 && e10.prototype, { constructor: { value: t9, writable: true, configurable: true } }), e10 && g5(t9, e10);
      }(e9, t8), i7 = e9, (u7 = [{ key: "toString", value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: b6.custom, value: function(t9, e10) {
        return b6(this, function(t10) {
          for (var e11 = 1; e11 < arguments.length; e11++) {
            var n9 = null != arguments[e11] ? arguments[e11] : {}, o9 = Object.keys(n9);
            "function" == typeof Object.getOwnPropertySymbols && (o9 = o9.concat(Object.getOwnPropertySymbols(n9).filter(function(t11) {
              return Object.getOwnPropertyDescriptor(n9, t11).enumerable;
            }))), o9.forEach(function(e12) {
              r9(t10, e12, n9[e12]);
            });
          }
          return t10;
        }({}, e10, { customInspect: false, depth: 0 }));
      } }]) && o8(i7.prototype, u7), e9;
    }(f7(Error));
    return u$5 = R5;
  }
  function s$3(t8, e9) {
    return function(t9) {
      if (Array.isArray(t9))
        return t9;
    }(t8) || function(t9, e10) {
      var n8 = [], r9 = true, o8 = false, c7 = void 0;
      try {
        for (var a8, i7 = t9[Symbol.iterator](); !(r9 = (a8 = i7.next()).done) && (n8.push(a8.value), !e10 || n8.length !== e10); r9 = true)
          ;
      } catch (t10) {
        o8 = true, c7 = t10;
      } finally {
        try {
          r9 || null == i7.return || i7.return();
        } finally {
          if (o8)
            throw c7;
        }
      }
      return n8;
    }(t8, e9) || function() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }();
  }
  function p$3(t8) {
    return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
      return typeof t9;
    } : function(t9) {
      return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
    })(t8);
  }
  function m$2(t8) {
    return t8.call.bind(t8);
  }
  function U4(t8) {
    if (0 === t8.length || t8.length > 10)
      return true;
    for (var e9 = 0; e9 < t8.length; e9++) {
      var n8 = t8.charCodeAt(e9);
      if (n8 < 48 || n8 > 57)
        return true;
    }
    return 10 === t8.length && t8 >= Math.pow(2, 32);
  }
  function G3(t8) {
    return Object.keys(t8).filter(U4).concat(v$1(t8).filter(Object.prototype.propertyIsEnumerable.bind(t8)));
  }
  function V3(t8, e9) {
    if (t8 === e9)
      return 0;
    for (var n8 = t8.length, r9 = e9.length, o8 = 0, c7 = Math.min(n8, r9); o8 < c7; ++o8)
      if (t8[o8] !== e9[o8]) {
        n8 = t8[o8], r9 = e9[o8];
        break;
      }
    return n8 < r9 ? -1 : r9 < n8 ? 1 : 0;
  }
  function B4(t8, e9, n8, r9) {
    if (t8 === e9)
      return 0 !== t8 || (!n8 || b$1(t8, e9));
    if (n8) {
      if ("object" !== p$3(t8))
        return "number" == typeof t8 && d$1(t8) && d$1(e9);
      if ("object" !== p$3(e9) || null === t8 || null === e9)
        return false;
      if (Object.getPrototypeOf(t8) !== Object.getPrototypeOf(e9))
        return false;
    } else {
      if (null === t8 || "object" !== p$3(t8))
        return (null === e9 || "object" !== p$3(e9)) && t8 == e9;
      if (null === e9 || "object" !== p$3(e9))
        return false;
    }
    var o8, c7, a8, i7, u7 = S4(t8);
    if (u7 !== S4(e9))
      return false;
    if (Array.isArray(t8)) {
      if (t8.length !== e9.length)
        return false;
      var l7 = G3(t8), f7 = G3(e9);
      return l7.length === f7.length && C4(t8, e9, n8, r9, 1, l7);
    }
    if ("[object Object]" === u7 && (!R4(t8) && R4(e9) || !k4(t8) && k4(e9)))
      return false;
    if (q3(t8)) {
      if (!q3(e9) || Date.prototype.getTime.call(t8) !== Date.prototype.getTime.call(e9))
        return false;
    } else if (A$1(t8)) {
      if (!A$1(e9) || (a8 = t8, i7 = e9, !(g$1 ? a8.source === i7.source && a8.flags === i7.flags : RegExp.prototype.toString.call(a8) === RegExp.prototype.toString.call(i7))))
        return false;
    } else if (_4(t8) || t8 instanceof Error) {
      if (t8.message !== e9.message || t8.name !== e9.name)
        return false;
    } else {
      if (x3(t8)) {
        if (n8 || !L4(t8) && !M3(t8)) {
          if (!function(t9, e10) {
            return t9.byteLength === e10.byteLength && 0 === V3(new Uint8Array(t9.buffer, t9.byteOffset, t9.byteLength), new Uint8Array(e10.buffer, e10.byteOffset, e10.byteLength));
          }(t8, e9))
            return false;
        } else if (!function(t9, e10) {
          if (t9.byteLength !== e10.byteLength)
            return false;
          for (var n9 = 0; n9 < t9.byteLength; n9++)
            if (t9[n9] !== e10[n9])
              return false;
          return true;
        }(t8, e9))
          return false;
        var s7 = G3(t8), h8 = G3(e9);
        return s7.length === h8.length && C4(t8, e9, n8, r9, 0, s7);
      }
      if (k4(t8))
        return !(!k4(e9) || t8.size !== e9.size) && C4(t8, e9, n8, r9, 2);
      if (R4(t8))
        return !(!R4(e9) || t8.size !== e9.size) && C4(t8, e9, n8, r9, 3);
      if (O3(t8)) {
        if (c7 = e9, (o8 = t8).byteLength !== c7.byteLength || 0 !== V3(new Uint8Array(o8), new Uint8Array(c7)))
          return false;
      } else if (T5(t8) && !function(t9, e10) {
        return P$1(t9) ? P$1(e10) && b$1(Number.prototype.valueOf.call(t9), Number.prototype.valueOf.call(e10)) : I4(t9) ? I4(e10) && String.prototype.valueOf.call(t9) === String.prototype.valueOf.call(e10) : D4(t9) ? D4(e10) && Boolean.prototype.valueOf.call(t9) === Boolean.prototype.valueOf.call(e10) : F4(t9) ? F4(e10) && BigInt.prototype.valueOf.call(t9) === BigInt.prototype.valueOf.call(e10) : N$1(e10) && Symbol.prototype.valueOf.call(t9) === Symbol.prototype.valueOf.call(e10);
      }(t8, e9))
        return false;
    }
    return C4(t8, e9, n8, r9, 0);
  }
  function z4(t8, e9) {
    return e9.filter(function(e10) {
      return w$1(t8, e10);
    });
  }
  function C4(t8, e9, n8, r9, o8, c7) {
    if (5 === arguments.length) {
      c7 = Object.keys(t8);
      var a8 = Object.keys(e9);
      if (c7.length !== a8.length)
        return false;
    }
    for (var i7 = 0; i7 < c7.length; i7++)
      if (!E4(e9, c7[i7]))
        return false;
    if (n8 && 5 === arguments.length) {
      var u7 = v$1(t8);
      if (0 !== u7.length) {
        var l7 = 0;
        for (i7 = 0; i7 < u7.length; i7++) {
          var f7 = u7[i7];
          if (w$1(t8, f7)) {
            if (!w$1(e9, f7))
              return false;
            c7.push(f7), l7++;
          } else if (w$1(e9, f7))
            return false;
        }
        var s7 = v$1(e9);
        if (u7.length !== s7.length && z4(e9, s7).length !== l7)
          return false;
      } else {
        var p8 = v$1(e9);
        if (0 !== p8.length && 0 !== z4(e9, p8).length)
          return false;
      }
    }
    if (0 === c7.length && (0 === o8 || 1 === o8 && 0 === t8.length || 0 === t8.size))
      return true;
    if (void 0 === r9)
      r9 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
    else {
      var g5 = r9.val1.get(t8);
      if (void 0 !== g5) {
        var h8 = r9.val2.get(e9);
        if (void 0 !== h8)
          return g5 === h8;
      }
      r9.position++;
    }
    r9.val1.set(t8, r9.position), r9.val2.set(e9, r9.position);
    var y6 = Q3(t8, e9, n8, c7, r9, o8);
    return r9.val1.delete(t8), r9.val2.delete(e9), y6;
  }
  function Y4(t8, e9, n8, r9) {
    for (var o8 = h$1(t8), c7 = 0; c7 < o8.length; c7++) {
      var a8 = o8[c7];
      if (B4(e9, a8, n8, r9))
        return t8.delete(a8), true;
    }
    return false;
  }
  function W3(t8) {
    switch (p$3(t8)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return false;
      case "string":
        t8 = +t8;
      case "number":
        if (d$1(t8))
          return false;
    }
    return true;
  }
  function H3(t8, e9, n8) {
    var r9 = W3(n8);
    return null != r9 ? r9 : e9.has(r9) && !t8.has(r9);
  }
  function J3(t8, e9, n8, r9, o8) {
    var c7 = W3(n8);
    if (null != c7)
      return c7;
    var a8 = e9.get(c7);
    return !(void 0 === a8 && !e9.has(c7) || !B4(r9, a8, false, o8)) && (!t8.has(c7) && B4(r9, a8, false, o8));
  }
  function K3(t8, e9, n8, r9, o8, c7) {
    for (var a8 = h$1(t8), i7 = 0; i7 < a8.length; i7++) {
      var u7 = a8[i7];
      if (B4(n8, u7, o8, c7) && B4(r9, e9.get(u7), o8, c7))
        return t8.delete(u7), true;
    }
    return false;
  }
  function Q3(t8, e9, n8, r9, o8, c7) {
    var a8 = 0;
    if (2 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = h$1(t9), a9 = 0; a9 < c8.length; a9++) {
          var i8 = c8[a9];
          if ("object" === p$3(i8) && null !== i8)
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          else if (!e10.has(i8)) {
            if (n9)
              return false;
            if (!H3(t9, e10, i8))
              return false;
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(i8);
          }
        }
        if (null !== o9) {
          for (var u8 = h$1(e10), l8 = 0; l8 < u8.length; l8++) {
            var f7 = u8[l8];
            if ("object" === p$3(f7) && null !== f7) {
              if (!Y4(o9, f7, n9, r10))
                return false;
            } else if (!n9 && !t9.has(f7) && !Y4(o9, f7, n9, r10))
              return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8))
        return false;
    } else if (3 === c7) {
      if (!function(t9, e10, n9, r10) {
        for (var o9 = null, c8 = y$2(t9), a9 = 0; a9 < c8.length; a9++) {
          var i8 = s$3(c8[a9], 2), u8 = i8[0], l8 = i8[1];
          if ("object" === p$3(u8) && null !== u8)
            null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
          else {
            var f7 = e10.get(u8);
            if (void 0 === f7 && !e10.has(u8) || !B4(l8, f7, n9, r10)) {
              if (n9)
                return false;
              if (!J3(t9, e10, u8, l8, r10))
                return false;
              null === o9 && (o9 = /* @__PURE__ */ new Set()), o9.add(u8);
            }
          }
        }
        if (null !== o9) {
          for (var g5 = y$2(e10), h8 = 0; h8 < g5.length; h8++) {
            var b6 = s$3(g5[h8], 2), v7 = (u8 = b6[0], b6[1]);
            if ("object" === p$3(u8) && null !== u8) {
              if (!K3(o9, t9, u8, v7, n9, r10))
                return false;
            } else if (!(n9 || t9.has(u8) && B4(t9.get(u8), v7, false, r10) || K3(o9, t9, u8, v7, false, r10)))
              return false;
          }
          return 0 === o9.size;
        }
        return true;
      }(t8, e9, n8, o8))
        return false;
    } else if (1 === c7)
      for (; a8 < t8.length; a8++) {
        if (!E4(t8, a8)) {
          if (E4(e9, a8))
            return false;
          for (var i7 = Object.keys(t8); a8 < i7.length; a8++) {
            var u7 = i7[a8];
            if (!E4(e9, u7) || !B4(t8[u7], e9[u7], n8, o8))
              return false;
          }
          return i7.length === Object.keys(e9).length;
        }
        if (!E4(e9, a8) || !B4(t8[a8], e9[a8], n8, o8))
          return false;
      }
    for (a8 = 0; a8 < r9.length; a8++) {
      var l7 = r9[a8];
      if (!B4(t8[l7], e9[l7], n8, o8))
        return false;
    }
    return true;
  }
  function tt2() {
    if ($$1)
      return Z2;
    $$1 = true;
    var o8 = T2;
    function c7(t8) {
      return (c7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t9) {
        return typeof t9;
      } : function(t9) {
        return t9 && "function" == typeof Symbol && t9.constructor === Symbol && t9 !== Symbol.prototype ? "symbol" : typeof t9;
      })(t8);
    }
    var a8, u7, l7 = i$5().codes, s7 = l7.ERR_AMBIGUOUS_ARGUMENT, p8 = l7.ERR_INVALID_ARG_TYPE, g5 = l7.ERR_INVALID_ARG_VALUE, h8 = l7.ERR_INVALID_RETURN_VALUE, y6 = l7.ERR_MISSING_ARGS, b6 = f$6(), v7 = X2.inspect, d7 = X2.types, m$12 = d7.isPromise, E5 = d7.isRegExp, w5 = Object.assign ? Object.assign : r5.assign, S5 = Object.is ? Object.is : m4;
    function j5() {
      a8 = X3.isDeepEqual, u7 = X3.isDeepStrictEqual;
    }
    var O5 = false, x4 = Z2 = k5, q4 = {};
    function R5(t8) {
      if (t8.message instanceof Error)
        throw t8.message;
      throw new b6(t8);
    }
    function A5(t8, e9, n8, r9) {
      if (!n8) {
        var o9 = false;
        if (0 === e9)
          o9 = true, r9 = "No value argument passed to `assert.ok()`";
        else if (r9 instanceof Error)
          throw r9;
        var c8 = new b6({ actual: n8, expected: true, message: r9, operator: "==", stackStartFn: t8 });
        throw c8.generatedMessage = o9, c8;
      }
    }
    function k5() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
        e9[n8] = arguments[n8];
      A5.apply(void 0, [k5, e9.length].concat(e9));
    }
    x4.fail = function t8(e9, n8, r9, c8, a9) {
      var i7, u8 = arguments.length;
      if (0 === u8)
        i7 = "Failed";
      else if (1 === u8)
        r9 = e9, e9 = void 0;
      else {
        if (false === O5) {
          O5 = true;
          var l8 = o8.emitWarning ? o8.emitWarning : console.warn.bind(console);
          l8("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        2 === u8 && (c8 = "!=");
      }
      if (r9 instanceof Error)
        throw r9;
      var f7 = { actual: e9, expected: n8, operator: void 0 === c8 ? "fail" : c8, stackStartFn: a9 || t8 };
      void 0 !== r9 && (f7.message = r9);
      var s8 = new b6(f7);
      throw i7 && (s8.message = i7, s8.generatedMessage = true), s8;
    }, x4.AssertionError = b6, x4.ok = k5, x4.equal = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      e9 != n8 && R5({ actual: e9, expected: n8, message: r9, operator: "==", stackStartFn: t8 });
    }, x4.notEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      e9 == n8 && R5({ actual: e9, expected: n8, message: r9, operator: "!=", stackStartFn: t8 });
    }, x4.deepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a8 && j5(), a8(e9, n8) || R5({ actual: e9, expected: n8, message: r9, operator: "deepEqual", stackStartFn: t8 });
    }, x4.notDeepEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a8 && j5(), a8(e9, n8) && R5({ actual: e9, expected: n8, message: r9, operator: "notDeepEqual", stackStartFn: t8 });
    }, x4.deepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a8 && j5(), u7(e9, n8) || R5({ actual: e9, expected: n8, message: r9, operator: "deepStrictEqual", stackStartFn: t8 });
    }, x4.notDeepStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      void 0 === a8 && j5();
      u7(e9, n8) && R5({ actual: e9, expected: n8, message: r9, operator: "notDeepStrictEqual", stackStartFn: t8 });
    }, x4.strictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      S5(e9, n8) || R5({ actual: e9, expected: n8, message: r9, operator: "strictEqual", stackStartFn: t8 });
    }, x4.notStrictEqual = function t8(e9, n8, r9) {
      if (arguments.length < 2)
        throw new y6("actual", "expected");
      S5(e9, n8) && R5({ actual: e9, expected: n8, message: r9, operator: "notStrictEqual", stackStartFn: t8 });
    };
    var _5 = function t8(e9, n8, r9) {
      var o9 = this;
      !function(t9, e10) {
        if (!(t9 instanceof e10))
          throw new TypeError("Cannot call a class as a function");
      }(this, t8), n8.forEach(function(t9) {
        t9 in e9 && (void 0 !== r9 && "string" == typeof r9[t9] && E5(e9[t9]) && e9[t9].test(r9[t9]) ? o9[t9] = r9[t9] : o9[t9] = e9[t9]);
      });
    };
    function T6(t8, e9, n8, r9, o9, c8) {
      if (!(n8 in t8) || !u7(t8[n8], e9[n8])) {
        if (!r9) {
          var a9 = new _5(t8, o9), i7 = new _5(e9, o9, t8), l8 = new b6({ actual: a9, expected: i7, operator: "deepStrictEqual", stackStartFn: c8 });
          throw l8.actual = t8, l8.expected = e9, l8.operator = c8.name, l8;
        }
        R5({ actual: t8, expected: e9, message: r9, operator: c8.name, stackStartFn: c8 });
      }
    }
    function P5(t8, e9, n8, r9) {
      if ("function" != typeof e9) {
        if (E5(e9))
          return e9.test(t8);
        if (2 === arguments.length)
          throw new p8("expected", ["Function", "RegExp"], e9);
        if ("object" !== c7(t8) || null === t8) {
          var o9 = new b6({ actual: t8, expected: e9, message: n8, operator: "deepStrictEqual", stackStartFn: r9 });
          throw o9.operator = r9.name, o9;
        }
        var i7 = Object.keys(e9);
        if (e9 instanceof Error)
          i7.push("name", "message");
        else if (0 === i7.length)
          throw new g5("error", e9, "may not be an empty object");
        return void 0 === a8 && j5(), i7.forEach(function(o10) {
          "string" == typeof t8[o10] && E5(e9[o10]) && e9[o10].test(t8[o10]) || T6(t8, e9, o10, n8, i7, r9);
        }), true;
      }
      return void 0 !== e9.prototype && t8 instanceof e9 || !Error.isPrototypeOf(e9) && true === e9.call({}, t8);
    }
    function I5(t8) {
      if ("function" != typeof t8)
        throw new p8("fn", "Function", t8);
      try {
        t8();
      } catch (t9) {
        return t9;
      }
      return q4;
    }
    function D5(t8) {
      return m$12(t8) || null !== t8 && "object" === c7(t8) && "function" == typeof t8.then && "function" == typeof t8.catch;
    }
    function F5(t8) {
      return Promise.resolve().then(function() {
        var e9;
        if ("function" == typeof t8) {
          if (!D5(e9 = t8()))
            throw new h8("instance of Promise", "promiseFn", e9);
        } else {
          if (!D5(t8))
            throw new p8("promiseFn", ["Function", "Promise"], t8);
          e9 = t8;
        }
        return Promise.resolve().then(function() {
          return e9;
        }).then(function() {
          return q4;
        }).catch(function(t9) {
          return t9;
        });
      });
    }
    function N5(t8, e9, n8, r9) {
      if ("string" == typeof n8) {
        if (4 === arguments.length)
          throw new p8("error", ["Object", "Error", "Function", "RegExp"], n8);
        if ("object" === c7(e9) && null !== e9) {
          if (e9.message === n8)
            throw new s7("error/message", 'The error message "'.concat(e9.message, '" is identical to the message.'));
        } else if (e9 === n8)
          throw new s7("error/message", 'The error "'.concat(e9, '" is identical to the message.'));
        r9 = n8, n8 = void 0;
      } else if (null != n8 && "object" !== c7(n8) && "function" != typeof n8)
        throw new p8("error", ["Object", "Error", "Function", "RegExp"], n8);
      if (e9 === q4) {
        var o9 = "";
        n8 && n8.name && (o9 += " (".concat(n8.name, ")")), o9 += r9 ? ": ".concat(r9) : ".";
        var a9 = "rejects" === t8.name ? "rejection" : "exception";
        R5({ actual: void 0, expected: n8, operator: t8.name, message: "Missing expected ".concat(a9).concat(o9), stackStartFn: t8 });
      }
      if (n8 && !P5(e9, n8, r9, t8))
        throw e9;
    }
    function L5(t8, e9, n8, r9) {
      if (e9 !== q4) {
        if ("string" == typeof n8 && (r9 = n8, n8 = void 0), !n8 || P5(e9, n8)) {
          var o9 = r9 ? ": ".concat(r9) : ".", c8 = "doesNotReject" === t8.name ? "rejection" : "exception";
          R5({ actual: e9, expected: n8, operator: t8.name, message: "Got unwanted ".concat(c8).concat(o9, "\n") + 'Actual message: "'.concat(e9 && e9.message, '"'), stackStartFn: t8 });
        }
        throw e9;
      }
    }
    function M4() {
      for (var t8 = arguments.length, e9 = new Array(t8), n8 = 0; n8 < t8; n8++)
        e9[n8] = arguments[n8];
      A5.apply(void 0, [M4, e9.length].concat(e9));
    }
    return x4.throws = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      N5.apply(void 0, [t8, I5(e9)].concat(r9));
    }, x4.rejects = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      return F5(e9).then(function(e10) {
        return N5.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.doesNotThrow = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      L5.apply(void 0, [t8, I5(e9)].concat(r9));
    }, x4.doesNotReject = function t8(e9) {
      for (var n8 = arguments.length, r9 = new Array(n8 > 1 ? n8 - 1 : 0), o9 = 1; o9 < n8; o9++)
        r9[o9 - 1] = arguments[o9];
      return F5(e9).then(function(e10) {
        return L5.apply(void 0, [t8, e10].concat(r9));
      });
    }, x4.ifError = function t8(e9) {
      if (null != e9) {
        var n8 = "ifError got unwanted exception: ";
        "object" === c7(e9) && "string" == typeof e9.message ? 0 === e9.message.length && e9.constructor ? n8 += e9.constructor.name : n8 += e9.message : n8 += v7(e9);
        var r9 = new b6({ actual: e9, expected: null, operator: "ifError", message: n8, stackStartFn: t8 }), o9 = e9.stack;
        if ("string" == typeof o9) {
          var a9 = o9.split("\n");
          a9.shift();
          for (var i7 = r9.stack.split("\n"), u8 = 0; u8 < a9.length; u8++) {
            var l8 = i7.indexOf(a9[u8]);
            if (-1 !== l8) {
              i7 = i7.slice(0, l8);
              break;
            }
          }
          r9.stack = "".concat(i7.join("\n"), "\n").concat(a9.join("\n"));
        }
        throw r9;
      }
    }, x4.strict = w5(M4, x4, { equal: x4.strictEqual, deepEqual: x4.deepStrictEqual, notEqual: x4.notStrictEqual, notDeepEqual: x4.notDeepStrictEqual }), x4.strict.strict = x4.strict, Z2;
  }
  var r5, t5, e$13, r$12, n8, o8, c7, l7, i7, a8, u7, f7, p8, s7, y4, b4, g3, h5, $3, j4, w4, r$2, e$2, o$13, n$13, a$1, c$13, l$13, u$13, f$12, t$12, f$22, e$3, l$2, t$22, n$2, o$22, r$3, e$4, o$3, t$3, n$3, y$1, a$22, i$13, d5, f$3, u$22, A4, l$3, v5, P4, c$2, t$4, p$1, o$4, i$2, a$3, l$4, r$4, n$4, i$3, o$5, c$3, f$4, u$3, s$12, a$4, l$5, p$2, m4, N4, e$5, i$4, n$5, t$5, u$4, a$5, m$1, o$6, s$2, f$5, c$4, a$6, u$5, l$6, g$1, h$1, y$2, b$1, v$1, d$1, E4, w$1, S4, j$1, O3, x3, q3, R4, A$1, k4, _4, T5, P$1, I4, D4, F4, N$1, L4, M3, X3, Z2, $$1, et2, AssertionError, deepEqual, deepStrictEqual, doesNotReject, doesNotThrow, equal, fail, ifError, notDeepEqual, notDeepStrictEqual, notEqual, notStrictEqual, ok, rejects, strict, strictEqual, throws;
  var init_assert2 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/assert.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      r5 = { assign: e5, polyfill: function() {
        Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e5 });
      } };
      e$13 = Object.prototype.toString;
      r$12 = function(t8) {
        var r9 = e$13.call(t8), n8 = "[object Arguments]" === r9;
        return n8 || (n8 = "[object Array]" !== r9 && null !== t8 && "object" == typeof t8 && "number" == typeof t8.length && t8.length >= 0 && "[object Function]" === e$13.call(t8.callee)), n8;
      };
      if (!Object.keys) {
        n8 = Object.prototype.hasOwnProperty, o8 = Object.prototype.toString, c7 = r$12, l7 = Object.prototype.propertyIsEnumerable, i7 = !l7.call({ toString: null }, "toString"), a8 = l7.call(function() {
        }, "prototype"), u7 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f7 = function(t8) {
          var e9 = t8.constructor;
          return e9 && e9.prototype === t8;
        }, p8 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s7 = function() {
          if ("undefined" == typeof window)
            return false;
          for (var t8 in window)
            try {
              if (!p8["$" + t8] && n8.call(window, t8) && null !== window[t8] && "object" == typeof window[t8])
                try {
                  f7(window[t8]);
                } catch (t9) {
                  return true;
                }
            } catch (t9) {
              return true;
            }
          return false;
        }();
        t5 = function(t8) {
          var e9 = null !== t8 && "object" == typeof t8, r9 = "[object Function]" === o8.call(t8), l8 = c7(t8), p9 = e9 && "[object String]" === o8.call(t8), y6 = [];
          if (!e9 && !r9 && !l8)
            throw new TypeError("Object.keys called on a non-object");
          var b6 = a8 && r9;
          if (p9 && t8.length > 0 && !n8.call(t8, 0))
            for (var g5 = 0; g5 < t8.length; ++g5)
              y6.push(String(g5));
          if (l8 && t8.length > 0)
            for (var h8 = 0; h8 < t8.length; ++h8)
              y6.push(String(h8));
          else
            for (var $4 in t8)
              b6 && "prototype" === $4 || !n8.call(t8, $4) || y6.push(String($4));
          if (i7)
            for (var j5 = function(t9) {
              if ("undefined" == typeof window || !s7)
                return f7(t9);
              try {
                return f7(t9);
              } catch (t10) {
                return false;
              }
            }(t8), w5 = 0; w5 < u7.length; ++w5)
              j5 && "constructor" === u7[w5] || !n8.call(t8, u7[w5]) || y6.push(u7[w5]);
          return y6;
        };
      }
      y4 = t5;
      b4 = Array.prototype.slice;
      g3 = r$12;
      h5 = Object.keys;
      $3 = h5 ? function(t8) {
        return h5(t8);
      } : y4;
      j4 = Object.keys;
      $3.shim = function() {
        Object.keys ? function() {
          var t8 = Object.keys(arguments);
          return t8 && t8.length === arguments.length;
        }(1, 2) || (Object.keys = function(t8) {
          return g3(t8) ? j4(b4.call(t8)) : j4(t8);
        }) : Object.keys = $3;
        return Object.keys || $3;
      };
      w4 = $3;
      r$2 = w4;
      e$2 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
      o$13 = Object.prototype.toString;
      n$13 = Array.prototype.concat;
      a$1 = Object.defineProperty;
      c$13 = a$1 && function() {
        var t8 = {};
        try {
          for (var r9 in a$1(t8, "x", { enumerable: false, value: t8 }), t8)
            return false;
          return t8.x === t8;
        } catch (t9) {
          return false;
        }
      }();
      l$13 = function(t8, r9, e9, n8) {
        var l7;
        (!(r9 in t8) || "function" == typeof (l7 = n8) && "[object Function]" === o$13.call(l7) && n8()) && (c$13 ? a$1(t8, r9, { configurable: true, enumerable: false, value: e9, writable: true }) : t8[r9] = e9);
      };
      u$13 = function(t8, o8) {
        var a8 = arguments.length > 2 ? arguments[2] : {}, c7 = r$2(o8);
        e$2 && (c7 = n$13.call(c7, Object.getOwnPropertySymbols(o8)));
        for (var u7 = 0; u7 < c7.length; u7 += 1)
          l$13(t8, c7[u7], o8[c7[u7]], a8[c7[u7]]);
      };
      u$13.supportsDescriptors = !!c$13;
      f$12 = u$13;
      t$12 = function() {
        if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols)
          return false;
        if ("symbol" == typeof Symbol.iterator)
          return true;
        var t8 = {}, e9 = Symbol("test"), r9 = Object(e9);
        if ("string" == typeof e9)
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(e9))
          return false;
        if ("[object Symbol]" !== Object.prototype.toString.call(r9))
          return false;
        for (e9 in t8[e9] = 42, t8)
          return false;
        if ("function" == typeof Object.keys && 0 !== Object.keys(t8).length)
          return false;
        if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t8).length)
          return false;
        var o8 = Object.getOwnPropertySymbols(t8);
        if (1 !== o8.length || o8[0] !== e9)
          return false;
        if (!Object.prototype.propertyIsEnumerable.call(t8, e9))
          return false;
        if ("function" == typeof Object.getOwnPropertyDescriptor) {
          var n8 = Object.getOwnPropertyDescriptor(t8, e9);
          if (42 !== n8.value || true !== n8.enumerable)
            return false;
        }
        return true;
      };
      f$22 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
      e$3 = t$12;
      l$2 = function() {
        return "function" == typeof f$22 && ("function" == typeof Symbol && ("symbol" == typeof f$22("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
      };
      t$22 = "Function.prototype.bind called on incompatible ";
      n$2 = Array.prototype.slice;
      o$22 = Object.prototype.toString;
      r$3 = function(r9) {
        var e9 = this;
        if ("function" != typeof e9 || "[object Function]" !== o$22.call(e9))
          throw new TypeError(t$22 + e9);
        for (var p8, i7 = n$2.call(arguments, 1), c7 = function() {
          if (this instanceof p8) {
            var t8 = e9.apply(this, i7.concat(n$2.call(arguments)));
            return Object(t8) === t8 ? t8 : this;
          }
          return e9.apply(r9, i7.concat(n$2.call(arguments)));
        }, a8 = Math.max(0, e9.length - i7.length), l7 = [], u7 = 0; u7 < a8; u7++)
          l7.push("$" + u7);
        if (p8 = Function("binder", "return function (" + l7.join(",") + "){ return binder.apply(this,arguments); }")(c7), e9.prototype) {
          var y6 = function() {
          };
          y6.prototype = e9.prototype, p8.prototype = new y6(), y6.prototype = null;
        }
        return p8;
      };
      e$4 = Function.prototype.bind || r$3;
      o$3 = TypeError;
      t$3 = Object.getOwnPropertyDescriptor;
      if (t$3)
        try {
          t$3({}, "");
        } catch (r9) {
          t$3 = null;
        }
      n$3 = function() {
        throw new o$3();
      };
      y$1 = t$3 ? function() {
        try {
          return arguments.callee, n$3;
        } catch (r9) {
          try {
            return t$3(arguments, "callee").get;
          } catch (r10) {
            return n$3;
          }
        }
      }() : n$3;
      a$22 = l$2();
      i$13 = Object.getPrototypeOf || function(r9) {
        return r9.__proto__;
      };
      d5 = "undefined" == typeof Uint8Array ? void 0 : i$13(Uint8Array);
      f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$22 ? i$13([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$22 ? i$13(i$13([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$22 ? i$13((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$22 ? i$13((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$22 ? i$13(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$22 ? Symbol : void 0, "%SymbolPrototype%": a$22 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d5, "%TypedArrayPrototype%": d5 ? d5.prototype : void 0, "%TypeError%": o$3, "%TypeErrorPrototype%": o$3.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
      u$22 = e$4.call(Function.call, String.prototype.replace);
      A4 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      l$3 = /\\(\\)?/g;
      v5 = function(r9) {
        var e9 = [];
        return u$22(r9, A4, function(r10, o8, t8, n8) {
          e9[e9.length] = t8 ? u$22(n8, l$3, "$1") : o8 || r10;
        }), e9;
      };
      P4 = function(r9, e9) {
        if (!(r9 in f$3))
          throw new SyntaxError("intrinsic " + r9 + " does not exist!");
        if (void 0 === f$3[r9] && !e9)
          throw new o$3("intrinsic " + r9 + " exists, but is not available. Please file an issue!");
        return f$3[r9];
      };
      c$2 = function(r9, e9) {
        if ("string" != typeof r9 || 0 === r9.length)
          throw new TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof e9)
          throw new TypeError('"allowMissing" argument must be a boolean');
        for (var n8 = v5(r9), y6 = P4("%" + (n8.length > 0 ? n8[0] : "") + "%", e9), a8 = 1; a8 < n8.length; a8 += 1)
          if (null != y6)
            if (t$3 && a8 + 1 >= n8.length) {
              var i7 = t$3(y6, n8[a8]);
              if (!e9 && !(n8[a8] in y6))
                throw new o$3("base intrinsic for " + r9 + " exists, but the property is not available.");
              y6 = i7 ? i7.get || i7.value : y6[n8[a8]];
            } else
              y6 = y6[n8[a8]];
        return y6;
      };
      p$1 = e$4;
      o$4 = c$2("%Function%");
      i$2 = o$4.apply;
      a$3 = o$4.call;
      (t$4 = function() {
        return p$1.apply(a$3, arguments);
      }).apply = function() {
        return p$1.apply(i$2, arguments);
      };
      l$4 = t$4;
      i$3 = function(t8) {
        return t8 != t8;
      };
      o$5 = (r$4 = function(t8, e9) {
        return 0 === t8 && 0 === e9 ? 1 / t8 == 1 / e9 : t8 === e9 || !(!i$3(t8) || !i$3(e9));
      }, r$4);
      c$3 = (n$4 = function() {
        return "function" == typeof Object.is ? Object.is : o$5;
      }, n$4);
      f$4 = f$12;
      u$3 = f$12;
      s$12 = r$4;
      a$4 = n$4;
      l$5 = function() {
        var t8 = c$3();
        return f$4(Object, { is: t8 }, { is: function() {
          return Object.is !== t8;
        } }), t8;
      };
      p$2 = l$4(a$4(), Object);
      u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
      m4 = p$2;
      N4 = function(r9) {
        return r9 != r9;
      };
      i$4 = N4;
      n$5 = (e$5 = function() {
        return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
      }, f$12);
      t$5 = e$5;
      u$4 = f$12;
      a$5 = N4;
      m$1 = e$5;
      o$6 = function() {
        var r9 = t$5();
        return n$5(Number, { isNaN: r9 }, { isNaN: function() {
          return Number.isNaN !== r9;
        } }), r9;
      };
      s$2 = m$1();
      u$4(s$2, { getPolyfill: m$1, implementation: a$5, shim: o$6 });
      f$5 = s$2;
      c$4 = {};
      a$6 = false;
      u$5 = {};
      l$6 = false;
      g$1 = void 0 !== /a/g.flags;
      h$1 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9) {
          return e9.push(t9);
        }), e9;
      };
      y$2 = function(t8) {
        var e9 = [];
        return t8.forEach(function(t9, n8) {
          return e9.push([n8, t9]);
        }), e9;
      };
      b$1 = Object.is ? Object.is : m4;
      v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
        return [];
      };
      d$1 = Number.isNaN ? Number.isNaN : f$5;
      E4 = m$2(Object.prototype.hasOwnProperty);
      w$1 = m$2(Object.prototype.propertyIsEnumerable);
      S4 = m$2(Object.prototype.toString);
      j$1 = X2.types;
      O3 = j$1.isAnyArrayBuffer;
      x3 = j$1.isArrayBufferView;
      q3 = j$1.isDate;
      R4 = j$1.isMap;
      A$1 = j$1.isRegExp;
      k4 = j$1.isSet;
      _4 = j$1.isNativeError;
      T5 = j$1.isBoxedPrimitive;
      P$1 = j$1.isNumberObject;
      I4 = j$1.isStringObject;
      D4 = j$1.isBooleanObject;
      F4 = j$1.isBigIntObject;
      N$1 = j$1.isSymbolObject;
      L4 = j$1.isFloat32Array;
      M3 = j$1.isFloat64Array;
      X3 = { isDeepEqual: function(t8, e9) {
        return B4(t8, e9, false);
      }, isDeepStrictEqual: function(t8, e9) {
        return B4(t8, e9, true);
      } };
      Z2 = {};
      $$1 = false;
      et2 = tt2();
      et2.AssertionError;
      et2.deepEqual;
      et2.deepStrictEqual;
      et2.doesNotReject;
      et2.doesNotThrow;
      et2.equal;
      et2.fail;
      et2.ifError;
      et2.notDeepEqual;
      et2.notDeepStrictEqual;
      et2.notEqual;
      et2.notStrictEqual;
      et2.ok;
      et2.rejects;
      et2.strict;
      et2.strictEqual;
      et2.throws;
      et2.AssertionError;
      et2.deepEqual;
      et2.deepStrictEqual;
      et2.doesNotReject;
      et2.doesNotThrow;
      et2.equal;
      et2.fail;
      et2.ifError;
      et2.notDeepEqual;
      et2.notDeepStrictEqual;
      et2.notEqual;
      et2.notStrictEqual;
      et2.ok;
      et2.rejects;
      et2.strict;
      et2.strictEqual;
      et2.throws;
      AssertionError = et2.AssertionError;
      deepEqual = et2.deepEqual;
      deepStrictEqual = et2.deepStrictEqual;
      doesNotReject = et2.doesNotReject;
      doesNotThrow = et2.doesNotThrow;
      equal = et2.equal;
      fail = et2.fail;
      ifError = et2.ifError;
      notDeepEqual = et2.notDeepEqual;
      notDeepStrictEqual = et2.notDeepStrictEqual;
      notEqual = et2.notEqual;
      notStrictEqual = et2.notStrictEqual;
      ok = et2.ok;
      rejects = et2.rejects;
      strict = et2.strict;
      strictEqual = et2.strictEqual;
      throws = et2.throws;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/util.js
  var _extend2, callbackify2, debuglog2, deprecate2, format2, inherits2, inspect2, isArray2, isBoolean2, isBuffer2, isDate2, isError2, isFunction2, isNull2, isNullOrUndefined2, isNumber2, isObject2, isPrimitive2, isRegExp2, isString2, isSymbol2, isUndefined2, log2, promisify2, types2, TextEncoder3, TextDecoder3;
  var init_util = __esm({
    "node_modules/@jspm/core/nodelibs/browser/util.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      _extend2 = X2._extend;
      callbackify2 = X2.callbackify;
      debuglog2 = X2.debuglog;
      deprecate2 = X2.deprecate;
      format2 = X2.format;
      inherits2 = X2.inherits;
      inspect2 = X2.inspect;
      isArray2 = X2.isArray;
      isBoolean2 = X2.isBoolean;
      isBuffer2 = X2.isBuffer;
      isDate2 = X2.isDate;
      isError2 = X2.isError;
      isFunction2 = X2.isFunction;
      isNull2 = X2.isNull;
      isNullOrUndefined2 = X2.isNullOrUndefined;
      isNumber2 = X2.isNumber;
      isObject2 = X2.isObject;
      isPrimitive2 = X2.isPrimitive;
      isRegExp2 = X2.isRegExp;
      isString2 = X2.isString;
      isSymbol2 = X2.isSymbol;
      isUndefined2 = X2.isUndefined;
      log2 = X2.log;
      promisify2 = X2.promisify;
      types2 = X2.types;
      TextEncoder3 = X2.TextEncoder = globalThis.TextEncoder;
      TextDecoder3 = X2.TextDecoder = globalThis.TextDecoder;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js
  function dew4() {
    if (_dewExec4)
      return exports$13;
    _dewExec4 = true;
    var process$1 = process2;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length)
          code = path2.charCodeAt(i7);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i7 - 1 || dots === 1)
            ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i7);
            else
              res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0)
            path2 = arguments[i7];
          else {
            if (cwd2 === void 0)
              cwd2 = process$1.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute2)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix2.resolve(from);
        to = posix2.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length; ++i7) {
          if (i7 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code = path2.charCodeAt(i7);
            if (code === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format5(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports$13 = posix2;
    return exports$13;
  }
  var exports$13, _dewExec4, exports4;
  var init_chunk_23dbec7b = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-23dbec7b.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_2eac56ff();
      exports$13 = {};
      _dewExec4 = false;
      exports4 = dew4();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/path.js
  var path_exports = {};
  __export(path_exports, {
    _makeLong: () => _makeLong,
    basename: () => basename,
    default: () => exports4,
    delimiter: () => delimiter,
    dirname: () => dirname,
    extname: () => extname,
    format: () => format3,
    isAbsolute: () => isAbsolute,
    join: () => join,
    normalize: () => normalize,
    parse: () => parse,
    posix: () => posix,
    relative: () => relative,
    resolve: () => resolve,
    sep: () => sep,
    win32: () => win32
  });
  var _makeLong, basename, delimiter, dirname, extname, format3, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32;
  var init_path = __esm({
    "node_modules/@jspm/core/nodelibs/browser/path.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_23dbec7b();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      _makeLong = exports4._makeLong;
      basename = exports4.basename;
      delimiter = exports4.delimiter;
      dirname = exports4.dirname;
      extname = exports4.extname;
      format3 = exports4.format;
      isAbsolute = exports4.isAbsolute;
      join = exports4.join;
      normalize = exports4.normalize;
      parse = exports4.parse;
      posix = exports4.posix;
      relative = exports4.relative;
      resolve = exports4.resolve;
      sep = exports4.sep;
      win32 = exports4.win32;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/events.js
  var EventEmitter2, defaultMaxListeners, init, listenerCount, on2, once2;
  var init_events = __esm({
    "node_modules/@jspm/core/nodelibs/browser/events.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_4bd36a8f();
      init_chunk_4bd36a8f();
      y.once = function(emitter, event) {
        return new Promise((resolve3, reject) => {
          function eventListener(...args) {
            if (errorListener !== void 0) {
              emitter.removeListener("error", errorListener);
            }
            resolve3(args);
          }
          let errorListener;
          if (event !== "error") {
            errorListener = (err) => {
              emitter.removeListener(name, eventListener);
              reject(err);
            };
            emitter.once("error", errorListener);
          }
          emitter.once(event, eventListener);
        });
      };
      y.on = function(emitter, event) {
        const unconsumedEventValues = [];
        const unconsumedPromises = [];
        let error = null;
        let finished2 = false;
        const iterator = {
          async next() {
            const value = unconsumedEventValues.shift();
            if (value) {
              return createIterResult(value, false);
            }
            if (error) {
              const p8 = Promise.reject(error);
              error = null;
              return p8;
            }
            if (finished2) {
              return createIterResult(void 0, true);
            }
            return new Promise((resolve3, reject) => unconsumedPromises.push({ resolve: resolve3, reject }));
          },
          async return() {
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
            finished2 = true;
            for (const promise of unconsumedPromises) {
              promise.resolve(createIterResult(void 0, true));
            }
            return createIterResult(void 0, true);
          },
          throw(err) {
            error = err;
            emitter.removeListener(event, eventHandler);
            emitter.removeListener("error", errorHandler);
          },
          [Symbol.asyncIterator]() {
            return this;
          }
        };
        emitter.on(event, eventHandler);
        emitter.on("error", errorHandler);
        return iterator;
        function eventHandler(...args) {
          const promise = unconsumedPromises.shift();
          if (promise) {
            promise.resolve(createIterResult(args, false));
          } else {
            unconsumedEventValues.push(args);
          }
        }
        function errorHandler(err) {
          finished2 = true;
          const toError = unconsumedPromises.shift();
          if (toError) {
            toError.reject(err);
          } else {
            error = err;
          }
          iterator.return();
        }
      };
      ({
        EventEmitter: EventEmitter2,
        defaultMaxListeners,
        init,
        listenerCount,
        on: on2,
        once: once2
      } = y);
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js
  function dew5() {
    if (_dewExec5)
      return exports$14;
    _dewExec5 = true;
    exports$14 = Stream2;
    var EE = y.EventEmitter;
    var inherits3 = dew$f();
    inherits3(Stream2, EE);
    Stream2.Readable = dew$3();
    Stream2.Writable = dew$8();
    Stream2.Duplex = dew$7();
    Stream2.Transform = dew$22();
    Stream2.PassThrough = dew$12();
    Stream2.finished = dew$6();
    Stream2.pipeline = dew3();
    Stream2.Stream = Stream2;
    function Stream2() {
      EE.call(this || _global3);
    }
    Stream2.prototype.pipe = function(dest, options) {
      var source2 = this || _global3;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source2.pause) {
            source2.pause();
          }
        }
      }
      source2.on("data", ondata);
      function ondrain() {
        if (source2.readable && source2.resume) {
          source2.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source2.on("end", onend);
        source2.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er2) {
        cleanup();
        if (EE.listenerCount(this || _global3, "error") === 0) {
          throw er2;
        }
      }
      source2.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source2.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source2.removeListener("end", onend);
        source2.removeListener("close", onclose);
        source2.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source2.removeListener("end", cleanup);
        source2.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source2.on("end", cleanup);
      source2.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source2);
      return dest;
    };
    return exports$14;
  }
  var exports$14, _dewExec5, _global3, exports5;
  var init_chunk_6c718bbe = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-6c718bbe.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_events();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      exports$14 = {};
      _dewExec5 = false;
      _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports5 = dew5();
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/stream.js
  var stream_exports = {};
  __export(stream_exports, {
    Duplex: () => Duplex,
    PassThrough: () => PassThrough,
    Readable: () => Readable,
    Stream: () => Stream,
    Transform: () => Transform,
    Writable: () => Writable,
    default: () => exports5,
    finished: () => finished,
    pipeline: () => pipeline,
    promises: () => promises
  });
  var Readable, Writable, Duplex, Transform, PassThrough, finished, pipeline, Stream, promises;
  var init_stream = __esm({
    "node_modules/@jspm/core/nodelibs/browser/stream.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_6c718bbe();
      init_chunk_6c718bbe();
      init_util();
      init_events();
      init_chunk_4bd36a8f();
      init_chunk_44e51b61();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      Readable = exports5.Readable;
      Readable.wrap = function(src, options) {
        options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
        options.destroy = function(err, callback) {
          src.destroy(err);
          callback(err);
        };
        return new Readable(options).wrap(src);
      };
      Writable = exports5.Writable;
      Duplex = exports5.Duplex;
      Transform = exports5.Transform;
      PassThrough = exports5.PassThrough;
      finished = exports5.finished;
      pipeline = exports5.pipeline;
      Stream = exports5.Stream;
      promises = {
        finished: promisify2(exports5.finished),
        pipeline: promisify2(exports5.pipeline)
      };
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js
  function i5(t8) {
    throw new RangeError(r6[t8]);
  }
  function f5(t8, o8) {
    const n8 = t8.split("@");
    let r9 = "";
    n8.length > 1 && (r9 = n8[0] + "@", t8 = n8[1]);
    const c7 = function(t9, o9) {
      const n9 = [];
      let e9 = t9.length;
      for (; e9--; )
        n9[e9] = o9(t9[e9]);
      return n9;
    }((t8 = t8.replace(e6, ".")).split("."), o8).join(".");
    return r9 + c7;
  }
  function l5(t8) {
    const o8 = [];
    let n8 = 0;
    const e9 = t8.length;
    for (; n8 < e9; ) {
      const r9 = t8.charCodeAt(n8++);
      if (r9 >= 55296 && r9 <= 56319 && n8 < e9) {
        const e10 = t8.charCodeAt(n8++);
        56320 == (64512 & e10) ? o8.push(((1023 & r9) << 10) + (1023 & e10) + 65536) : (o8.push(r9), n8--);
      } else
        o8.push(r9);
    }
    return o8;
  }
  var t6, o5, n5, e6, r6, c5, s6, u5, a6, d6, h6, p6;
  var init_chunk_924bb2e1 = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-924bb2e1.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      t6 = 2147483647;
      o5 = /^xn--/;
      n5 = /[^\0-\x7E]/;
      e6 = /[\x2E\u3002\uFF0E\uFF61]/g;
      r6 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
      c5 = Math.floor;
      s6 = String.fromCharCode;
      u5 = function(t8, o8) {
        return t8 + 22 + 75 * (t8 < 26) - ((0 != o8) << 5);
      };
      a6 = function(t8, o8, n8) {
        let e9 = 0;
        for (t8 = n8 ? c5(t8 / 700) : t8 >> 1, t8 += c5(t8 / o8); t8 > 455; e9 += 36)
          t8 = c5(t8 / 35);
        return c5(e9 + 36 * t8 / (t8 + 38));
      };
      d6 = function(o8) {
        const n8 = [], e9 = o8.length;
        let r9 = 0, s7 = 128, f7 = 72, l7 = o8.lastIndexOf("-");
        l7 < 0 && (l7 = 0);
        for (let t8 = 0; t8 < l7; ++t8)
          o8.charCodeAt(t8) >= 128 && i5("not-basic"), n8.push(o8.charCodeAt(t8));
        for (let d7 = l7 > 0 ? l7 + 1 : 0; d7 < e9; ) {
          let l8 = r9;
          for (let n9 = 1, s8 = 36; ; s8 += 36) {
            d7 >= e9 && i5("invalid-input");
            const l9 = (u7 = o8.charCodeAt(d7++)) - 48 < 10 ? u7 - 22 : u7 - 65 < 26 ? u7 - 65 : u7 - 97 < 26 ? u7 - 97 : 36;
            (l9 >= 36 || l9 > c5((t6 - r9) / n9)) && i5("overflow"), r9 += l9 * n9;
            const a8 = s8 <= f7 ? 1 : s8 >= f7 + 26 ? 26 : s8 - f7;
            if (l9 < a8)
              break;
            const h9 = 36 - a8;
            n9 > c5(t6 / h9) && i5("overflow"), n9 *= h9;
          }
          const h8 = n8.length + 1;
          f7 = a6(r9 - l8, h8, 0 == l8), c5(r9 / h8) > t6 - s7 && i5("overflow"), s7 += c5(r9 / h8), r9 %= h8, n8.splice(r9++, 0, s7);
        }
        var u7;
        return String.fromCodePoint(...n8);
      };
      h6 = function(o8) {
        const n8 = [];
        let e9 = (o8 = l5(o8)).length, r9 = 128, f7 = 0, d7 = 72;
        for (const t8 of o8)
          t8 < 128 && n8.push(s6(t8));
        let h8 = n8.length, p8 = h8;
        for (h8 && n8.push("-"); p8 < e9; ) {
          let e10 = t6;
          for (const t8 of o8)
            t8 >= r9 && t8 < e10 && (e10 = t8);
          const l7 = p8 + 1;
          e10 - r9 > c5((t6 - f7) / l7) && i5("overflow"), f7 += (e10 - r9) * l7, r9 = e10;
          for (const e11 of o8)
            if (e11 < r9 && ++f7 > t6 && i5("overflow"), e11 == r9) {
              let t8 = f7;
              for (let o9 = 36; ; o9 += 36) {
                const e12 = o9 <= d7 ? 1 : o9 >= d7 + 26 ? 26 : o9 - d7;
                if (t8 < e12)
                  break;
                const r10 = t8 - e12, i7 = 36 - e12;
                n8.push(s6(u5(e12 + r10 % i7, 0))), t8 = c5(r10 / i7);
              }
              n8.push(s6(u5(t8, 0))), d7 = a6(f7, l7, p8 == h8), f7 = 0, ++p8;
            }
          ++f7, ++r9;
        }
        return n8.join("");
      };
      p6 = { version: "2.1.0", ucs2: { decode: l5, encode: (t8) => String.fromCodePoint(...t8) }, decode: d6, encode: h6, toASCII: function(t8) {
        return f5(t8, function(t9) {
          return n5.test(t9) ? "xn--" + h6(t9) : t9;
        });
      }, toUnicode: function(t8) {
        return f5(t8, function(t9) {
          return o5.test(t9) ? d6(t9.slice(4).toLowerCase()) : t9;
        });
      } };
      p6.decode;
      p6.encode;
      p6.toASCII;
      p6.toUnicode;
      p6.ucs2;
      p6.version;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js
  function e7(e9, n8) {
    return Object.prototype.hasOwnProperty.call(e9, n8);
  }
  var n6, r7, t7, o6;
  var init_chunk_b04e620d = __esm({
    "node_modules/@jspm/core/nodelibs/browser/chunk-b04e620d.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      n6 = function(n8, r9, t8, o8) {
        r9 = r9 || "&", t8 = t8 || "=";
        var a8 = {};
        if ("string" != typeof n8 || 0 === n8.length)
          return a8;
        var u7 = /\+/g;
        n8 = n8.split(r9);
        var c7 = 1e3;
        o8 && "number" == typeof o8.maxKeys && (c7 = o8.maxKeys);
        var i7 = n8.length;
        c7 > 0 && i7 > c7 && (i7 = c7);
        for (var s7 = 0; s7 < i7; ++s7) {
          var p8, f7, d7, y6, m6 = n8[s7].replace(u7, "%20"), l7 = m6.indexOf(t8);
          l7 >= 0 ? (p8 = m6.substr(0, l7), f7 = m6.substr(l7 + 1)) : (p8 = m6, f7 = ""), d7 = decodeURIComponent(p8), y6 = decodeURIComponent(f7), e7(a8, d7) ? Array.isArray(a8[d7]) ? a8[d7].push(y6) : a8[d7] = [a8[d7], y6] : a8[d7] = y6;
        }
        return a8;
      };
      r7 = function(e9) {
        switch (typeof e9) {
          case "string":
            return e9;
          case "boolean":
            return e9 ? "true" : "false";
          case "number":
            return isFinite(e9) ? e9 : "";
          default:
            return "";
        }
      };
      t7 = function(e9, n8, t8, o8) {
        return n8 = n8 || "&", t8 = t8 || "=", null === e9 && (e9 = void 0), "object" == typeof e9 ? Object.keys(e9).map(function(o9) {
          var a8 = encodeURIComponent(r7(o9)) + t8;
          return Array.isArray(e9[o9]) ? e9[o9].map(function(e10) {
            return a8 + encodeURIComponent(r7(e10));
          }).join(n8) : a8 + encodeURIComponent(r7(e9[o9]));
        }).join(n8) : o8 ? encodeURIComponent(r7(o8)) + t8 + encodeURIComponent(r7(e9)) : "";
      };
      o6 = {};
      o6.decode = o6.parse = n6, o6.encode = o6.stringify = t7;
      o6.decode;
      o6.encode;
      o6.parse;
      o6.stringify;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/url.js
  function r8() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  function O4(t8, s7, h8) {
    if (t8 && a7.isObject(t8) && t8 instanceof r8)
      return t8;
    var e9 = new r8();
    return e9.parse(t8, s7, h8), e9;
  }
  function dew6() {
    if (_dewExec6)
      return exports6;
    _dewExec6 = true;
    var process3 = T2;
    function assertPath(path2) {
      if (typeof path2 !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
      }
    }
    function normalizeStringPosix(path2, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i7 = 0; i7 <= path2.length; ++i7) {
        if (i7 < path2.length)
          code = path2.charCodeAt(i7);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i7 - 1 || dots === 1)
            ;
          else if (lastSlash !== i7 - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i7;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i7;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path2.slice(lastSlash + 1, i7);
            else
              res = path2.slice(lastSlash + 1, i7);
            lastSegmentLength = i7 - lastSlash - 1;
          }
          lastSlash = i7;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep2, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep2 + base;
    }
    var posix2 = {
      // path.resolve([from ...], to)
      resolve: function resolve3() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd2;
        for (var i7 = arguments.length - 1; i7 >= -1 && !resolvedAbsolute; i7--) {
          var path2;
          if (i7 >= 0)
            path2 = arguments[i7];
          else {
            if (cwd2 === void 0)
              cwd2 = process3.cwd();
            path2 = cwd2;
          }
          assertPath(path2);
          if (path2.length === 0) {
            continue;
          }
          resolvedPath = path2 + "/" + resolvedPath;
          resolvedAbsolute = path2.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var isAbsolute2 = path2.charCodeAt(0) === 47;
        var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
        path2 = normalizeStringPosix(path2, !isAbsolute2);
        if (path2.length === 0 && !isAbsolute2)
          path2 = ".";
        if (path2.length > 0 && trailingSeparator)
          path2 += "/";
        if (isAbsolute2)
          return "/" + path2;
        return path2;
      },
      isAbsolute: function isAbsolute2(path2) {
        assertPath(path2);
        return path2.length > 0 && path2.charCodeAt(0) === 47;
      },
      join: function join2() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i7 = 0; i7 < arguments.length; ++i7) {
          var arg = arguments[i7];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix2.normalize(joined);
      },
      relative: function relative2(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix2.resolve(from);
        to = posix2.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i7 = 0;
        for (; i7 <= length; ++i7) {
          if (i7 === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i7) === 47) {
                return to.slice(toStart + i7 + 1);
              } else if (i7 === 0) {
                return to.slice(toStart + i7);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i7) === 47) {
                lastCommonSep = i7;
              } else if (i7 === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i7);
          var toCode = to.charCodeAt(toStart + i7);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i7;
        }
        var out = "";
        for (i7 = fromStart + lastCommonSep + 1; i7 <= fromEnd; ++i7) {
          if (i7 === fromEnd || from.charCodeAt(i7) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong2(path2) {
        return path2;
      },
      dirname: function dirname2(path2) {
        assertPath(path2);
        if (path2.length === 0)
          return ".";
        var code = path2.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i7 = path2.length - 1; i7 >= 1; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              end = i7;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path2.slice(0, end);
      },
      basename: function basename2(path2, ext) {
        if (ext !== void 0 && typeof ext !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path2);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i7;
        if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
          if (ext.length === path2.length && ext === path2)
            return "";
          var extIdx = ext.length - 1;
          var firstNonSlashEnd = -1;
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            var code = path2.charCodeAt(i7);
            if (code === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i7 + 1;
              }
              if (extIdx >= 0) {
                if (code === ext.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i7;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path2.length;
          return path2.slice(start, end);
        } else {
          for (i7 = path2.length - 1; i7 >= 0; --i7) {
            if (path2.charCodeAt(i7) === 47) {
              if (!matchedSlash) {
                start = i7 + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i7 + 1;
            }
          }
          if (end === -1)
            return "";
          return path2.slice(start, end);
        }
      },
      extname: function extname2(path2) {
        assertPath(path2);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i7 = path2.length - 1; i7 >= 0; --i7) {
          var code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path2.slice(startDot, end);
      },
      format: function format5(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse3(path2) {
        assertPath(path2);
        var ret = {
          root: "",
          dir: "",
          base: "",
          ext: "",
          name: ""
        };
        if (path2.length === 0)
          return ret;
        var code = path2.charCodeAt(0);
        var isAbsolute2 = code === 47;
        var start;
        if (isAbsolute2) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i7 = path2.length - 1;
        var preDotState = 0;
        for (; i7 >= start; --i7) {
          code = path2.charCodeAt(i7);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i7 + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i7 + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i7;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute2)
              ret.base = ret.name = path2.slice(1, end);
            else
              ret.base = ret.name = path2.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute2) {
            ret.name = path2.slice(1, startDot);
            ret.base = path2.slice(1, end);
          } else {
            ret.name = path2.slice(startPart, startDot);
            ret.base = path2.slice(startPart, end);
          }
          ret.ext = path2.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path2.slice(0, startPart - 1);
        else if (isAbsolute2)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix2.posix = posix2;
    exports6 = posix2;
    return exports6;
  }
  function fileURLToPath$1(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
  }
  function getPathFromURLWin$1(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx$1, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix$1(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL$1(filepath) {
    let resolved = path.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx$1, "%25");
    if (!isWindows$1 && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx$1, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx$1, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx$1, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  function fileURLToPath(path2) {
    if (typeof path2 === "string")
      path2 = new URL(path2);
    else if (!(path2 instanceof URL)) {
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    }
    if (path2.protocol !== "file:") {
      throw new Deno.errors.InvalidData("invalid url scheme");
    }
    return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
  }
  function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102 || // 2f 2F /
        pathname[n8 + 1] === "5" && third === 99) {
          throw new Deno.errors.InvalidData(
            "must not include encoded \\ or / characters"
          );
        }
      }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
      return `\\\\${hostname}${pathname}`;
    } else {
      const letter = pathname.codePointAt(1) | 32;
      const sep2 = pathname[2];
      if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
      sep2 !== ":") {
        throw new Deno.errors.InvalidData("file url path must be absolute");
      }
      return pathname.slice(1);
    }
  }
  function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
      throw new Deno.errors.InvalidData("invalid file url hostname");
    }
    const pathname = url.pathname;
    for (let n8 = 0; n8 < pathname.length; n8++) {
      if (pathname[n8] === "%") {
        const third = pathname.codePointAt(n8 + 2) || 32;
        if (pathname[n8 + 1] === "2" && third === 102) {
          throw new Deno.errors.InvalidData(
            "must not include encoded / characters"
          );
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFileURL(filepath) {
    let resolved = exports4.resolve(filepath);
    const filePathLast = filepath.charCodeAt(filepath.length - 1);
    if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports4.sep) {
      resolved += "/";
    }
    const outURL = new URL("file://");
    if (resolved.includes("%"))
      resolved = resolved.replace(percentRegEx, "%25");
    if (!isWindows && resolved.includes("\\")) {
      resolved = resolved.replace(backslashRegEx, "%5C");
    }
    if (resolved.includes("\n"))
      resolved = resolved.replace(newlineRegEx, "%0A");
    if (resolved.includes("\r")) {
      resolved = resolved.replace(carriageReturnRegEx, "%0D");
    }
    if (resolved.includes("	"))
      resolved = resolved.replace(tabRegEx, "%09");
    outURL.pathname = resolved;
    return outURL;
  }
  var h7, e8, a7, o7, n7, i6, l6, p7, c6, u6, f6, m5, v6, g4, y5, b5, exports6, _dewExec6, path, processPlatform$1, CHAR_BACKWARD_SLASH$1, CHAR_FORWARD_SLASH$1, CHAR_LOWERCASE_A$1, CHAR_LOWERCASE_Z$1, isWindows$1, forwardSlashRegEx$1, percentRegEx$1, backslashRegEx$1, newlineRegEx$1, carriageReturnRegEx$1, tabRegEx$1, processPlatform, Url, format4, resolve2, resolveObject, parse2, _URL, CHAR_BACKWARD_SLASH, CHAR_FORWARD_SLASH, CHAR_LOWERCASE_A, CHAR_LOWERCASE_Z, isWindows, forwardSlashRegEx, percentRegEx, backslashRegEx, newlineRegEx, carriageReturnRegEx, tabRegEx;
  var init_url = __esm({
    "node_modules/@jspm/core/nodelibs/browser/url.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_chunk_5decc758();
      init_chunk_23dbec7b();
      init_chunk_2eac56ff();
      h7 = {};
      e8 = p6;
      a7 = { isString: function(t8) {
        return "string" == typeof t8;
      }, isObject: function(t8) {
        return "object" == typeof t8 && null !== t8;
      }, isNull: function(t8) {
        return null === t8;
      }, isNullOrUndefined: function(t8) {
        return null == t8;
      } };
      h7.parse = O4, h7.resolve = function(t8, s7) {
        return O4(t8, false, true).resolve(s7);
      }, h7.resolveObject = function(t8, s7) {
        return t8 ? O4(t8, false, true).resolveObject(s7) : s7;
      }, h7.format = function(t8) {
        a7.isString(t8) && (t8 = O4(t8));
        return t8 instanceof r8 ? t8.format() : r8.prototype.format.call(t8);
      }, h7.Url = r8;
      o7 = /^([a-z0-9.+-]+:)/i;
      n7 = /:[0-9]*$/;
      i6 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
      l6 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
      p7 = ["'"].concat(l6);
      c6 = ["%", "/", "?", ";", "#"].concat(p7);
      u6 = ["/", "?", "#"];
      f6 = /^[+a-z0-9A-Z_-]{0,63}$/;
      m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
      v6 = { javascript: true, "javascript:": true };
      g4 = { javascript: true, "javascript:": true };
      y5 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
      b5 = o6;
      r8.prototype.parse = function(t8, s7, h8) {
        if (!a7.isString(t8))
          throw new TypeError("Parameter 'url' must be a string, not " + typeof t8);
        var r9 = t8.indexOf("?"), n8 = -1 !== r9 && r9 < t8.indexOf("#") ? "?" : "#", l7 = t8.split(n8);
        l7[0] = l7[0].replace(/\\/g, "/");
        var O5 = t8 = l7.join(n8);
        if (O5 = O5.trim(), !h8 && 1 === t8.split("#").length) {
          var d7 = i6.exec(O5);
          if (d7)
            return this.path = O5, this.href = O5, this.pathname = d7[1], d7[2] ? (this.search = d7[2], this.query = s7 ? b5.parse(this.search.substr(1)) : this.search.substr(1)) : s7 && (this.search = "", this.query = {}), this;
        }
        var j5 = o7.exec(O5);
        if (j5) {
          var q4 = (j5 = j5[0]).toLowerCase();
          this.protocol = q4, O5 = O5.substr(j5.length);
        }
        if (h8 || j5 || O5.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var x4 = "//" === O5.substr(0, 2);
          !x4 || j5 && g4[j5] || (O5 = O5.substr(2), this.slashes = true);
        }
        if (!g4[j5] && (x4 || j5 && !y5[j5])) {
          for (var A5, C5, I5 = -1, w5 = 0; w5 < u6.length; w5++) {
            -1 !== (N5 = O5.indexOf(u6[w5])) && (-1 === I5 || N5 < I5) && (I5 = N5);
          }
          -1 !== (C5 = -1 === I5 ? O5.lastIndexOf("@") : O5.lastIndexOf("@", I5)) && (A5 = O5.slice(0, C5), O5 = O5.slice(C5 + 1), this.auth = decodeURIComponent(A5)), I5 = -1;
          for (w5 = 0; w5 < c6.length; w5++) {
            var N5;
            -1 !== (N5 = O5.indexOf(c6[w5])) && (-1 === I5 || N5 < I5) && (I5 = N5);
          }
          -1 === I5 && (I5 = O5.length), this.host = O5.slice(0, I5), O5 = O5.slice(I5), this.parseHost(), this.hostname = this.hostname || "";
          var U5 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
          if (!U5)
            for (var k5 = this.hostname.split(/\./), S5 = (w5 = 0, k5.length); w5 < S5; w5++) {
              var R5 = k5[w5];
              if (R5 && !R5.match(f6)) {
                for (var $4 = "", z5 = 0, H4 = R5.length; z5 < H4; z5++)
                  R5.charCodeAt(z5) > 127 ? $4 += "x" : $4 += R5[z5];
                if (!$4.match(f6)) {
                  var L5 = k5.slice(0, w5), Z3 = k5.slice(w5 + 1), _5 = R5.match(m5);
                  _5 && (L5.push(_5[1]), Z3.unshift(_5[2])), Z3.length && (O5 = "/" + Z3.join(".") + O5), this.hostname = L5.join(".");
                  break;
                }
              }
            }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U5 || (this.hostname = e8.toASCII(this.hostname));
          var E5 = this.port ? ":" + this.port : "", P5 = this.hostname || "";
          this.host = P5 + E5, this.href += this.host, U5 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O5[0] && (O5 = "/" + O5));
        }
        if (!v6[q4])
          for (w5 = 0, S5 = p7.length; w5 < S5; w5++) {
            var T6 = p7[w5];
            if (-1 !== O5.indexOf(T6)) {
              var B5 = encodeURIComponent(T6);
              B5 === T6 && (B5 = escape(T6)), O5 = O5.split(T6).join(B5);
            }
          }
        var D5 = O5.indexOf("#");
        -1 !== D5 && (this.hash = O5.substr(D5), O5 = O5.slice(0, D5));
        var F5 = O5.indexOf("?");
        if (-1 !== F5 ? (this.search = O5.substr(F5), this.query = O5.substr(F5 + 1), s7 && (this.query = b5.parse(this.query)), O5 = O5.slice(0, F5)) : s7 && (this.search = "", this.query = {}), O5 && (this.pathname = O5), y5[q4] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          E5 = this.pathname || "";
          var G4 = this.search || "";
          this.path = E5 + G4;
        }
        return this.href = this.format(), this;
      }, r8.prototype.format = function() {
        var t8 = this.auth || "";
        t8 && (t8 = (t8 = encodeURIComponent(t8)).replace(/%3A/i, ":"), t8 += "@");
        var s7 = this.protocol || "", h8 = this.pathname || "", e9 = this.hash || "", r9 = false, o8 = "";
        this.host ? r9 = t8 + this.host : this.hostname && (r9 = t8 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r9 += ":" + this.port)), this.query && a7.isObject(this.query) && Object.keys(this.query).length && (o8 = b5.stringify(this.query));
        var n8 = this.search || o8 && "?" + o8 || "";
        return s7 && ":" !== s7.substr(-1) && (s7 += ":"), this.slashes || (!s7 || y5[s7]) && false !== r9 ? (r9 = "//" + (r9 || ""), h8 && "/" !== h8.charAt(0) && (h8 = "/" + h8)) : r9 || (r9 = ""), e9 && "#" !== e9.charAt(0) && (e9 = "#" + e9), n8 && "?" !== n8.charAt(0) && (n8 = "?" + n8), s7 + r9 + (h8 = h8.replace(/[?#]/g, function(t9) {
          return encodeURIComponent(t9);
        })) + (n8 = n8.replace("#", "%23")) + e9;
      }, r8.prototype.resolve = function(t8) {
        return this.resolveObject(O4(t8, false, true)).format();
      }, r8.prototype.resolveObject = function(t8) {
        if (a7.isString(t8)) {
          var s7 = new r8();
          s7.parse(t8, false, true), t8 = s7;
        }
        for (var h8 = new r8(), e9 = Object.keys(this), o8 = 0; o8 < e9.length; o8++) {
          var n8 = e9[o8];
          h8[n8] = this[n8];
        }
        if (h8.hash = t8.hash, "" === t8.href)
          return h8.href = h8.format(), h8;
        if (t8.slashes && !t8.protocol) {
          for (var i7 = Object.keys(t8), l7 = 0; l7 < i7.length; l7++) {
            var p8 = i7[l7];
            "protocol" !== p8 && (h8[p8] = t8[p8]);
          }
          return y5[h8.protocol] && h8.hostname && !h8.pathname && (h8.path = h8.pathname = "/"), h8.href = h8.format(), h8;
        }
        if (t8.protocol && t8.protocol !== h8.protocol) {
          if (!y5[t8.protocol]) {
            for (var c7 = Object.keys(t8), u7 = 0; u7 < c7.length; u7++) {
              var f7 = c7[u7];
              h8[f7] = t8[f7];
            }
            return h8.href = h8.format(), h8;
          }
          if (h8.protocol = t8.protocol, t8.host || g4[t8.protocol])
            h8.pathname = t8.pathname;
          else {
            for (var m6 = (t8.pathname || "").split("/"); m6.length && !(t8.host = m6.shift()); )
              ;
            t8.host || (t8.host = ""), t8.hostname || (t8.hostname = ""), "" !== m6[0] && m6.unshift(""), m6.length < 2 && m6.unshift(""), h8.pathname = m6.join("/");
          }
          if (h8.search = t8.search, h8.query = t8.query, h8.host = t8.host || "", h8.auth = t8.auth, h8.hostname = t8.hostname || t8.host, h8.port = t8.port, h8.pathname || h8.search) {
            var v7 = h8.pathname || "", b6 = h8.search || "";
            h8.path = v7 + b6;
          }
          return h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
        }
        var O5 = h8.pathname && "/" === h8.pathname.charAt(0), d7 = t8.host || t8.pathname && "/" === t8.pathname.charAt(0), j5 = d7 || O5 || h8.host && t8.pathname, q4 = j5, x4 = h8.pathname && h8.pathname.split("/") || [], A5 = (m6 = t8.pathname && t8.pathname.split("/") || [], h8.protocol && !y5[h8.protocol]);
        if (A5 && (h8.hostname = "", h8.port = null, h8.host && ("" === x4[0] ? x4[0] = h8.host : x4.unshift(h8.host)), h8.host = "", t8.protocol && (t8.hostname = null, t8.port = null, t8.host && ("" === m6[0] ? m6[0] = t8.host : m6.unshift(t8.host)), t8.host = null), j5 = j5 && ("" === m6[0] || "" === x4[0])), d7)
          h8.host = t8.host || "" === t8.host ? t8.host : h8.host, h8.hostname = t8.hostname || "" === t8.hostname ? t8.hostname : h8.hostname, h8.search = t8.search, h8.query = t8.query, x4 = m6;
        else if (m6.length)
          x4 || (x4 = []), x4.pop(), x4 = x4.concat(m6), h8.search = t8.search, h8.query = t8.query;
        else if (!a7.isNullOrUndefined(t8.search)) {
          if (A5)
            h8.hostname = h8.host = x4.shift(), (U5 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U5.shift(), h8.host = h8.hostname = U5.shift());
          return h8.search = t8.search, h8.query = t8.query, a7.isNull(h8.pathname) && a7.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.href = h8.format(), h8;
        }
        if (!x4.length)
          return h8.pathname = null, h8.search ? h8.path = "/" + h8.search : h8.path = null, h8.href = h8.format(), h8;
        for (var C5 = x4.slice(-1)[0], I5 = (h8.host || t8.host || x4.length > 1) && ("." === C5 || ".." === C5) || "" === C5, w5 = 0, N5 = x4.length; N5 >= 0; N5--)
          "." === (C5 = x4[N5]) ? x4.splice(N5, 1) : ".." === C5 ? (x4.splice(N5, 1), w5++) : w5 && (x4.splice(N5, 1), w5--);
        if (!j5 && !q4)
          for (; w5--; w5)
            x4.unshift("..");
        !j5 || "" === x4[0] || x4[0] && "/" === x4[0].charAt(0) || x4.unshift(""), I5 && "/" !== x4.join("/").substr(-1) && x4.push("");
        var U5, k5 = "" === x4[0] || x4[0] && "/" === x4[0].charAt(0);
        A5 && (h8.hostname = h8.host = k5 ? "" : x4.length ? x4.shift() : "", (U5 = !!(h8.host && h8.host.indexOf("@") > 0) && h8.host.split("@")) && (h8.auth = U5.shift(), h8.host = h8.hostname = U5.shift()));
        return (j5 = j5 || h8.host && x4.length) && !k5 && x4.unshift(""), x4.length ? h8.pathname = x4.join("/") : (h8.pathname = null, h8.path = null), a7.isNull(h8.pathname) && a7.isNull(h8.search) || (h8.path = (h8.pathname ? h8.pathname : "") + (h8.search ? h8.search : "")), h8.auth = t8.auth || h8.auth, h8.slashes = h8.slashes || t8.slashes, h8.href = h8.format(), h8;
      }, r8.prototype.parseHost = function() {
        var t8 = this.host, s7 = n7.exec(t8);
        s7 && (":" !== (s7 = s7[0]) && (this.port = s7.substr(1)), t8 = t8.substr(0, t8.length - s7.length)), t8 && (this.hostname = t8);
      };
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      exports6 = {};
      _dewExec6 = false;
      path = dew6();
      processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL$1;
      h7.fileURLToPath = fileURLToPath$1;
      h7.Url;
      h7.format;
      h7.resolve;
      h7.resolveObject;
      h7.URL;
      CHAR_BACKWARD_SLASH$1 = 92;
      CHAR_FORWARD_SLASH$1 = 47;
      CHAR_LOWERCASE_A$1 = 97;
      CHAR_LOWERCASE_Z$1 = 122;
      isWindows$1 = processPlatform$1 === "win32";
      forwardSlashRegEx$1 = /\//g;
      percentRegEx$1 = /%/g;
      backslashRegEx$1 = /\\/g;
      newlineRegEx$1 = /\n/g;
      carriageReturnRegEx$1 = /\r/g;
      tabRegEx$1 = /\t/g;
      processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
      h7.URL = typeof URL !== "undefined" ? URL : null;
      h7.pathToFileURL = pathToFileURL;
      h7.fileURLToPath = fileURLToPath;
      Url = h7.Url;
      format4 = h7.format;
      resolve2 = h7.resolve;
      resolveObject = h7.resolveObject;
      parse2 = h7.parse;
      _URL = h7.URL;
      CHAR_BACKWARD_SLASH = 92;
      CHAR_FORWARD_SLASH = 47;
      CHAR_LOWERCASE_A = 97;
      CHAR_LOWERCASE_Z = 122;
      isWindows = processPlatform === "win32";
      forwardSlashRegEx = /\//g;
      percentRegEx = /%/g;
      backslashRegEx = /\\/g;
      newlineRegEx = /\n/g;
      carriageReturnRegEx = /\r/g;
      tabRegEx = /\t/g;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/fs.js
  var fs_exports = {};
  __export(fs_exports, {
    Dir: () => Dir,
    Dirent: () => Dirent,
    F_OK: () => F_OK,
    FileReadStream: () => FileReadStream,
    FileWriteStream: () => FileWriteStream,
    R_OK: () => R_OK,
    ReadStream: () => ReadStream,
    Stats: () => Stats,
    W_OK: () => W_OK,
    WriteStream: () => WriteStream,
    X_OK: () => X_OK,
    _toUnixTimestamp: () => _toUnixTimestamp,
    access: () => access,
    accessSync: () => accessSync,
    appendFile: () => appendFile,
    appendFileSync: () => appendFileSync,
    chmod: () => chmod,
    chmodSync: () => chmodSync,
    chown: () => chown,
    chownSync: () => chownSync,
    close: () => close,
    closeSync: () => closeSync,
    constants: () => constants,
    copyFile: () => copyFile,
    copyFileSync: () => copyFileSync,
    cp: () => cp,
    cpSync: () => cpSync,
    createReadStream: () => createReadStream,
    createWriteStream: () => createWriteStream,
    default: () => fs,
    exists: () => exists,
    existsSync: () => existsSync,
    fchmod: () => fchmod,
    fchmodSync: () => fchmodSync,
    fchown: () => fchown,
    fchownSync: () => fchownSync,
    fdatasync: () => fdatasync,
    fdatasyncSync: () => fdatasyncSync,
    fstat: () => fstat,
    fstatSync: () => fstatSync,
    fsync: () => fsync,
    fsyncSync: () => fsyncSync,
    ftruncate: () => ftruncate,
    ftruncateSync: () => ftruncateSync,
    futimes: () => futimes,
    futimesSync: () => futimesSync,
    lchmod: () => lchmod,
    lchmodSync: () => lchmodSync,
    lchown: () => lchown,
    lchownSync: () => lchownSync,
    link: () => link,
    linkSync: () => linkSync,
    lstat: () => lstat,
    lstatSync: () => lstatSync,
    mkdir: () => mkdir,
    mkdirSync: () => mkdirSync,
    mkdtemp: () => mkdtemp,
    mkdtempSync: () => mkdtempSync,
    open: () => open,
    openSync: () => openSync,
    opendir: () => opendir,
    opendirSync: () => opendirSync,
    promises: () => promises2,
    read: () => read,
    readFile: () => readFile,
    readFileSync: () => readFileSync,
    readSync: () => readSync,
    readdir: () => readdir,
    readdirSync: () => readdirSync,
    readlink: () => readlink,
    readlinkSync: () => readlinkSync,
    readv: () => readv,
    readvSync: () => readvSync,
    realpath: () => realpath,
    realpathSync: () => realpathSync,
    rename: () => rename,
    renameSync: () => renameSync,
    rm: () => rm,
    rmSync: () => rmSync,
    rmdir: () => rmdir,
    rmdirSync: () => rmdirSync,
    stat: () => stat,
    statSync: () => statSync,
    symlink: () => symlink,
    symlinkSync: () => symlinkSync,
    truncate: () => truncate,
    truncateSync: () => truncateSync,
    unlink: () => unlink,
    unlinkSync: () => unlinkSync,
    unwatchFile: () => unwatchFile,
    utimes: () => utimes,
    utimesSync: () => utimesSync,
    watch: () => watch,
    watchFile: () => watchFile,
    write: () => write,
    writeFile: () => writeFile,
    writeFileSync: () => writeFileSync,
    writeSync: () => writeSync,
    writev: () => writev,
    writevSync: () => writevSync
  });
  function dew$f2() {
    if (_dewExec$f2)
      return exports$h;
    _dewExec$f2 = true;
    Object.defineProperty(exports$h, "__esModule", {
      value: true
    });
    exports$h.constants = void 0;
    exports$h.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
    return exports$h;
  }
  function dew$e2() {
    if (_dewExec$e2)
      return exports$g2;
    _dewExec$e2 = true;
    if (typeof BigInt === "function")
      exports$g2.default = BigInt;
    else
      exports$g2.default = function BigIntNotSupported() {
        throw new Error("BigInt is not supported in this environment.");
      };
    return exports$g2;
  }
  function dew$d2() {
    if (_dewExec$d2)
      return exports$f2;
    _dewExec$d2 = true;
    Object.defineProperty(exports$f2, "__esModule", {
      value: true
    });
    exports$f2.Stats = void 0;
    var constants_1 = dew$f2();
    var getBigInt_1 = dew$e2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Stats2 = function() {
      function Stats3() {
      }
      Stats3.build = function(node, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var stats = new Stats3();
        var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
        var getStatNumber = !bigint ? function(number) {
          return number;
        } : getBigInt_1.default;
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      };
      Stats3.prototype._checkModeProperty = function(property) {
        return (Number(this.mode) & S_IFMT) === property;
      };
      Stats3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Stats3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Stats3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Stats3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Stats3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Stats3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Stats3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Stats3;
    }();
    exports$f2.Stats = Stats2;
    exports$f2.default = Stats2;
    return exports$f2;
  }
  function dew$c2() {
    if (_dewExec$c2)
      return exports$e2;
    _dewExec$c2 = true;
    var __spreadArray = exports$e2 && exports$e2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from.length, ar2; i7 < l7; i7++) {
          if (ar2 || !(i7 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i7);
            ar2[i7] = from[i7];
          }
        }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports$e2, "__esModule", {
      value: true
    });
    exports$e2.bufferFrom = exports$e2.bufferAllocUnsafe = exports$e2.Buffer = void 0;
    var buffer_1 = buffer;
    Object.defineProperty(exports$e2, "Buffer", {
      enumerable: true,
      get: function() {
        return buffer_1.Buffer;
      }
    });
    function bufferV0P12Ponyfill(arg0) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
    }
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports$e2.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports$e2.bufferFrom = bufferFrom;
    return exports$e2;
  }
  function dew$b2() {
    if (_dewExec$b2)
      return exports$d2;
    _dewExec$b2 = true;
    var __extends = exports$d2 && exports$d2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d7, b6) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d8, b7) {
          d8.__proto__ = b7;
        } || function(d8, b7) {
          for (var p8 in b7)
            if (Object.prototype.hasOwnProperty.call(b7, p8))
              d8[p8] = b7[p8];
        };
        return extendStatics(d7, b6);
      };
      return function(d7, b6) {
        if (typeof b6 !== "function" && b6 !== null)
          throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
        extendStatics(d7, b6);
        function __() {
          this.constructor = d7;
        }
        d7.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
      };
    }();
    Object.defineProperty(exports$d2, "__esModule", {
      value: true
    });
    exports$d2.E = exports$d2.AssertionError = exports$d2.message = exports$d2.RangeError = exports$d2.TypeError = exports$d2.Error = void 0;
    var assert3 = et2;
    var util = X2;
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      return function(_super) {
        __extends(NodeError, _super);
        function NodeError(key) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var _this = _super.call(this, message(key, args)) || this;
          _this.code = key;
          _this[kCode] = key;
          _this.name = _super.prototype.name + " [" + _this[kCode] + "]";
          return _this;
        }
        return NodeError;
      }(Base);
    }
    var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
    var AssertionError2 = function(_super) {
      __extends(AssertionError3, _super);
      function AssertionError3(options) {
        var _this = this;
        if (typeof options !== "object" || options === null) {
          throw new exports$d2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          _this = _super.call(this, options.message) || this;
        } else {
          _this = _super.call(this, util.inspect(options.actual).slice(0, 128) + " " + (options.operator + " " + util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = "AssertionError [ERR_ASSERTION]";
        _this.code = "ERR_ASSERTION";
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports$d2.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
      }
      return AssertionError3;
    }(g5.Error);
    exports$d2.AssertionError = AssertionError2;
    function message(key, args) {
      assert3.strictEqual(typeof key, "string");
      var msg = messages[key];
      assert3(msg, "An invalid error message key was used: " + key + ".");
      var fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    exports$d2.message = message;
    function E5(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    exports$d2.E = E5;
    exports$d2.Error = makeNodeError(g5.Error);
    exports$d2.TypeError = makeNodeError(g5.TypeError);
    exports$d2.RangeError = makeNodeError(g5.RangeError);
    E5("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E5("ERR_ASSERTION", "%s");
    E5("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E5("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E5("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E5("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E5("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
      return 'c-ares failed to set servers: "' + err + '" [' + servers + "]";
    });
    E5("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E5("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
      return 'The "' + enc + '" encoding is not supported';
    });
    E5("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
      return "The encoded data was not valid for encoding " + enc;
    });
    E5("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E5("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E5("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E5("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E5("ERR_INVALID_ARG_TYPE", invalidArgType);
    E5("ERR_INVALID_ARRAY_LENGTH", function(name2, len, actual) {
      assert3.strictEqual(typeof actual, "number");
      return 'The array "' + name2 + '" (length ' + actual + ") must be of length " + len + ".";
    });
    E5("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E5("ERR_INVALID_CALLBACK", "Callback must be a function");
    E5("ERR_INVALID_CHAR", "Invalid character in %s");
    E5("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E5("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E5("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E5("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E5("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E5("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E5("ERR_INVALID_OPT_VALUE", function(name2, value) {
      return 'The value "' + String(value) + '" is invalid for option "' + name2 + '"';
    });
    E5("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
      return 'The value "' + String(value) + '" is invalid for option "encoding"';
    });
    E5("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E5("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E5("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E5("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E5("ERR_INVALID_URL", "Invalid URL: %s");
    E5("ERR_INVALID_URL_SCHEME", function(expected) {
      return "The URL must be " + oneOf(expected, "scheme");
    });
    E5("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E5("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E5("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E5("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E5("ERR_MISSING_ARGS", missingArgs);
    E5("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E5("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E5("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E5("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E5("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E5("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E5("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E5("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E5("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E5("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E5("ERR_SOCKET_CLOSED", "Socket is closed");
    E5("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E5("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E5("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E5("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E5("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E5("ERR_TLS_DH_PARAM_SIZE", function(size) {
      return "DH parameter size " + size + " is less than 2048";
    });
    E5("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E5("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E5("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E5("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E5("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E5("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E5("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E5("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E5("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E5("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E5("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name2, expected, actual) {
      assert3(name2, "name is required");
      var determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      var msg;
      if (Array.isArray(name2)) {
        var names = name2.map(function(val) {
          return '"' + val + '"';
        }).join(", ");
        msg = "The " + names + " arguments " + determiner + " " + oneOf(expected, "type");
      } else if (name2.includes(" argument")) {
        msg = "The " + name2 + " " + determiner + " " + oneOf(expected, "type");
      } else {
        var type = name2.includes(".") ? "property" : "argument";
        msg = 'The "' + name2 + '" ' + type + " " + determiner + " " + oneOf(expected, "type");
      }
      if (arguments.length >= 3) {
        msg += ". Received type " + (actual !== null ? typeof actual : "null");
      }
      return msg;
    }
    function missingArgs() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      assert3(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a8) {
        return '"' + a8 + '"';
      });
      switch (len) {
        case 1:
          msg += args[0] + " argument";
          break;
        case 2:
          msg += args[0] + " and " + args[1] + " arguments";
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and " + args[len - 1] + " arguments";
          break;
      }
      return msg + " must be specified";
    }
    function oneOf(expected, thing) {
      assert3(expected, "expected is required");
      assert3(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        var len = expected.length;
        assert3(len > 0, "At least one expected value needs to be specified");
        expected = expected.map(function(i7) {
          return String(i7);
        });
        if (len > 2) {
          return "one of " + thing + " " + expected.slice(0, len - 1).join(", ") + ", or " + expected[len - 1];
        } else if (len === 2) {
          return "one of " + thing + " " + expected[0] + " or " + expected[1];
        } else {
          return "of " + thing + " " + expected[0];
        }
      } else {
        return "of " + thing + " " + String(expected);
      }
    }
    function bufferOutOfBounds(name2, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return '"' + name2 + '" is outside of buffer bounds';
      }
    }
    return exports$d2;
  }
  function dew$a2() {
    if (_dewExec$a2)
      return exports$c2;
    _dewExec$a2 = true;
    Object.defineProperty(exports$c2, "__esModule", {
      value: true
    });
    exports$c2.strToEncoding = exports$c2.assertEncoding = exports$c2.ENCODING_UTF8 = void 0;
    var buffer_1 = dew$c2();
    var errors2 = dew$b2();
    exports$c2.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding))
        throw new errors2.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    exports$c2.assertEncoding = assertEncoding;
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports$c2.ENCODING_UTF8)
        return str;
      if (encoding === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    exports$c2.strToEncoding = strToEncoding;
    return exports$c2;
  }
  function dew$92() {
    if (_dewExec$92)
      return exports$b2;
    _dewExec$92 = true;
    Object.defineProperty(exports$b2, "__esModule", {
      value: true
    });
    exports$b2.Dirent = void 0;
    var constants_1 = dew$f2();
    var encoding_1 = dew$a2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Dirent2 = function() {
      function Dirent3() {
        this.name = "";
        this.mode = 0;
      }
      Dirent3.build = function(link3, encoding) {
        var dirent = new Dirent3();
        var mode = link3.getNode().mode;
        dirent.name = (0, encoding_1.strToEncoding)(link3.getName(), encoding);
        dirent.mode = mode;
        return dirent;
      };
      Dirent3.prototype._checkModeProperty = function(property) {
        return (this.mode & S_IFMT) === property;
      };
      Dirent3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Dirent3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Dirent3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Dirent3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Dirent3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Dirent3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Dirent3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Dirent3;
    }();
    exports$b2.Dirent = Dirent2;
    exports$b2.default = Dirent2;
    return exports$b2;
  }
  function dew$82() {
    if (_dewExec$82)
      return exports$a2;
    _dewExec$82 = true;
    var process$1 = process2;
    Object.defineProperty(exports$a2, "__esModule", {
      value: true
    });
    var _setImmediate;
    if (typeof process$1.nextTick === "function")
      _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    else
      _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
    exports$a2.default = _setImmediate;
    return exports$a2;
  }
  function dew$72() {
    if (_dewExec$72)
      return exports$92;
    _dewExec$72 = true;
    var process$1 = process2;
    Object.defineProperty(exports$92, "__esModule", {
      value: true
    });
    exports$92.createProcess = void 0;
    var maybeReturnProcess = function() {
      if (typeof process$1 !== "undefined") {
        return process$1;
      }
      try {
        return process2;
      } catch (_a) {
        return void 0;
      }
    };
    function createProcess() {
      var p8 = maybeReturnProcess() || {};
      if (!p8.getuid)
        p8.getuid = function() {
          return 0;
        };
      if (!p8.getgid)
        p8.getgid = function() {
          return 0;
        };
      if (!p8.cwd)
        p8.cwd = function() {
          return "/";
        };
      if (!p8.nextTick)
        p8.nextTick = dew$82().default;
      if (!p8.emitWarning)
        p8.emitWarning = function(message, type) {
          console.warn("" + type + (type ? ": " : "") + message);
        };
      if (!p8.env)
        p8.env = {};
      return p8;
    }
    exports$92.createProcess = createProcess;
    exports$92.default = createProcess();
    return exports$92;
  }
  function dew$62() {
    if (_dewExec$62)
      return exports$82;
    _dewExec$62 = true;
    var __extends = exports$82 && exports$82.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d7, b6) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d8, b7) {
          d8.__proto__ = b7;
        } || function(d8, b7) {
          for (var p8 in b7)
            if (Object.prototype.hasOwnProperty.call(b7, p8))
              d8[p8] = b7[p8];
        };
        return extendStatics(d7, b6);
      };
      return function(d7, b6) {
        if (typeof b6 !== "function" && b6 !== null)
          throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
        extendStatics(d7, b6);
        function __() {
          this.constructor = d7;
        }
        d7.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
      };
    }();
    Object.defineProperty(exports$82, "__esModule", {
      value: true
    });
    exports$82.File = exports$82.Link = exports$82.Node = exports$82.SEP = void 0;
    var process_1 = dew$72();
    var buffer_1 = dew$c2();
    var constants_1 = dew$f2();
    var events_1 = y;
    var Stats_1 = dew$d2();
    var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
    exports$82.SEP = "/";
    var Node2 = function(_super) {
      __extends(Node3, _super);
      function Node3(ino, perm) {
        if (perm === void 0) {
          perm = 438;
        }
        var _this = _super.call(this) || this;
        _this.uid = process_1.default.getuid();
        _this.gid = process_1.default.getgid();
        _this.atime = /* @__PURE__ */ new Date();
        _this.mtime = /* @__PURE__ */ new Date();
        _this.ctime = /* @__PURE__ */ new Date();
        _this.perm = 438;
        _this.mode = S_IFREG;
        _this.nlink = 1;
        _this.perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
      }
      Node3.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        return this.getBuffer().toString(encoding);
      };
      Node3.prototype.setString = function(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      };
      Node3.prototype.getBuffer = function() {
        if (!this.buf)
          this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      };
      Node3.prototype.setBuffer = function(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      };
      Node3.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      };
      Node3.prototype.setModeProperty = function(property) {
        this.mode = this.mode & ~S_IFMT | property;
      };
      Node3.prototype.setIsFile = function() {
        this.setModeProperty(S_IFREG);
      };
      Node3.prototype.setIsDirectory = function() {
        this.setModeProperty(S_IFDIR);
      };
      Node3.prototype.setIsSymlink = function() {
        this.setModeProperty(S_IFLNK);
      };
      Node3.prototype.isFile = function() {
        return (this.mode & S_IFMT) === S_IFREG;
      };
      Node3.prototype.isDirectory = function() {
        return (this.mode & S_IFMT) === S_IFDIR;
      };
      Node3.prototype.isSymlink = function() {
        return (this.mode & S_IFMT) === S_IFLNK;
      };
      Node3.prototype.makeSymlink = function(steps) {
        this.symlink = steps;
        this.setIsSymlink();
      };
      Node3.prototype.write = function(buf, off2, len, pos) {
        if (off2 === void 0) {
          off2 = 0;
        }
        if (len === void 0) {
          len = buf.length;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off2, off2 + len);
        this.touch();
        return len;
      };
      Node3.prototype.read = function(buf, off2, len, pos) {
        if (off2 === void 0) {
          off2 = 0;
        }
        if (len === void 0) {
          len = buf.byteLength;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off2, pos, pos + actualLen);
        return actualLen;
      };
      Node3.prototype.truncate = function(len) {
        if (len === void 0) {
          len = 0;
        }
        if (!len)
          this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            var buf = (0, buffer_1.bufferAllocUnsafe)(0);
            this.buf.copy(buf);
            buf.fill(0, len);
          }
        }
        this.touch();
      };
      Node3.prototype.chmod = function(perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
      };
      Node3.prototype.chown = function(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      };
      Node3.prototype.touch = function() {
        this.mtime = /* @__PURE__ */ new Date();
        this.emit("change", this);
      };
      Node3.prototype.canRead = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.canWrite = function(uid, gid) {
        if (uid === void 0) {
          uid = process_1.default.getuid();
        }
        if (gid === void 0) {
          gid = process_1.default.getgid();
        }
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.del = function() {
        this.emit("delete", this);
      };
      Node3.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      };
      return Node3;
    }(events_1.EventEmitter);
    exports$82.Node = Node2;
    var Link = function(_super) {
      __extends(Link2, _super);
      function Link2(vol2, parent, name2) {
        var _this = _super.call(this) || this;
        _this.children = {};
        _this.steps = [];
        _this.ino = 0;
        _this.length = 0;
        _this.vol = vol2;
        _this.parent = parent;
        _this.steps = parent ? parent.steps.concat([name2]) : [name2];
        return _this;
      }
      Link2.prototype.setNode = function(node) {
        this.node = node;
        this.ino = node.ino;
      };
      Link2.prototype.getNode = function() {
        return this.node;
      };
      Link2.prototype.createChild = function(name2, node) {
        if (node === void 0) {
          node = this.vol.createNode();
        }
        var link3 = new Link2(this.vol, this, name2);
        link3.setNode(node);
        if (node.isDirectory())
          ;
        this.setChild(name2, link3);
        return link3;
      };
      Link2.prototype.setChild = function(name2, link3) {
        if (link3 === void 0) {
          link3 = new Link2(this.vol, this, name2);
        }
        this.children[name2] = link3;
        link3.parent = this;
        this.length++;
        this.emit("child:add", link3, this);
        return link3;
      };
      Link2.prototype.deleteChild = function(link3) {
        delete this.children[link3.getName()];
        this.length--;
        this.emit("child:delete", link3, this);
      };
      Link2.prototype.getChild = function(name2) {
        if (Object.hasOwnProperty.call(this.children, name2)) {
          return this.children[name2];
        }
      };
      Link2.prototype.getPath = function() {
        return this.steps.join(exports$82.SEP);
      };
      Link2.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      };
      Link2.prototype.walk = function(steps, stop, i7) {
        if (stop === void 0) {
          stop = steps.length;
        }
        if (i7 === void 0) {
          i7 = 0;
        }
        if (i7 >= steps.length)
          return this;
        if (i7 >= stop)
          return this;
        var step = steps[i7];
        var link3 = this.getChild(step);
        if (!link3)
          return null;
        return link3.walk(steps, stop, i7 + 1);
      };
      Link2.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      };
      return Link2;
    }(events_1.EventEmitter);
    exports$82.Link = Link;
    var File = function() {
      function File2(link3, node, flags, fd) {
        this.position = 0;
        this.link = link3;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
      }
      File2.prototype.getString = function(encoding) {
        return this.node.getString();
      };
      File2.prototype.setString = function(str) {
        this.node.setString(str);
      };
      File2.prototype.getBuffer = function() {
        return this.node.getBuffer();
      };
      File2.prototype.setBuffer = function(buf) {
        this.node.setBuffer(buf);
      };
      File2.prototype.getSize = function() {
        return this.node.getSize();
      };
      File2.prototype.truncate = function(len) {
        this.node.truncate(len);
      };
      File2.prototype.seekTo = function(position) {
        this.position = position;
      };
      File2.prototype.stats = function() {
        return Stats_1.default.build(this.node);
      };
      File2.prototype.write = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.length;
        }
        if (typeof position !== "number")
          position = this.position;
        if (this.flags & O_APPEND)
          position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File2.prototype.read = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.byteLength;
        }
        if (typeof position !== "number")
          position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File2.prototype.chmod = function(perm) {
        this.node.chmod(perm);
      };
      File2.prototype.chown = function(uid, gid) {
        this.node.chown(uid, gid);
      };
      return File2;
    }();
    exports$82.File = File;
    return exports$82;
  }
  function dew$52() {
    if (_dewExec$52)
      return exports$72;
    _dewExec$52 = true;
    Object.defineProperty(exports$72, "__esModule", {
      value: true
    });
    function setTimeoutUnref(callback, time, args) {
      var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function")
        ref.unref();
      return ref;
    }
    exports$72.default = setTimeoutUnref;
    return exports$72;
  }
  function dew$42() {
    if (_dewExec$42)
      return exports$62;
    _dewExec$42 = true;
    var __spreadArray = exports$62 && exports$62.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from.length, ar2; i7 < l7; i7++) {
          if (ar2 || !(i7 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i7);
            ar2[i7] = from[i7];
          }
        }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports$62, "__esModule", {
      value: true
    });
    exports$62.FileHandle = void 0;
    function promisify3(vol2, fn, getResult) {
      if (getResult === void 0) {
        getResult = function(input) {
          return input;
        };
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve3, reject) {
          vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
            if (error)
              return reject(error);
            return resolve3(getResult(result));
          }], false));
        });
      };
    }
    var FileHandle = function() {
      function FileHandle2(vol2, fd) {
        this.vol = vol2;
        this.fd = fd;
      }
      FileHandle2.prototype.appendFile = function(data, options) {
        return promisify3(this.vol, "appendFile")(this.fd, data, options);
      };
      FileHandle2.prototype.chmod = function(mode) {
        return promisify3(this.vol, "fchmod")(this.fd, mode);
      };
      FileHandle2.prototype.chown = function(uid, gid) {
        return promisify3(this.vol, "fchown")(this.fd, uid, gid);
      };
      FileHandle2.prototype.close = function() {
        return promisify3(this.vol, "close")(this.fd);
      };
      FileHandle2.prototype.datasync = function() {
        return promisify3(this.vol, "fdatasync")(this.fd);
      };
      FileHandle2.prototype.read = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "read", function(bytesRead) {
          return {
            bytesRead,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.readFile = function(options) {
        return promisify3(this.vol, "readFile")(this.fd, options);
      };
      FileHandle2.prototype.stat = function(options) {
        return promisify3(this.vol, "fstat")(this.fd, options);
      };
      FileHandle2.prototype.sync = function() {
        return promisify3(this.vol, "fsync")(this.fd);
      };
      FileHandle2.prototype.truncate = function(len) {
        return promisify3(this.vol, "ftruncate")(this.fd, len);
      };
      FileHandle2.prototype.utimes = function(atime, mtime) {
        return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
      };
      FileHandle2.prototype.write = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "write", function(bytesWritten) {
          return {
            bytesWritten,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.writeFile = function(data, options) {
        return promisify3(this.vol, "writeFile")(this.fd, data, options);
      };
      return FileHandle2;
    }();
    exports$62.FileHandle = FileHandle;
    function createPromisesApi(vol2) {
      if (typeof Promise === "undefined")
        return null;
      return {
        FileHandle,
        access: function(path2, mode) {
          return promisify3(vol2, "access")(path2, mode);
        },
        appendFile: function(path2, data, options) {
          return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
        },
        chmod: function(path2, mode) {
          return promisify3(vol2, "chmod")(path2, mode);
        },
        chown: function(path2, uid, gid) {
          return promisify3(vol2, "chown")(path2, uid, gid);
        },
        copyFile: function(src, dest, flags) {
          return promisify3(vol2, "copyFile")(src, dest, flags);
        },
        lchmod: function(path2, mode) {
          return promisify3(vol2, "lchmod")(path2, mode);
        },
        lchown: function(path2, uid, gid) {
          return promisify3(vol2, "lchown")(path2, uid, gid);
        },
        link: function(existingPath, newPath) {
          return promisify3(vol2, "link")(existingPath, newPath);
        },
        lstat: function(path2, options) {
          return promisify3(vol2, "lstat")(path2, options);
        },
        mkdir: function(path2, options) {
          return promisify3(vol2, "mkdir")(path2, options);
        },
        mkdtemp: function(prefix, options) {
          return promisify3(vol2, "mkdtemp")(prefix, options);
        },
        open: function(path2, flags, mode) {
          return promisify3(vol2, "open", function(fd) {
            return new FileHandle(vol2, fd);
          })(path2, flags, mode);
        },
        readdir: function(path2, options) {
          return promisify3(vol2, "readdir")(path2, options);
        },
        readFile: function(id, options) {
          return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function(path2, options) {
          return promisify3(vol2, "readlink")(path2, options);
        },
        realpath: function(path2, options) {
          return promisify3(vol2, "realpath")(path2, options);
        },
        rename: function(oldPath, newPath) {
          return promisify3(vol2, "rename")(oldPath, newPath);
        },
        rmdir: function(path2) {
          return promisify3(vol2, "rmdir")(path2);
        },
        stat: function(path2, options) {
          return promisify3(vol2, "stat")(path2, options);
        },
        symlink: function(target, path2, type) {
          return promisify3(vol2, "symlink")(target, path2, type);
        },
        truncate: function(path2, len) {
          return promisify3(vol2, "truncate")(path2, len);
        },
        unlink: function(path2) {
          return promisify3(vol2, "unlink")(path2);
        },
        utimes: function(path2, atime, mtime) {
          return promisify3(vol2, "utimes")(path2, atime, mtime);
        },
        writeFile: function(id, data, options) {
          return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
        }
      };
    }
    exports$62.default = createPromisesApi;
    return exports$62;
  }
  function dew$32() {
    if (_dewExec$32)
      return exports$52;
    _dewExec$32 = true;
    var process$1 = process2;
    Object.defineProperty(exports$52, "__esModule", {
      value: true
    });
    exports$52.unixify = unixify;
    exports$52.correctPath = correctPath;
    var isWin = process$1.platform === "win32";
    function removeTrailingSeparator(str) {
      var i7 = str.length - 1;
      if (i7 < 2) {
        return str;
      }
      while (isSeparator(str, i7)) {
        i7--;
      }
      return str.substr(0, i7 + 1);
    }
    function isSeparator(str, i7) {
      var _char = str[i7];
      return i7 > 0 && (_char === "/" || isWin && _char === "\\");
    }
    function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    }
    function unixify(filepath) {
      var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }
    function correctPath(filepath) {
      return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
    }
    return exports$52;
  }
  function dew$23() {
    if (_dewExec$23)
      return exports$42;
    _dewExec$23 = true;
    var __extends = exports$42 && exports$42.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d7, b6) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d8, b7) {
          d8.__proto__ = b7;
        } || function(d8, b7) {
          for (var p8 in b7)
            if (Object.prototype.hasOwnProperty.call(b7, p8))
              d8[p8] = b7[p8];
        };
        return extendStatics(d7, b6);
      };
      return function(d7, b6) {
        if (typeof b6 !== "function" && b6 !== null)
          throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
        extendStatics(d7, b6);
        function __() {
          this.constructor = d7;
        }
        d7.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
      };
    }();
    var __spreadArray = exports$42 && exports$42.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i7 = 0, l7 = from.length, ar2; i7 < l7; i7++) {
          if (ar2 || !(i7 in from)) {
            if (!ar2)
              ar2 = Array.prototype.slice.call(from, 0, i7);
            ar2[i7] = from[i7];
          }
        }
      return to.concat(ar2 || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports$42, "__esModule", {
      value: true
    });
    exports$42.FSWatcher = exports$42.StatWatcher = exports$42.Volume = exports$42.toUnixTimestamp = exports$42.bufferToEncoding = exports$42.dataToBuffer = exports$42.dataToStr = exports$42.pathToSteps = exports$42.filenameToSteps = exports$42.pathToFilename = exports$42.flagsToNumber = exports$42.FLAGS = void 0;
    var pathModule = exports4;
    var node_1 = dew$62();
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var buffer_1 = dew$c2();
    var setImmediate_1 = dew$82();
    var process_1 = dew$72();
    var setTimeoutUnref_1 = dew$52();
    var stream_1 = exports5;
    var constants_1 = dew$f2();
    var events_1 = y;
    var encoding_1 = dew$a2();
    var errors2 = dew$b2();
    var util = X2;
    var promises_1 = dew$42();
    var resolveCrossPlatform = pathModule.resolve;
    var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
    var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
    var isWin = process_1.default.platform === "win32";
    var kMinPoolSpace = 128;
    var ERRSTR = {
      PATH_STR: "path must be a string or Buffer",
      // FD:             'file descriptor must be a unsigned 32-bit integer',
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var ERRSTR_OPTS = function(tipeof) {
      return "Expected options to be either an object or a string, but got " + tipeof + " instead";
    };
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    function formatError(errorCode, func, path2, path22) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      var pathFormatted = "";
      if (path2)
        pathFormatted = " '" + path2 + "'";
      if (path22)
        pathFormatted += " -> '" + path22 + "'";
      switch (errorCode) {
        case ENOENT:
          return "ENOENT: no such file or directory, " + func + pathFormatted;
        case EBADF:
          return "EBADF: bad file descriptor, " + func + pathFormatted;
        case EINVAL:
          return "EINVAL: invalid argument, " + func + pathFormatted;
        case EPERM:
          return "EPERM: operation not permitted, " + func + pathFormatted;
        case EPROTO:
          return "EPROTO: protocol error, " + func + pathFormatted;
        case EEXIST:
          return "EEXIST: file already exists, " + func + pathFormatted;
        case ENOTDIR:
          return "ENOTDIR: not a directory, " + func + pathFormatted;
        case EISDIR:
          return "EISDIR: illegal operation on a directory, " + func + pathFormatted;
        case EACCES:
          return "EACCES: permission denied, " + func + pathFormatted;
        case ENOTEMPTY:
          return "ENOTEMPTY: directory not empty, " + func + pathFormatted;
        case EMFILE:
          return "EMFILE: too many open files, " + func + pathFormatted;
        case ENOSYS:
          return "ENOSYS: function not implemented, " + func + pathFormatted;
        default:
          return errorCode + ": error occurred, " + func + pathFormatted;
      }
    }
    function createError(errorCode, func, path2, path22, Constructor) {
      if (func === void 0) {
        func = "";
      }
      if (path2 === void 0) {
        path2 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      if (Constructor === void 0) {
        Constructor = Error;
      }
      var error = new Constructor(formatError(errorCode, func, path2, path22));
      error.code = errorCode;
      return error;
    }
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS = exports$42.FLAGS || (exports$42.FLAGS = {}));
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors2.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    exports$42.flagsToNumber = flagsToNumber;
    function getOptions(defaults, options) {
      var opts;
      if (!options)
        return defaults;
      else {
        var tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, {
              encoding: options
            });
            break;
          case "object":
            opts = Object.assign({}, defaults, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    function optsGenerator(defaults) {
      return function(options) {
        return getOptions(defaults, options);
      };
    }
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(ERRSTR.CB);
      return callback;
    }
    function optsAndCbGenerator(getOpts) {
      return function(options, callback) {
        return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
      };
    }
    var optsDefaults = {
      encoding: "utf8"
    };
    var getDefaultOpts = optsGenerator(optsDefaults);
    var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    var getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.w]
    };
    var getWriteFileOptions = optsGenerator(writeFileDefaults);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.a]
    };
    var getAppendFileOpts = optsGenerator(appendFileDefaults);
    var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
    var realpathDefaults = optsDefaults;
    var getRealpathOptions = optsGenerator(realpathDefaults);
    var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = function(options) {
      if (typeof options === "number")
        return Object.assign({}, mkdirDefaults, {
          mode: options
        });
      return Object.assign({}, mkdirDefaults, options);
    };
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = function(options) {
      return Object.assign({}, rmdirDefaults, options);
    };
    var readdirDefaults = {
      encoding: "utf8",
      withFileTypes: false
    };
    var getReaddirOptions = optsGenerator(readdirDefaults);
    var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = function(options) {
      if (options === void 0) {
        options = {};
      }
      return Object.assign({}, statDefaults, options);
    };
    var getStatOptsAndCb = function(options, callback) {
      return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
    };
    function getPathFromURLPosix2(url) {
      if (url.hostname !== "") {
        throw new errors2.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
      }
      var pathname = url.pathname;
      for (var n8 = 0; n8 < pathname.length; n8++) {
        if (pathname[n8] === "%") {
          var third = pathname.codePointAt(n8 + 2) | 32;
          if (pathname[n8 + 1] === "2" && third === 102) {
            throw new errors2.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function pathToFilename(path2) {
      if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
        try {
          if (!(path2 instanceof h7.URL))
            throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(ERRSTR.PATH_STR);
        }
        path2 = getPathFromURLPosix2(path2);
      }
      var pathString = String(path2);
      nullCheck(pathString);
      return pathString;
    }
    exports$42.pathToFilename = pathToFilename;
    var resolve3 = function(filename, base) {
      if (base === void 0) {
        base = process_1.default.cwd();
      }
      return resolveCrossPlatform(base, filename);
    };
    if (isWin) {
      var _resolve_1 = resolve3;
      var unixify_1 = dew$32().unixify;
      resolve3 = function(filename, base) {
        return unixify_1(_resolve_1(filename, base));
      };
    }
    function filenameToSteps(filename, base) {
      var fullPath = resolve3(filename, base);
      var fullPathSansSlash = fullPath.substr(1);
      if (!fullPathSansSlash)
        return [];
      return fullPathSansSlash.split(sep2);
    }
    exports$42.filenameToSteps = filenameToSteps;
    function pathToSteps(path2) {
      return filenameToSteps(pathToFilename(path2));
    }
    exports$42.pathToSteps = pathToSteps;
    function dataToStr(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else
        return String(data);
    }
    exports$42.dataToStr = dataToStr;
    function dataToBuffer(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
      else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    exports$42.dataToBuffer = dataToBuffer;
    function bufferToEncoding(buffer2, encoding) {
      if (!encoding || encoding === "buffer")
        return buffer2;
      else
        return buffer2.toString(encoding);
    }
    exports$42.bufferToEncoding = bufferToEncoding;
    function nullCheck(path2, callback) {
      if (("" + path2).indexOf("\0") !== -1) {
        var er2 = new Error("Path must be a string without null bytes");
        er2.code = ENOENT;
        if (typeof callback !== "function")
          throw er2;
        process_1.default.nextTick(callback, er2);
        return false;
      }
      return true;
    }
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    function modeToNumber(mode, def) {
      var result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(ERRSTR.MODE_INT);
      return result;
    }
    function isFd(path2) {
      return path2 >>> 0 === path2;
    }
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
    }
    function toUnixTimestamp(time) {
      if (typeof time === "string" && +time == time) {
        return +time;
      }
      if (time instanceof Date) {
        return time.getTime() / 1e3;
      }
      if (isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        }
        return time;
      }
      throw new Error("Cannot parse time: " + time);
    }
    exports$42.toUnixTimestamp = toUnixTimestamp;
    function validateUid(uid) {
      if (typeof uid !== "number")
        throw TypeError(ERRSTR.UID);
    }
    function validateGid(gid) {
      if (typeof gid !== "number")
        throw TypeError(ERRSTR.GID);
    }
    function flattenJSON(nestedJSON) {
      var flatJSON = {};
      function flatten(pathPrefix, node) {
        for (var path2 in node) {
          var contentOrNode = node[path2];
          var joinedPath = join2(pathPrefix, path2);
          if (typeof contentOrNode === "string") {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
            flatten(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      flatten("", nestedJSON);
      return flatJSON;
    }
    var Volume = function() {
      function Volume2(props) {
        if (props === void 0) {
          props = {};
        }
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.promisesApi = (0, promises_1.default)(this);
        this.statWatchers = {};
        this.props = Object.assign({
          Node: node_1.Node,
          Link: node_1.Link,
          File: node_1.File
        }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self2 = this;
        this.StatWatcher = function(_super) {
          __extends(StatWatcher2, _super);
          function StatWatcher2() {
            return _super.call(this, self2) || this;
          }
          return StatWatcher2;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = function(_super) {
          __extends(class_1, _super);
          function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = function(_super) {
          __extends(class_2, _super);
          function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_2;
        }(_WriteStream);
        this.FSWatcher = function(_super) {
          __extends(FSWatcher2, _super);
          function FSWatcher2() {
            return _super.call(this, self2) || this;
          }
          return FSWatcher2;
        }(FSWatcher);
        this.root = root;
      }
      Volume2.fromJSON = function(json, cwd2) {
        var vol2 = new Volume2();
        vol2.fromJSON(json, cwd2);
        return vol2;
      };
      Volume2.fromNestedJSON = function(json, cwd2) {
        var vol2 = new Volume2();
        vol2.fromNestedJSON(json, cwd2);
        return vol2;
      };
      Object.defineProperty(Volume2.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null)
            throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: false,
        configurable: true
      });
      Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        if (!parent) {
          return new this.props.Link(this, null, "");
        }
        if (!name2) {
          throw new Error("createLink: name cannot be empty");
        }
        return parent.createChild(name2, this.createNode(isDirectory, perm));
      };
      Volume2.prototype.deleteLink = function(link3) {
        var parent = link3.parent;
        if (parent) {
          parent.deleteChild(link3);
          return true;
        }
        return false;
      };
      Volume2.prototype.newInoNumber = function() {
        var releasedFd = this.releasedInos.pop();
        if (releasedFd)
          return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      };
      Volume2.prototype.newFdNumber = function() {
        var releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
      };
      Volume2.prototype.createNode = function(isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory)
          node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
      };
      Volume2.prototype.getNode = function(ino) {
        return this.inodes[ino];
      };
      Volume2.prototype.deleteNode = function(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      };
      Volume2.prototype.genRndStr = function() {
        var str = (Math.random() + 1).toString(36).substr(2, 6);
        if (str.length === 6)
          return str;
        else
          return this.genRndStr();
      };
      Volume2.prototype.getLink = function(steps) {
        return this.root.walk(steps);
      };
      Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3)
          throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
        var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link3 = this.root;
        var i7 = 0;
        while (i7 < steps.length) {
          var step = steps[i7];
          link3 = link3.getChild(step);
          if (!link3)
            return null;
          var node = link3.getNode();
          if (node.isSymlink()) {
            steps = node.symlink.concat(steps.slice(i7 + 1));
            link3 = this.root;
            i7 = 0;
            continue;
          }
          i7++;
        }
        return link3;
      };
      Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
        var link3 = this.getResolvedLink(filename);
        if (!link3)
          throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.resolveSymlinks = function(link3) {
        return this.getResolvedLink(link3.steps.slice(1));
      };
      Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
        var link3 = this.getLinkOrThrow(filename, funcName);
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, filename);
        return link3;
      };
      Volume2.prototype.getLinkParent = function(steps) {
        return this.root.walk(steps, steps.length - 1);
      };
      Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link3 = this.getLinkParent(steps);
        if (!link3)
          throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
        if (!link3.getNode().isDirectory())
          throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
        return link3;
      };
      Volume2.prototype.getFileByFd = function(fd) {
        return this.fds[String(fd)];
      };
      Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
        if (!isFd(fd))
          throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, funcName);
        return file;
      };
      Volume2.prototype.getNodeByIdOrCreate = function(id, flags, perm) {
        if (typeof id === "number") {
          var file = this.getFileByFd(id);
          if (!file)
            throw Error("File nto found");
          return file.node;
        } else {
          var steps = pathToSteps(id);
          var link3 = this.getLink(steps);
          if (link3)
            return link3.getNode();
          if (flags & O_CREAT) {
            var dirLink = this.getLinkParent(steps);
            if (dirLink) {
              var name_1 = steps[steps.length - 1];
              link3 = this.createLink(dirLink, name_1, false, perm);
              return link3.getNode();
            }
          }
          throw createError(ENOENT, "getNodeByIdOrCreate", pathToFilename(id));
        }
      };
      Volume2.prototype.wrapAsync = function(method, args, callback) {
        var _this = this;
        validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          var result;
          try {
            result = method.apply(_this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      };
      Volume2.prototype._toJSON = function(link3, json, path2) {
        var _a2;
        if (link3 === void 0) {
          link3 = this.root;
        }
        if (json === void 0) {
          json = {};
        }
        var isEmpty = true;
        var children = link3.children;
        if (link3.getNode().isFile()) {
          children = (_a2 = {}, _a2[link3.getName()] = link3.parent.getChild(link3.getName()), _a2);
          link3 = link3.parent;
        }
        for (var name_2 in children) {
          isEmpty = false;
          var child = link3.getChild(name_2);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          var node = child.getNode();
          if (node.isFile()) {
            var filename = child.getPath();
            if (path2)
              filename = relative2(path2, filename);
            json[filename] = node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path2);
          }
        }
        var dirPath = link3.getPath();
        if (path2)
          dirPath = relative2(path2, dirPath);
        if (dirPath && isEmpty) {
          json[dirPath] = null;
        }
        return json;
      };
      Volume2.prototype.toJSON = function(paths, json, isRelative) {
        if (json === void 0) {
          json = {};
        }
        if (isRelative === void 0) {
          isRelative = false;
        }
        var links = [];
        if (paths) {
          if (!(paths instanceof Array))
            paths = [paths];
          for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var path2 = paths_1[_i];
            var filename = pathToFilename(path2);
            var link3 = this.getResolvedLink(filename);
            if (!link3)
              continue;
            links.push(link3);
          }
        } else {
          links.push(this.root);
        }
        if (!links.length)
          return json;
        for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
          var link3 = links_1[_a2];
          this._toJSON(link3, json, isRelative ? link3.getPath() : "");
        }
        return json;
      };
      Volume2.prototype.fromJSON = function(json, cwd2) {
        if (cwd2 === void 0) {
          cwd2 = process_1.default.cwd();
        }
        for (var filename in json) {
          var data = json[filename];
          filename = resolve3(filename, cwd2);
          if (typeof data === "string") {
            var dir = dirname2(filename);
            this.mkdirpBase(
              dir,
              511
              /* DIR */
            );
            this.writeFileSync(filename, data);
          } else {
            this.mkdirpBase(
              filename,
              511
              /* DIR */
            );
          }
        }
      };
      Volume2.prototype.fromNestedJSON = function(json, cwd2) {
        this.fromJSON(flattenJSON(json), cwd2);
      };
      Volume2.prototype.reset = function() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
      };
      Volume2.prototype.mountSync = function(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      };
      Volume2.prototype.openLink = function(link3, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
          throw createError(EMFILE, "open", link3.getPath());
        }
        var realLink = link3;
        if (resolveSymlinks)
          realLink = this.resolveSymlinks(link3);
        if (!realLink)
          throw createError(ENOENT, "open", link3.getPath());
        var node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
            throw createError(EISDIR, "open", link3.getPath());
        } else {
          if (flagsNum & O_DIRECTORY)
            throw createError(ENOTDIR, "open", link3.getPath());
        }
        if (!(flagsNum & O_WRONLY)) {
          if (!node.canRead()) {
            throw createError(EACCES, "open", link3.getPath());
          }
        }
        var file = new this.props.File(link3, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC)
          file.truncate();
        return file;
      };
      Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link3 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        if (!link3 && flagsNum & O_CREAT) {
          var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
          if (!dirLink)
            throw createError(ENOENT, "open", sep2 + steps.join(sep2));
          if (flagsNum & O_CREAT && typeof modeNum === "number") {
            link3 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          }
        }
        if (link3)
          return this.openLink(link3, flagsNum, resolveSymlinks);
        throw createError(ENOENT, "open", filename);
      };
      Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file)
          throw createError(ENOENT, "open", filename);
        return file.fd;
      };
      Volume2.prototype.openSync = function(path2, flags, mode) {
        if (mode === void 0) {
          mode = 438;
        }
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
      };
      Volume2.prototype.open = function(path2, flags, a8, b6) {
        var mode = a8;
        var callback = b6;
        if (typeof a8 === "function") {
          mode = 438;
          callback = a8;
        }
        mode = mode || 438;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
      };
      Volume2.prototype.closeFile = function(file) {
        if (!this.fds[file.fd])
          return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      };
      Volume2.prototype.closeSync = function(fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, "close");
        this.closeFile(file);
      };
      Volume2.prototype.close = function(fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
      };
      Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
        if (typeof id === "number") {
          var file = this.fds[id];
          if (!file)
            throw createError(ENOENT);
          return file;
        } else {
          return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
      };
      Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer2, Number(offset), Number(length), position);
      };
      Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer2, offset, length, position);
      };
      Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        if (length === 0) {
          return process_1.default.nextTick(function() {
            if (callback)
              callback(null, 0, buffer2);
          });
        }
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.readBase(fd, buffer2, offset, length, position);
            callback(null, bytes, buffer2);
          } catch (err) {
            callback(err);
          }
        });
      };
      Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === "number";
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd)
          fd = id;
        else {
          var filename = pathToFilename(id);
          var steps = filenameToSteps(filename);
          var link3 = this.getResolvedLink(steps);
          if (link3) {
            var node = link3.getNode();
            if (node.isDirectory())
              throw createError(EISDIR, "open", link3.getPath());
          }
          fd = this.openSync(id, flagsNum);
        }
        try {
          result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
          if (!userOwnsFd) {
            this.closeSync(fd);
          }
        }
        return result;
      };
      Volume2.prototype.readFileSync = function(file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
      };
      Volume2.prototype.readFile = function(id, a8, b6) {
        var _a2 = optsAndCbGenerator(getReadFileOptions)(a8, b6), opts = _a2[0], callback = _a2[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
      };
      Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, "write");
        return file.write(buf, offset, length, position);
      };
      Volume2.prototype.writeSync = function(fd, a8, b6, c7, d7) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer3 = typeof a8 !== "string";
        if (isBuffer3) {
          offset = (b6 || 0) | 0;
          length = c7;
          position = d7;
        } else {
          position = b6;
          encoding = c7;
        }
        var buf = dataToBuffer(a8, encoding);
        if (isBuffer3) {
          if (typeof length === "undefined") {
            length = buf.length;
          }
        } else {
          offset = 0;
          length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
      };
      Volume2.prototype.write = function(fd, a8, b6, c7, d7, e9) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a8;
        var tipb = typeof b6;
        var tipc = typeof c7;
        var tipd = typeof d7;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b6;
          } else if (tipc === "function") {
            offset = b6 | 0;
            callback = c7;
          } else if (tipd === "function") {
            offset = b6 | 0;
            length = c7;
            callback = d7;
          } else {
            offset = b6 | 0;
            length = c7;
            position = d7;
            callback = e9;
          }
        } else {
          if (tipb === "function") {
            callback = b6;
          } else if (tipc === "function") {
            position = b6;
            callback = c7;
          } else if (tipd === "function") {
            position = b6;
            encoding = c7;
            callback = d7;
          }
        }
        var buf = dataToBuffer(a8, encoding);
        if (tipa !== "string") {
          if (typeof length === "undefined")
            length = buf.length;
        } else {
          offset = 0;
          length = buf.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.writeBase(fd, buf, offset, length, position);
            if (tipa !== "string") {
              cb(null, bytes, buf);
            } else {
              cb(null, bytes, a8);
            }
          } catch (err) {
            cb(err);
          }
        });
      };
      Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
        var isUserFd = typeof id === "number";
        var fd;
        if (isUserFd)
          fd = id;
        else {
          fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? void 0 : 0;
        try {
          while (length > 0) {
            var written = this.writeSync(fd, buf, offset, length, position);
            offset += written;
            length -= written;
            if (position !== void 0)
              position += written;
          }
        } finally {
          if (!isUserFd)
            this.closeSync(fd);
        }
      };
      Volume2.prototype.writeFileSync = function(id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
      };
      Volume2.prototype.writeFile = function(id, data, a8, b6) {
        var options = a8;
        var callback = b6;
        if (typeof a8 === "function") {
          options = writeFileDefaults;
          callback = a8;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
      };
      Volume2.prototype.linkBase = function(filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1)
          throw createError(ENOENT, "link", filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        var dir2 = this.getLinkParent(steps2);
        if (!dir2)
          throw createError(ENOENT, "link", filename1, filename2);
        var name2 = steps2[steps2.length - 1];
        if (dir2.getChild(name2))
          throw createError(EEXIST, "link", filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name2, node);
      };
      Volume2.prototype.copyFileBase = function(src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
          if (this.existsSync(dest)) {
            throw createError(EEXIST, "copyFile", src, dest);
          }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
          throw createError(ENOSYS, "copyFile", src, dest);
        }
        this.writeFileBase(
          dest,
          buf,
          FLAGS.w,
          438
          /* DEFAULT */
        );
      };
      Volume2.prototype.copyFileSync = function(src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
      };
      Volume2.prototype.copyFile = function(src, dest, a8, b6) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a8 === "function") {
          flags = 0;
          callback = a8;
        } else {
          flags = a8;
          callback = b6;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
      };
      Volume2.prototype.linkSync = function(existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
      };
      Volume2.prototype.link = function(existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.unlinkBase = function(filename) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3)
          throw createError(ENOENT, "unlink", filename);
        if (link3.length)
          throw Error("Dir not empty...");
        this.deleteLink(link3);
        var node = link3.getNode();
        node.nlink--;
        if (node.nlink <= 0) {
          this.deleteNode(node);
        }
      };
      Volume2.prototype.unlinkSync = function(path2) {
        var filename = pathToFilename(path2);
        this.unlinkBase(filename);
      };
      Volume2.prototype.unlink = function(path2, callback) {
        var filename = pathToFilename(path2);
        this.wrapAsync(this.unlinkBase, [filename], callback);
      };
      Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink)
          throw createError(ENOENT, "symlink", targetFilename, pathFilename);
        var name2 = pathSteps[pathSteps.length - 1];
        if (dirLink.getChild(name2))
          throw createError(EEXIST, "symlink", targetFilename, pathFilename);
        var symlink3 = dirLink.createChild(name2);
        symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink3;
      };
      Volume2.prototype.symlinkSync = function(target, path2, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.symlinkBase(targetFilename, pathFilename);
      };
      Volume2.prototype.symlink = function(target, path2, a8, b6) {
        var callback = validateCallback(typeof a8 === "function" ? a8 : b6);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
      };
      Volume2.prototype.realpathBase = function(filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink)
          throw createError(ENOENT, "realpath", filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath(), encoding);
      };
      Volume2.prototype.realpathSync = function(path2, options) {
        return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
      };
      Volume2.prototype.realpath = function(path2, a8, b6) {
        var _a2 = getRealpathOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
      };
      Volume2.prototype.lstatBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link3 = this.getLink(filenameToSteps(filename));
        if (!link3)
          throw createError(ENOENT, "lstat", filename);
        return Stats_1.default.build(link3.getNode(), bigint);
      };
      Volume2.prototype.lstatSync = function(path2, options) {
        return this.lstatBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.lstat = function(path2, a8, b6) {
        var _a2 = getStatOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.statBase = function(filename, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var link3 = this.getResolvedLink(filenameToSteps(filename));
        if (!link3)
          throw createError(ENOENT, "stat", filename);
        return Stats_1.default.build(link3.getNode(), bigint);
      };
      Volume2.prototype.statSync = function(path2, options) {
        return this.statBase(pathToFilename(path2), getStatOptions(options).bigint);
      };
      Volume2.prototype.stat = function(path2, a8, b6) {
        var _a2 = getStatOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.statBase, [pathToFilename(path2), opts.bigint], callback);
      };
      Volume2.prototype.fstatBase = function(fd, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file)
          throw createError(EBADF, "fstat");
        return Stats_1.default.build(file.node, bigint);
      };
      Volume2.prototype.fstatSync = function(fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
      };
      Volume2.prototype.fstat = function(fd, a8, b6) {
        var _a2 = getStatOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      };
      Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
        var link3 = this.getLink(filenameToSteps(oldPathFilename));
        if (!link3)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var newPathSteps = filenameToSteps(newPathFilename);
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink)
          throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var oldLinkParent = link3.parent;
        if (oldLinkParent) {
          oldLinkParent.deleteChild(link3);
        }
        var name2 = newPathSteps[newPathSteps.length - 1];
        link3.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name2], false);
        newPathDirLink.setChild(link3.getName(), link3);
      };
      Volume2.prototype.renameSync = function(oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
      };
      Volume2.prototype.rename = function(oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.existsBase = function(filename) {
        return !!this.statBase(filename);
      };
      Volume2.prototype.existsSync = function(path2) {
        try {
          return this.existsBase(pathToFilename(path2));
        } catch (err) {
          return false;
        }
      };
      Volume2.prototype.exists = function(path2, callback) {
        var _this = this;
        var filename = pathToFilename(path2);
        if (typeof callback !== "function")
          throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function() {
          try {
            callback(_this.existsBase(filename));
          } catch (err) {
            callback(false);
          }
        });
      };
      Volume2.prototype.accessBase = function(filename, mode) {
        this.getLinkOrThrow(filename, "access");
      };
      Volume2.prototype.accessSync = function(path2, mode) {
        if (mode === void 0) {
          mode = F_OK2;
        }
        var filename = pathToFilename(path2);
        mode = mode | 0;
        this.accessBase(filename, mode);
      };
      Volume2.prototype.access = function(path2, a8, b6) {
        var mode = F_OK2;
        var callback;
        if (typeof a8 !== "function") {
          mode = a8 | 0;
          callback = validateCallback(b6);
        } else {
          callback = a8;
        }
        var filename = pathToFilename(path2);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
      };
      Volume2.prototype.appendFileSync = function(id, data, options) {
        if (options === void 0) {
          options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFileSync(id, data, opts);
      };
      Volume2.prototype.appendFile = function(id, data, a8, b6) {
        var _a2 = getAppendFileOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        if (!opts.flag || isFd(id))
          opts.flag = "a";
        this.writeFile(id, data, opts, callback);
      };
      Volume2.prototype.readdirBase = function(filename, options) {
        var steps = filenameToSteps(filename);
        var link3 = this.getResolvedLink(steps);
        if (!link3)
          throw createError(ENOENT, "readdir", filename);
        var node = link3.getNode();
        if (!node.isDirectory())
          throw createError(ENOTDIR, "scandir", filename);
        if (options.withFileTypes) {
          var list_1 = [];
          for (var name_3 in link3.children) {
            var child = link3.getChild(name_3);
            if (!child) {
              continue;
            }
            list_1.push(Dirent_1.default.build(child, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer")
            list_1.sort(function(a8, b6) {
              if (a8.name < b6.name)
                return -1;
              if (a8.name > b6.name)
                return 1;
              return 0;
            });
          return list_1;
        }
        var list = [];
        for (var name_4 in link3.children) {
          list.push((0, encoding_1.strToEncoding)(name_4, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer")
          list.sort();
        return list;
      };
      Volume2.prototype.readdirSync = function(path2, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path2);
        return this.readdirBase(filename, opts);
      };
      Volume2.prototype.readdir = function(path2, a8, b6) {
        var _a2 = getReaddirOptsAndCb(a8, b6), options = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
      };
      Volume2.prototype.readlinkBase = function(filename, encoding) {
        var link3 = this.getLinkOrThrow(filename, "readlink");
        var node = link3.getNode();
        if (!node.isSymlink())
          throw createError(EINVAL, "readlink", filename);
        var str = sep2 + node.symlink.join(sep2);
        return (0, encoding_1.strToEncoding)(str, encoding);
      };
      Volume2.prototype.readlinkSync = function(path2, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path2);
        return this.readlinkBase(filename, opts.encoding);
      };
      Volume2.prototype.readlink = function(path2, a8, b6) {
        var _a2 = getDefaultOptsAndCb(a8, b6), opts = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
      };
      Volume2.prototype.fsyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fsync");
      };
      Volume2.prototype.fsyncSync = function(fd) {
        this.fsyncBase(fd);
      };
      Volume2.prototype.fsync = function(fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
      };
      Volume2.prototype.fdatasyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fdatasync");
      };
      Volume2.prototype.fdatasyncSync = function(fd) {
        this.fdatasyncBase(fd);
      };
      Volume2.prototype.fdatasync = function(fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
      };
      Volume2.prototype.ftruncateBase = function(fd, len) {
        var file = this.getFileByFdOrThrow(fd, "ftruncate");
        file.truncate(len);
      };
      Volume2.prototype.ftruncateSync = function(fd, len) {
        this.ftruncateBase(fd, len);
      };
      Volume2.prototype.ftruncate = function(fd, a8, b6) {
        var len = typeof a8 === "number" ? a8 : 0;
        var callback = validateCallback(typeof a8 === "number" ? b6 : a8);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
      };
      Volume2.prototype.truncateBase = function(path2, len) {
        var fd = this.openSync(path2, "r+");
        try {
          this.ftruncateSync(fd, len);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.truncateSync = function(id, len) {
        if (isFd(id))
          return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
      };
      Volume2.prototype.truncate = function(id, a8, b6) {
        var len = typeof a8 === "number" ? a8 : 0;
        var callback = validateCallback(typeof a8 === "number" ? b6 : a8);
        if (isFd(id))
          return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
      };
      Volume2.prototype.futimesBase = function(fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, "futimes");
        var node = file.node;
        node.atime = new Date(atime * 1e3);
        node.mtime = new Date(mtime * 1e3);
      };
      Volume2.prototype.futimesSync = function(fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.utimesBase = function(filename, atime, mtime) {
        var fd = this.openSync(filename, "r+");
        try {
          this.futimesBase(fd, atime, mtime);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.utimesSync = function(path2, atime, mtime) {
        this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.mkdirBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        if (!steps.length) {
          throw createError(EEXIST, "mkdir", filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
        var name2 = steps[steps.length - 1];
        if (dir.getChild(name2))
          throw createError(EEXIST, "mkdir", filename);
        dir.createChild(name2, this.createNode(true, modeNum));
      };
      Volume2.prototype.mkdirpBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        var link3 = this.root;
        for (var i7 = 0; i7 < steps.length; i7++) {
          var step = steps[i7];
          if (!link3.getNode().isDirectory())
            throw createError(ENOTDIR, "mkdir", link3.getPath());
          var child = link3.getChild(step);
          if (child) {
            if (child.getNode().isDirectory())
              link3 = child;
            else
              throw createError(ENOTDIR, "mkdir", child.getPath());
          } else {
            link3 = link3.createChild(step, this.createNode(true, modeNum));
          }
        }
      };
      Volume2.prototype.mkdirSync = function(path2, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive)
          this.mkdirpBase(filename, modeNum);
        else
          this.mkdirBase(filename, modeNum);
      };
      Volume2.prototype.mkdir = function(path2, a8, b6) {
        var opts = getMkdirOptions(a8);
        var callback = validateCallback(typeof a8 === "function" ? a8 : b6);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive)
          this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else
          this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
      };
      Volume2.prototype.mkdirpSync = function(path2, mode) {
        this.mkdirSync(path2, {
          mode,
          recursive: true
        });
      };
      Volume2.prototype.mkdirp = function(path2, a8, b6) {
        var mode = typeof a8 === "function" ? void 0 : a8;
        var callback = validateCallback(typeof a8 === "function" ? a8 : b6);
        this.mkdir(path2, {
          mode,
          recursive: true
        }, callback);
      };
      Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
        if (retry === void 0) {
          retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
          this.mkdirBase(
            filename,
            511
            /* DIR */
          );
          return (0, encoding_1.strToEncoding)(filename, encoding);
        } catch (err) {
          if (err.code === EEXIST) {
            if (retry > 1)
              return this.mkdtempBase(prefix, encoding, retry - 1);
            else
              throw Error("Could not create temp dir.");
          } else
            throw err;
        }
      };
      Volume2.prototype.mkdtempSync = function(prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
      };
      Volume2.prototype.mkdtemp = function(prefix, a8, b6) {
        var _a2 = getDefaultOptsAndCb(a8, b6), encoding = _a2[0].encoding, callback = _a2[1];
        if (!prefix || typeof prefix !== "string")
          throw new TypeError("filename prefix is required");
        if (!nullCheck(prefix))
          return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
      };
      Volume2.prototype.rmdirBase = function(filename, options) {
        var opts = getRmdirOptions(options);
        var link3 = this.getLinkAsDirOrThrow(filename, "rmdir");
        if (link3.length && !opts.recursive)
          throw createError(ENOTEMPTY, "rmdir", filename);
        this.deleteLink(link3);
      };
      Volume2.prototype.rmdirSync = function(path2, options) {
        this.rmdirBase(pathToFilename(path2), options);
      };
      Volume2.prototype.rmdir = function(path2, a8, b6) {
        var opts = getRmdirOptions(a8);
        var callback = validateCallback(typeof a8 === "function" ? a8 : b6);
        this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
      };
      Volume2.prototype.fchmodBase = function(fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, "fchmod");
        file.chmod(modeNum);
      };
      Volume2.prototype.fchmodSync = function(fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
      };
      Volume2.prototype.fchmod = function(fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
      };
      Volume2.prototype.chmodBase = function(filename, modeNum) {
        var fd = this.openSync(filename, "r+");
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.chmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.chmodBase(filename, modeNum);
      };
      Volume2.prototype.chmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.lchmodBase = function(filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.lchmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.lchmodBase(filename, modeNum);
      };
      Volume2.prototype.lchmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.fchownBase = function(fd, uid, gid) {
        this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
      };
      Volume2.prototype.fchownSync = function(fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
      };
      Volume2.prototype.fchown = function(fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
      };
      Volume2.prototype.chownBase = function(filename, uid, gid) {
        var link3 = this.getResolvedLinkOrThrow(filename, "chown");
        var node = link3.getNode();
        node.chown(uid, gid);
      };
      Volume2.prototype.chownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.chown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.lchownBase = function(filename, uid, gid) {
        this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
      };
      Volume2.prototype.lchownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.lchown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.watchFile = function(path2, a8, b6) {
        var filename = pathToFilename(path2);
        var options = a8;
        var listener = b6;
        if (typeof options === "function") {
          listener = a8;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number")
            interval = options.interval;
          if (typeof options.persistent === "boolean")
            persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      };
      Volume2.prototype.unwatchFile = function(path2, listener) {
        var filename = pathToFilename(path2);
        var watcher = this.statWatchers[filename];
        if (!watcher)
          return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      };
      Volume2.prototype.createReadStream = function(path2, options) {
        return new this.ReadStream(path2, options);
      };
      Volume2.prototype.createWriteStream = function(path2, options) {
        return new this.WriteStream(path2, options);
      };
      Volume2.prototype.watch = function(path2, options, listener) {
        var filename = pathToFilename(path2);
        var givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
        if (persistent === void 0)
          persistent = true;
        if (recursive === void 0)
          recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      };
      Volume2.fd = 2147483647;
      return Volume2;
    }();
    exports$42.Volume = Volume;
    function emitStop(self2) {
      self2.emit("stop");
    }
    var StatWatcher = function(_super) {
      __extends(StatWatcher2, _super);
      function StatWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this.onInterval = function() {
          try {
            var stats = _this.vol.statSync(_this.filename);
            if (_this.hasChanged(stats)) {
              _this.emit("change", stats, _this.prev);
              _this.prev = stats;
            }
          } finally {
            _this.loop();
          }
        };
        _this.vol = vol2;
        return _this;
      }
      StatWatcher2.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      };
      StatWatcher2.prototype.hasChanged = function(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs)
          return true;
        if (stats.nlink !== this.prev.nlink)
          return true;
        return false;
      };
      StatWatcher2.prototype.start = function(path2, persistent, interval) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (interval === void 0) {
          interval = 5007;
        }
        this.filename = pathToFilename(path2);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global4) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      };
      StatWatcher2.prototype.stop = function() {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
      };
      return StatWatcher2;
    }(events_1.EventEmitter);
    exports$42.StatWatcher = StatWatcher;
    var pool;
    function allocNewPool(poolSize) {
      pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool.used = 0;
    }
    util.inherits(FsReadStream, stream_1.Readable);
    exports$42.ReadStream = FsReadStream;
    function FsReadStream(vol2, path2, options) {
      if (!(this instanceof FsReadStream))
        return new FsReadStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number")
        this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy)
            this.destroy();
        }
      });
    }
    FsReadStream.prototype.open = function() {
      var self2 = this;
      this._vol.open(this.path, this.flags, this.mode, function(er2, fd) {
        if (er2) {
          if (self2.autoClose) {
            if (self2.destroy)
              self2.destroy();
          }
          self2.emit("error", er2);
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2.read();
      });
    };
    FsReadStream.prototype._read = function(n8) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n8);
        });
      }
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool;
      var toRead = Math.min(pool.length - pool.used, n8);
      var start = pool.used;
      if (this.pos !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      var self2 = this;
      this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
      if (this.pos !== void 0)
        this.pos += toRead;
      pool.used += toRead;
      function onread(er2, bytesRead) {
        if (er2) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          self2.emit("error", er2);
        } else {
          var b6 = null;
          if (bytesRead > 0) {
            self2.bytesRead += bytesRead;
            b6 = thisPool.slice(start, start + bytesRead);
          }
          self2.push(b6);
        }
      }
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close(function(err2) {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      var _this = this;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      this.closed = true;
      this._vol.close(this.fd, function(er2) {
        if (er2)
          _this.emit("error", er2);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    util.inherits(FsWriteStream, stream_1.Writable);
    exports$42.WriteStream = FsWriteStream;
    function FsWriteStream(vol2, path2, options) {
      if (!(this instanceof FsWriteStream))
        return new FsWriteStream(vol2, path2, options);
      this._vol = vol2;
      options = Object.assign({}, getOptions(options, {}));
      stream_1.Writable.call(this, options);
      this.path = pathToFilename(path2);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number")
        this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er2, fd) {
        if (er2) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er2);
          return;
        }
        this.fd = fd;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer))
        return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self2 = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, function(er2, bytes) {
        if (er2) {
          if (self2.autoClose && self2.destroy) {
            self2.destroy();
          }
          return cb(er2);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      var self2 = this;
      var len = data.length;
      var chunks = new Array(len);
      var size = 0;
      for (var i7 = 0; i7 < len; i7++) {
        var chunk = data[i7].chunk;
        chunks[i7] = chunk;
        size += chunk.length;
      }
      var buf = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er2, bytes) {
        if (er2) {
          if (self2.destroy)
            self2.destroy();
          return cb(er2);
        }
        self2.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += size;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.close = FsReadStream.prototype.close;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var FSWatcher = function(_super) {
      __extends(FSWatcher2, _super);
      function FSWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this._filename = "";
        _this._filenameEncoded = "";
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._onNodeChange = function() {
          _this._emit("change");
        };
        _this._onParentChild = function(link3) {
          if (link3.getName() === _this._getName()) {
            _this._emit("rename");
          }
        };
        _this._emit = function(type) {
          _this.emit("change", type, _this._filenameEncoded);
        };
        _this._persist = function() {
          _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol2;
        return _this;
      }
      FSWatcher2.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      };
      FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (recursive === void 0) {
          recursive = false;
        }
        if (encoding === void 0) {
          encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path2);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          var error = new Error("watch " + this._filename + " " + err.code);
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        this._link.getNode().on("change", this._onNodeChange);
        this._link.on("child:add", this._onNodeChange);
        this._link.on("child:delete", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.setMaxListeners(parent.getMaxListeners() + 1);
          parent.on("child:delete", this._onParentChild);
        }
        if (persistent)
          this._persist();
      };
      FSWatcher2.prototype.close = function() {
        clearTimeout(this._timer);
        this._link.getNode().removeListener("change", this._onNodeChange);
        var parent = this._link.parent;
        if (parent) {
          parent.removeListener("child:delete", this._onParentChild);
        }
      };
      return FSWatcher2;
    }(events_1.EventEmitter);
    exports$42.FSWatcher = FSWatcher;
    return exports$42;
  }
  function dew$13() {
    if (_dewExec$13)
      return exports$33;
    _dewExec$13 = true;
    Object.defineProperty(exports$33, "__esModule", {
      value: true
    });
    exports$33.fsAsyncMethods = exports$33.fsSyncMethods = exports$33.fsProps = void 0;
    var fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
    exports$33.fsProps = fsProps;
    var fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "createReadStream", "createWriteStream"];
    exports$33.fsSyncMethods = fsSyncMethods;
    var fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "watchFile", "unwatchFile", "watch"];
    exports$33.fsAsyncMethods = fsAsyncMethods;
    return exports$33;
  }
  function dew7() {
    if (_dewExec7)
      return exports$23;
    _dewExec7 = true;
    var __assign = exports$23 && exports$23.__assign || function() {
      __assign = Object.assign || function(t8) {
        for (var s7, i7 = 1, n8 = arguments.length; i7 < n8; i7++) {
          s7 = arguments[i7];
          for (var p8 in s7)
            if (Object.prototype.hasOwnProperty.call(s7, p8))
              t8[p8] = s7[p8];
        }
        return t8;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports$23, "__esModule", {
      value: true
    });
    exports$23.fs = exports$23.createFsFromVolume = exports$23.vol = exports$23.Volume = void 0;
    var Stats_1 = dew$d2();
    var Dirent_1 = dew$92();
    var volume_1 = dew$23();
    var _a = dew$13(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
    var constants_1 = dew$f2();
    var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
    exports$23.Volume = volume_1.Volume;
    exports$23.vol = new volume_1.Volume();
    function createFsFromVolume2(vol2) {
      var fs3 = {
        F_OK: F_OK2,
        R_OK: R_OK2,
        W_OK: W_OK2,
        X_OK: X_OK2,
        constants: constants_1.constants,
        Stats: Stats_1.default,
        Dirent: Dirent_1.default
      };
      for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
        var method = fsAsyncMethods_1[_a2];
        if (typeof vol2[method] === "function")
          fs3[method] = vol2[method].bind(vol2);
      }
      fs3.StatWatcher = vol2.StatWatcher;
      fs3.FSWatcher = vol2.FSWatcher;
      fs3.WriteStream = vol2.WriteStream;
      fs3.ReadStream = vol2.ReadStream;
      fs3.promises = vol2.promises;
      fs3._toUnixTimestamp = volume_1.toUnixTimestamp;
      return fs3;
    }
    exports$23.createFsFromVolume = createFsFromVolume2;
    exports$23.fs = createFsFromVolume2(exports$23.vol);
    exports$23 = __assign(__assign({}, exports$23), exports$23.fs);
    exports$23.semantic = true;
    return exports$23;
  }
  function unimplemented2(name2) {
    throw new Error(`Node.js fs ${name2} is not supported by JSPM core in the browser`);
  }
  function watchStdo(path2, fd, listener) {
    let oldSize = 0;
    const decoder = new TextDecoder();
    vol.watch(path2, "utf8", () => {
      const { size } = vol.fstatSync(fd);
      const buf = Buffer2.alloc(size - oldSize);
      vol.readSync(fd, buf, 0, buf.length, oldSize);
      oldSize = size;
      listener(decoder.decode(buf, { stream: true }));
    });
  }
  function handleFsUrl(url, isSync) {
    if (url.protocol === "file:")
      return fileURLToPath(url);
    if (url.protocol === "https:" || url.protocol === "http:") {
      const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
      if (existsSync(path2))
        return path2;
      if (isSync)
        throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
      return (async () => {
        const res = await fetch(url);
        if (!res.ok)
          throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
        const buf = await res.arrayBuffer();
        writeFileSync(path2, Buffer2.from(buf));
        return path2;
      })();
    }
    throw new Error("URL " + url + " not supported in JSPM FS implementation.");
  }
  function wrapFsSync(fn) {
    return function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(handleFsUrl(path2, true), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsPromise(fn) {
    return async function(path2, ...args) {
      if (path2 instanceof URL)
        return fn(await handleFsUrl(path2), ...args);
      return fn(path2, ...args);
    };
  }
  function wrapFsCallback(fn) {
    return function(path2, ...args) {
      const cb = args[args.length - 1];
      if (path2 instanceof URL && typeof cb === "function") {
        handleFsUrl(path2).then((path3) => {
          fn(path3, ...args);
        }, cb);
      } else {
        fn(path2, ...args);
      }
    };
  }
  var exports$h, _dewExec$f2, exports$g2, _dewExec$e2, exports$f2, _dewExec$d2, exports$e2, _dewExec$c2, exports$d2, _dewExec$b2, _global$3, exports$c2, _dewExec$a2, exports$b2, _dewExec$92, exports$a2, _dewExec$82, _global$22, exports$92, _dewExec$72, exports$82, _dewExec$62, exports$72, _dewExec$52, _global$12, exports$62, _dewExec$42, exports$52, _dewExec$32, exports$42, _dewExec$23, _global4, exports$33, _dewExec$13, exports$23, _dewExec7, exports$15, exports7, vol, createFsFromVolume, fs, appendFile, appendFileSync, access, accessSync, chown, chownSync, chmod, chmodSync, close, closeSync, copyFile, copyFileSync, cp, cpSync, createReadStream, createWriteStream, exists, existsSync, fchown, fchownSync, fchmod, fchmodSync, fdatasync, fdatasyncSync, fstat, fstatSync, fsync, fsyncSync, ftruncate, ftruncateSync, futimes, futimesSync, lchown, lchownSync, lchmod, lchmodSync, link, linkSync, lstat, lstatSync, mkdir, mkdirSync, mkdtemp, mkdtempSync, open, openSync, opendir, opendirSync, readdir, readdirSync, read, readSync, readv, readvSync, readFile, readFileSync, readlink, readlinkSync, realpath, realpathSync, rename, renameSync, rm, rmSync, rmdir, rmdirSync, stat, statSync, symlink, symlinkSync, truncate, truncateSync, unwatchFile, unlink, unlinkSync, utimes, utimesSync, watch, watchFile, writeFile, writeFileSync, write, writeSync, writev, writevSync, Dir, Dirent, Stats, ReadStream, WriteStream, FileReadStream, FileWriteStream, _toUnixTimestamp, F_OK, R_OK, W_OK, X_OK, constants, promises2;
  var init_fs = __esm({
    "node_modules/@jspm/core/nodelibs/browser/fs.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_chunk_44e51b61();
      init_assert2();
      init_util();
      init_chunk_b4205b57();
      init_path();
      init_chunk_2eac56ff();
      init_events();
      init_chunk_4bd36a8f();
      init_stream();
      init_url();
      init_chunk_23dbec7b();
      init_chunk_6c718bbe();
      init_buffer();
      init_chunk_ce0fbc82();
      init_chunk_5decc758();
      init_chunk_4ccc3a29();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      exports$h = {};
      _dewExec$f2 = false;
      exports$g2 = {};
      _dewExec$e2 = false;
      exports$f2 = {};
      _dewExec$d2 = false;
      exports$e2 = {};
      _dewExec$c2 = false;
      exports$d2 = {};
      _dewExec$b2 = false;
      _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$c2 = {};
      _dewExec$a2 = false;
      exports$b2 = {};
      _dewExec$92 = false;
      exports$a2 = {};
      _dewExec$82 = false;
      _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$92 = {};
      _dewExec$72 = false;
      exports$82 = {};
      _dewExec$62 = false;
      exports$72 = {};
      _dewExec$52 = false;
      _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$62 = {};
      _dewExec$42 = false;
      exports$52 = {};
      _dewExec$32 = false;
      exports$42 = {};
      _dewExec$23 = false;
      _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
      exports$33 = {};
      _dewExec$13 = false;
      exports$23 = {};
      _dewExec7 = false;
      exports$15 = dew7();
      exports$15["__esModule"];
      exports$15["fs"];
      exports$15["createFsFromVolume"];
      exports$15["vol"];
      exports$15["Volume"];
      exports$15["semantic"];
      exports7 = dew$23();
      exports7["__esModule"];
      exports7["FSWatcher"];
      exports7["StatWatcher"];
      exports7["Volume"];
      exports7["toUnixTimestamp"];
      exports7["bufferToEncoding"];
      exports7["dataToBuffer"];
      exports7["dataToStr"];
      exports7["pathToSteps"];
      exports7["filenameToSteps"];
      exports7["pathToFilename"];
      exports7["flagsToNumber"];
      exports7["FLAGS"];
      exports7["ReadStream"];
      exports7["WriteStream"];
      ({ vol, createFsFromVolume } = exports$15);
      vol.fromNestedJSON({
        "/dev": { stdin: "", stdout: "", stderr: "" },
        "/usr/bin": {},
        "/home": {},
        "/tmp": {}
      });
      vol.releasedFds = [2, 1, 0];
      vol.openSync("/dev/stdin", "w");
      vol.openSync("/dev/stdout", "r");
      vol.openSync("/dev/stderr", "r");
      watchStdo("/dev/stdout", 1, console.log);
      watchStdo("/dev/stderr", 2, console.error);
      fs = createFsFromVolume(vol);
      fs.opendir = () => unimplemented2("opendir");
      fs.opendirSync = () => unimplemented2("opendirSync");
      fs.promises.opendir = () => unimplemented2("promises.opendir");
      fs.cp = () => unimplemented2("cp");
      fs.cpSync = () => unimplemented2("cpSync");
      fs.promises.cp = () => unimplemented2("promises.cp");
      fs.readv = () => unimplemented2("readv");
      fs.readvSync = () => unimplemented2("readvSync");
      fs.rm = () => unimplemented2("rm");
      fs.rmSync = () => unimplemented2("rmSync");
      fs.promises.rm = () => unimplemented2("promises.rm");
      fs.Dir = () => unimplemented2("Dir");
      fs.promises.watch = () => unimplemented2("promises.watch");
      fs.FileReadStream = fs.ReadStream;
      fs.FileWriteStream = fs.WriteStream;
      fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
      fs.readFile = wrapFsCallback(fs.readFile);
      fs.readFileSync = wrapFsSync(fs.readFileSync);
      ({
        appendFile,
        appendFileSync,
        access,
        accessSync,
        chown,
        chownSync,
        chmod,
        chmodSync,
        close,
        closeSync,
        copyFile,
        copyFileSync,
        cp,
        cpSync,
        createReadStream,
        createWriteStream,
        exists,
        existsSync,
        fchown,
        fchownSync,
        fchmod,
        fchmodSync,
        fdatasync,
        fdatasyncSync,
        fstat,
        fstatSync,
        fsync,
        fsyncSync,
        ftruncate,
        ftruncateSync,
        futimes,
        futimesSync,
        lchown,
        lchownSync,
        lchmod,
        lchmodSync,
        link,
        linkSync,
        lstat,
        lstatSync,
        mkdir,
        mkdirSync,
        mkdtemp,
        mkdtempSync,
        open,
        openSync,
        opendir,
        opendirSync,
        readdir,
        readdirSync,
        read,
        readSync,
        readv,
        readvSync,
        readFile,
        readFileSync,
        readlink,
        readlinkSync,
        realpath,
        realpathSync,
        rename,
        renameSync,
        rm,
        rmSync,
        rmdir,
        rmdirSync,
        stat,
        statSync,
        symlink,
        symlinkSync,
        truncate,
        truncateSync,
        unwatchFile,
        unlink,
        unlinkSync,
        utimes,
        utimesSync,
        watch,
        watchFile,
        writeFile,
        writeFileSync,
        write,
        writeSync,
        writev,
        writevSync,
        Dir,
        Dirent,
        Stats,
        ReadStream,
        WriteStream,
        FileReadStream,
        FileWriteStream,
        _toUnixTimestamp,
        constants: { F_OK, R_OK, W_OK, X_OK },
        constants,
        promises: promises2
      } = fs);
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/fs/promises.js
  var promises_exports = {};
  __export(promises_exports, {
    access: () => access2,
    appendFile: () => appendFile2,
    chmod: () => chmod2,
    chown: () => chown2,
    copyFile: () => copyFile2,
    cp: () => cp2,
    default: () => promises2,
    lchmod: () => lchmod2,
    lchown: () => lchown2,
    link: () => link2,
    lstat: () => lstat2,
    mkdir: () => mkdir2,
    mkdtemp: () => mkdtemp2,
    open: () => open2,
    opendir: () => opendir2,
    readFile: () => readFile2,
    readdir: () => readdir2,
    readlink: () => readlink2,
    realpath: () => realpath2,
    rename: () => rename2,
    rm: () => rm2,
    rmdir: () => rmdir2,
    stat: () => stat2,
    symlink: () => symlink2,
    truncate: () => truncate2,
    unlink: () => unlink2,
    utimes: () => utimes2,
    watch: () => watch2,
    writeFile: () => writeFile2
  });
  var access2, copyFile2, cp2, open2, opendir2, rename2, truncate2, rm2, rmdir2, mkdir2, readdir2, readlink2, symlink2, lstat2, stat2, link2, unlink2, chmod2, lchmod2, lchown2, chown2, utimes2, realpath2, mkdtemp2, writeFile2, appendFile2, readFile2, watch2;
  var init_promises = __esm({
    "node_modules/@jspm/core/nodelibs/browser/fs/promises.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_fs();
      init_fs();
      init_chunk_44e51b61();
      init_chunk_4bd36a8f();
      init_chunk_ce0fbc82();
      init_chunk_b4205b57();
      init_chunk_5decc758();
      init_chunk_2eac56ff();
      init_chunk_4ccc3a29();
      init_assert2();
      init_util();
      init_path();
      init_chunk_23dbec7b();
      init_events();
      init_stream();
      init_chunk_6c718bbe();
      init_url();
      init_chunk_924bb2e1();
      init_chunk_b04e620d();
      init_buffer();
      ({
        access: access2,
        copyFile: copyFile2,
        cp: cp2,
        open: open2,
        opendir: opendir2,
        rename: rename2,
        truncate: truncate2,
        rm: rm2,
        rmdir: rmdir2,
        mkdir: mkdir2,
        readdir: readdir2,
        readlink: readlink2,
        symlink: symlink2,
        lstat: lstat2,
        stat: stat2,
        link: link2,
        unlink: unlink2,
        chmod: chmod2,
        lchmod: lchmod2,
        lchown: lchown2,
        chown: chown2,
        utimes: utimes2,
        realpath: realpath2,
        mkdtemp: mkdtemp2,
        writeFile: writeFile2,
        appendFile: appendFile2,
        readFile: readFile2,
        watch: watch2
      } = promises2);
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js
  function createEvaluationError(details) {
    let name2;
    let message;
    if (!details.exception) {
      name2 = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name2 = detail.name;
      message = detail.message;
    }
    const messageHeight = message.split("\n").length;
    const error = new Error(message);
    error.name = name2;
    const stackLines = error.stack.split("\n");
    const messageLines = stackLines.splice(0, messageHeight);
    stackLines.shift();
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  function createClientError(details) {
    let name2;
    let message;
    if (!details.exception) {
      name2 = "Error";
      message = details.text;
    } else if ((details.exception.type !== "object" || details.exception.subtype !== "error") && !details.exception.objectId) {
      return valueFromRemoteObject(details.exception);
    } else {
      const detail = getErrorDetails(details);
      name2 = detail.name;
      message = detail.message;
    }
    const error = new Error(message);
    error.name = name2;
    const messageHeight = error.message.split("\n").length;
    const messageLines = error.stack.split("\n").splice(0, messageHeight);
    const stackLines = [];
    if (details.stackTrace) {
      for (const frame of details.stackTrace.callFrames) {
        stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber + 1}:${frame.columnNumber + 1})`);
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [...messageLines, ...stackLines].join("\n");
    return error;
  }
  function valueFromRemoteObject(remoteObject) {
    assert2(!remoteObject.objectId, "Cannot extract value when objectId is given");
    if (remoteObject.unserializableValue) {
      if (remoteObject.type === "bigint") {
        return BigInt(remoteObject.unserializableValue.replace("n", ""));
      }
      switch (remoteObject.unserializableValue) {
        case "-0":
          return -0;
        case "NaN":
          return NaN;
        case "Infinity":
          return Infinity;
        case "-Infinity":
          return -Infinity;
        default:
          throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
      }
    }
    return remoteObject.value;
  }
  function evaluationString(fun, ...args) {
    if (isString3(fun)) {
      assert2(args.length === 0, "Cannot evaluate a string with arguments");
      return fun;
    }
    function serializeArgument(arg) {
      if (Object.is(arg, void 0)) {
        return "undefined";
      }
      return JSON.stringify(arg);
    }
    return `(${fun})(${args.map(serializeArgument).join(",")})`;
  }
  function addPageBinding(type, name2) {
    const callCdp = globalThis[name2];
    if (callCdp[Symbol.toStringTag] === "PuppeteerBinding") {
      return;
    }
    Object.assign(globalThis, {
      [name2](...args) {
        const callPuppeteer = globalThis[name2];
        callPuppeteer.args ??= /* @__PURE__ */ new Map();
        callPuppeteer.callbacks ??= /* @__PURE__ */ new Map();
        const seq = (callPuppeteer.lastSeq ?? 0) + 1;
        callPuppeteer.lastSeq = seq;
        callPuppeteer.args.set(seq, args);
        callCdp(JSON.stringify({
          type,
          name: name2,
          seq,
          args,
          isTrivial: !args.some((value) => {
            return value instanceof Node;
          })
        }));
        return new Promise((resolve3, reject) => {
          callPuppeteer.callbacks.set(seq, {
            resolve(value) {
              callPuppeteer.args.delete(seq);
              resolve3(value);
            },
            reject(value) {
              callPuppeteer.args.delete(seq);
              reject(value);
            }
          });
        });
      }
    });
    globalThis[name2][Symbol.toStringTag] = "PuppeteerBinding";
  }
  function pageBindingInitString(type, name2) {
    return evaluationString(addPageBinding, type, name2);
  }
  async function importFSPromises() {
    if (!fs2) {
      try {
        fs2 = await Promise.resolve().then(() => (init_promises(), promises_exports));
      } catch (error) {
        if (error instanceof TypeError) {
          throw new Error("Cannot write to a path outside of a Node-like environment.");
        }
        throw error;
      }
    }
    return fs2;
  }
  async function getReadableAsBuffer(readable, path2) {
    const buffers = [];
    if (path2) {
      const fs3 = await importFSPromises();
      const fileHandle = await fs3.open(path2, "w+");
      try {
        for await (const chunk of readable) {
          buffers.push(chunk);
          await fileHandle.writeFile(chunk);
        }
      } finally {
        await fileHandle.close();
      }
    } else {
      for await (const chunk of readable) {
        buffers.push(chunk);
      }
    }
    try {
      return Buffer2.concat(buffers);
    } catch (error) {
      return null;
    }
  }
  async function getReadableFromProtocolStream(client, handle) {
    if (!isNode) {
      throw new Error("Cannot create a stream outside of Node.js environment.");
    }
    const { Readable: Readable2 } = await Promise.resolve().then(() => (init_stream(), stream_exports));
    let eof = false;
    return new Readable2({
      async read(size) {
        if (eof) {
          return;
        }
        try {
          const response = await client.send("IO.read", { handle, size });
          this.push(response.data, response.base64Encoded ? "base64" : void 0);
          if (response.eof) {
            eof = true;
            await client.send("IO.close", { handle });
            this.push(null);
          }
        } catch (error) {
          if (isErrorLike(error)) {
            this.destroy(error);
            return;
          }
          throw error;
        }
      }
    });
  }
  function getPageContent() {
    let content = "";
    for (const node of document.childNodes) {
      switch (node) {
        case document.documentElement:
          content += document.documentElement.outerHTML;
          break;
        default:
          content += new XMLSerializer().serializeToString(node);
          break;
      }
    }
    return content;
  }
  function validateDialogType(type) {
    let dialogType = null;
    const validDialogTypes = /* @__PURE__ */ new Set([
      "alert",
      "confirm",
      "prompt",
      "beforeunload"
    ]);
    if (validDialogTypes.has(type)) {
      dialogType = type;
    }
    assert2(dialogType, `Unknown javascript dialog type: ${type}`);
    return dialogType;
  }
  function timeout(ms) {
    return ms === 0 ? ve : H(ms).pipe(k(() => {
      throw new TimeoutError(`Timed out after waiting ${ms}ms`);
    }));
  }
  function getSourceUrlComment(url) {
    return `//# sourceURL=${url}`;
  }
  async function waitForHTTP(networkManager, eventName, urlOrPredicate, ms, cancelation) {
    return await fe(xr(networkManager, eventName).pipe(Au(async (http) => {
      if (isString3(urlOrPredicate)) {
        return urlOrPredicate === http.url();
      }
      if (typeof urlOrPredicate === "function") {
        return !!await urlOrPredicate(http);
      }
      return false;
    }), Oe(timeout(ms), j(cancelation.valueOrThrow()))));
  }
  var debugError, DEFAULT_VIEWPORT, getErrorDetails, SOURCE_URL, PuppeteerURL, withSourcePuppeteerURLIfNone, getSourcePuppeteerURLIfAvailable, isString3, isNumber3, isPlainObject, isRegExp3, isDate3, fs2, UTILITY_WORLD_NAME, SOURCE_URL_REGEX, NETWORK_IDLE_TIME;
  var init_util2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/util.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_environment();
      init_assert();
      init_ErrorLike();
      init_Debug();
      init_Errors();
      debugError = debug("puppeteer:error");
      DEFAULT_VIEWPORT = Object.freeze({ width: 800, height: 600 });
      getErrorDetails = (details) => {
        let name2 = "";
        let message;
        const lines = details.exception?.description?.split("\n    at ") ?? [];
        const size = Math.min(details.stackTrace?.callFrames.length ?? 0, lines.length - 1);
        lines.splice(-size, size);
        if (details.exception?.className) {
          name2 = details.exception.className;
        }
        message = lines.join("\n");
        if (name2 && message.startsWith(`${name2}: `)) {
          message = message.slice(name2.length + 2);
        }
        return { message, name: name2 };
      };
      SOURCE_URL = Symbol("Source URL for Puppeteer evaluation scripts");
      PuppeteerURL = class _PuppeteerURL {
        static INTERNAL_URL = "pptr:internal";
        static fromCallSite(functionName, site) {
          const url = new _PuppeteerURL();
          url.#functionName = functionName;
          url.#siteString = site.toString();
          return url;
        }
        static parse = (url) => {
          url = url.slice("pptr:".length);
          const [functionName = "", siteString = ""] = url.split(";");
          const puppeteerUrl = new _PuppeteerURL();
          puppeteerUrl.#functionName = functionName;
          puppeteerUrl.#siteString = decodeURIComponent(siteString);
          return puppeteerUrl;
        };
        static isPuppeteerURL = (url) => {
          return url.startsWith("pptr:");
        };
        #functionName;
        #siteString;
        get functionName() {
          return this.#functionName;
        }
        get siteString() {
          return this.#siteString;
        }
        toString() {
          return `pptr:${[
            this.#functionName,
            encodeURIComponent(this.#siteString)
          ].join(";")}`;
        }
      };
      withSourcePuppeteerURLIfNone = (functionName, object) => {
        if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
          return object;
        }
        const original = Error.prepareStackTrace;
        Error.prepareStackTrace = (_5, stack) => {
          return stack[2];
        };
        const site = new Error().stack;
        Error.prepareStackTrace = original;
        return Object.assign(object, {
          [SOURCE_URL]: PuppeteerURL.fromCallSite(functionName, site)
        });
      };
      getSourcePuppeteerURLIfAvailable = (object) => {
        if (Object.prototype.hasOwnProperty.call(object, SOURCE_URL)) {
          return object[SOURCE_URL];
        }
        return void 0;
      };
      isString3 = (obj) => {
        return typeof obj === "string" || obj instanceof String;
      };
      isNumber3 = (obj) => {
        return typeof obj === "number" || obj instanceof Number;
      };
      isPlainObject = (obj) => {
        return typeof obj === "object" && obj?.constructor === Object;
      };
      isRegExp3 = (obj) => {
        return typeof obj === "object" && obj?.constructor === RegExp;
      };
      isDate3 = (obj) => {
        return typeof obj === "object" && obj?.constructor === Date;
      };
      fs2 = null;
      UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
      SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
      NETWORK_IDLE_TIME = 500;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js
  function createIncrementalIdGenerator() {
    let id = 0;
    return () => {
      return ++id;
    };
  }
  var CallbackRegistry, Callback;
  var init_CallbackRegistry = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Deferred();
      init_ErrorLike();
      init_Errors();
      init_util2();
      CallbackRegistry = class {
        #callbacks = /* @__PURE__ */ new Map();
        #idGenerator = createIncrementalIdGenerator();
        create(label, timeout2, request) {
          const callback = new Callback(this.#idGenerator(), label, timeout2);
          this.#callbacks.set(callback.id, callback);
          try {
            request(callback.id);
          } catch (error) {
            callback.promise.valueOrThrow().catch(debugError).finally(() => {
              this.#callbacks.delete(callback.id);
            });
            callback.reject(error);
            throw error;
          }
          return callback.promise.valueOrThrow().finally(() => {
            this.#callbacks.delete(callback.id);
          });
        }
        reject(id, message, originalMessage) {
          const callback = this.#callbacks.get(id);
          if (!callback) {
            return;
          }
          this._reject(callback, message, originalMessage);
        }
        _reject(callback, errorMessage, originalMessage) {
          let error;
          let message;
          if (errorMessage instanceof ProtocolError) {
            error = errorMessage;
            error.cause = callback.error;
            message = errorMessage.message;
          } else {
            error = callback.error;
            message = errorMessage;
          }
          callback.reject(rewriteError(error, `Protocol error (${callback.label}): ${message}`, originalMessage));
        }
        resolve(id, value) {
          const callback = this.#callbacks.get(id);
          if (!callback) {
            return;
          }
          callback.resolve(value);
        }
        clear() {
          for (const callback of this.#callbacks.values()) {
            this._reject(callback, new TargetCloseError("Target closed"));
          }
          this.#callbacks.clear();
        }
      };
      Callback = class {
        #id;
        #error = new ProtocolError();
        #deferred = Deferred.create();
        #timer;
        #label;
        constructor(id, label, timeout2) {
          this.#id = id;
          this.#label = label;
          if (timeout2) {
            this.#timer = setTimeout(() => {
              this.#deferred.reject(rewriteError(this.#error, `${label} timed out. Increase the 'protocolTimeout' setting in launch/connect calls for a higher timeout if needed.`));
            }, timeout2);
          }
        }
        resolve(value) {
          clearTimeout(this.#timer);
          this.#deferred.resolve(value);
        }
        reject(error) {
          clearTimeout(this.#timer);
          this.#deferred.reject(error);
        }
        get id() {
          return this.#id;
        }
        get promise() {
          return this.#deferred;
        }
        get error() {
          return this.#error;
        }
        get label() {
          return this.#label;
        }
      };
    }
  });

  // node_modules/mitt/dist/mitt.mjs
  var mitt_exports = {};
  __export(mitt_exports, {
    default: () => mitt_default
  });
  function mitt_default(n8) {
    return { all: n8 = n8 || /* @__PURE__ */ new Map(), on: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 ? i7.push(e9) : n8.set(t8, [e9]);
    }, off: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 && (e9 ? i7.splice(i7.indexOf(e9) >>> 0, 1) : n8.set(t8, []));
    }, emit: function(t8, e9) {
      var i7 = n8.get(t8);
      i7 && i7.slice().map(function(n9) {
        n9(e9);
      }), (i7 = n8.get("*")) && i7.slice().map(function(n9) {
        n9(t8, e9);
      });
    } };
  }
  var init_mitt2 = __esm({
    "node_modules/mitt/dist/mitt.mjs"() {
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js
  var require_EventEmitter = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/EventEmitter.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __importDefault = exports8 && exports8.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.EventEmitter = void 0;
      var mitt_1 = __importDefault((init_mitt2(), __toCommonJS(mitt_exports)));
      var EventEmitter4 = class {
        #emitter = (0, mitt_1.default)();
        on(type, handler) {
          this.#emitter.on(type, handler);
          return this;
        }
        /**
         * Like `on` but the listener will only be fired once and then it will be removed.
         * @param event The event you'd like to listen to
         * @param handler The handler function to run when the event occurs
         * @return `this` to enable chaining method calls.
         */
        once(event, handler) {
          const onceHandler = (eventData) => {
            handler(eventData);
            this.off(event, onceHandler);
          };
          return this.on(event, onceHandler);
        }
        off(type, handler) {
          this.#emitter.off(type, handler);
          return this;
        }
        /**
         * Emits an event and call any associated listeners.
         *
         * @param event The event to emit.
         * @param eventData Any data to emit with the event.
         * @return `true` if there are any listeners, `false` otherwise.
         */
        emit(event, eventData) {
          this.#emitter.emit(event, eventData);
        }
        /**
         * Removes all listeners. If given an event argument, it will remove only
         * listeners for that event.
         * @param event - the event to remove listeners for.
         * @returns `this` to enable you to chain method calls.
         */
        removeAllListeners(event) {
          if (event) {
            this.#emitter.all.delete(event);
          } else {
            this.#emitter.all.clear();
          }
          return this;
        }
      };
      exports8.EventEmitter = EventEmitter4;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/log.js
  var require_log = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/log.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.LogType = void 0;
      var LogType;
      (function(LogType2) {
        LogType2["bidi"] = "bidi";
        LogType2["cdp"] = "cdp";
        LogType2["debug"] = "debug";
        LogType2["debugError"] = "debug:error";
        LogType2["debugInfo"] = "debug:info";
      })(LogType || (exports8.LogType = LogType = {}));
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js
  var require_ProcessingQueue = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/ProcessingQueue.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ProcessingQueue = void 0;
      var log_js_1 = require_log();
      var ProcessingQueue = class _ProcessingQueue {
        static LOGGER_PREFIX = `${log_js_1.LogType.debug}:queue`;
        #logger;
        #processor;
        #queue = [];
        // Flag to keep only 1 active processor.
        #isProcessing = false;
        constructor(processor, logger) {
          this.#processor = processor;
          this.#logger = logger;
        }
        add(entry, name2) {
          this.#queue.push([entry, name2]);
          void this.#processIfNeeded();
        }
        async #processIfNeeded() {
          if (this.#isProcessing) {
            return;
          }
          this.#isProcessing = true;
          while (this.#queue.length > 0) {
            const arrayEntry = this.#queue.shift();
            if (!arrayEntry) {
              continue;
            }
            const [entryPromise, name2] = arrayEntry;
            this.#logger?.(_ProcessingQueue.LOGGER_PREFIX, "Processing event:", name2);
            await entryPromise.then((entry) => {
              if (entry.kind === "error") {
                this.#logger?.(log_js_1.LogType.debugError, "Event threw before sending:", entry.error.message, entry.error.stack);
                return;
              }
              return this.#processor(entry.value);
            }).catch((error) => {
              this.#logger?.(log_js_1.LogType.debugError, "Event was not processed:", error?.message);
            });
          }
          this.#isProcessing = false;
        }
      };
      exports8.ProcessingQueue = ProcessingQueue;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/protocol/cdp.js
  var require_cdp = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/protocol/cdp.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
    }
  });

  // node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js
  var require_chromium_bidi = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/protocol/chromium-bidi.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.EVENT_NAMES = exports8.Network = exports8.BrowsingContext = exports8.Log = exports8.Script = exports8.BiDiModule = void 0;
      var BiDiModule;
      (function(BiDiModule2) {
        BiDiModule2["Browser"] = "browser";
        BiDiModule2["BrowsingContext"] = "browsingContext";
        BiDiModule2["Cdp"] = "cdp";
        BiDiModule2["Input"] = "input";
        BiDiModule2["Log"] = "log";
        BiDiModule2["Network"] = "network";
        BiDiModule2["Script"] = "script";
        BiDiModule2["Session"] = "session";
      })(BiDiModule || (exports8.BiDiModule = BiDiModule = {}));
      var Script;
      (function(Script2) {
        let EventNames;
        (function(EventNames2) {
          EventNames2["Message"] = "script.message";
          EventNames2["RealmCreated"] = "script.realmCreated";
          EventNames2["RealmDestroyed"] = "script.realmDestroyed";
        })(EventNames = Script2.EventNames || (Script2.EventNames = {}));
      })(Script || (exports8.Script = Script = {}));
      var Log;
      (function(Log2) {
        let EventNames;
        (function(EventNames2) {
          EventNames2["LogEntryAdded"] = "log.entryAdded";
        })(EventNames = Log2.EventNames || (Log2.EventNames = {}));
      })(Log || (exports8.Log = Log = {}));
      var BrowsingContext2;
      (function(BrowsingContext3) {
        let EventNames;
        (function(EventNames2) {
          EventNames2["ContextCreated"] = "browsingContext.contextCreated";
          EventNames2["ContextDestroyed"] = "browsingContext.contextDestroyed";
          EventNames2["DomContentLoaded"] = "browsingContext.domContentLoaded";
          EventNames2["DownloadWillBegin"] = "browsingContext.downloadWillBegin";
          EventNames2["FragmentNavigated"] = "browsingContext.fragmentNavigated";
          EventNames2["Load"] = "browsingContext.load";
          EventNames2["NavigationAborted"] = "browsingContext.navigationAborted";
          EventNames2["NavigationFailed"] = "browsingContext.navigationFailed";
          EventNames2["NavigationStarted"] = "browsingContext.navigationStarted";
          EventNames2["UserPromptClosed"] = "browsingContext.userPromptClosed";
          EventNames2["UserPromptOpened"] = "browsingContext.userPromptOpened";
        })(EventNames = BrowsingContext3.EventNames || (BrowsingContext3.EventNames = {}));
      })(BrowsingContext2 || (exports8.BrowsingContext = BrowsingContext2 = {}));
      var Network;
      (function(Network2) {
        let EventNames;
        (function(EventNames2) {
          EventNames2["AuthRequired"] = "network.authRequired";
          EventNames2["BeforeRequestSent"] = "network.beforeRequestSent";
          EventNames2["FetchError"] = "network.fetchError";
          EventNames2["ResponseCompleted"] = "network.responseCompleted";
          EventNames2["ResponseStarted"] = "network.responseStarted";
        })(EventNames = Network2.EventNames || (Network2.EventNames = {}));
      })(Network || (exports8.Network = Network = {}));
      exports8.EVENT_NAMES = /* @__PURE__ */ new Set([
        // keep-sorted start
        ...Object.values(BiDiModule),
        ...Object.values(BrowsingContext2.EventNames),
        ...Object.values(Log.EventNames),
        ...Object.values(Network.EventNames),
        ...Object.values(Script.EventNames)
        // keep-sorted end
      ]);
    }
  });

  // node_modules/chromium-bidi/lib/cjs/protocol/webdriver-bidi.js
  var require_webdriver_bidi = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/protocol/webdriver-bidi.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
    }
  });

  // node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js
  var require_ErrorResponse = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/protocol/ErrorResponse.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.UnsupportedOperationException = exports8.UnableToCloseBrowserException = exports8.UnableToCaptureScreenException = exports8.UnknownErrorException = exports8.UnknownCommandException = exports8.SessionNotCreatedException = exports8.NoSuchScriptException = exports8.NoSuchRequestException = exports8.NoSuchNodeException = exports8.NoSuchInterceptException = exports8.NoSuchHistoryEntryException = exports8.NoSuchHandleException = exports8.NoSuchFrameException = exports8.NoSuchElementException = exports8.NoSuchAlertException = exports8.MoveTargetOutOfBoundsException = exports8.InvalidSessionIdException = exports8.InvalidArgumentException = exports8.Exception = void 0;
      var Exception = class {
        error;
        message;
        stacktrace;
        constructor(error, message, stacktrace) {
          this.error = error;
          this.message = message;
          this.stacktrace = stacktrace;
        }
        toErrorResponse(commandId) {
          return {
            type: "error",
            id: commandId,
            error: this.error,
            message: this.message,
            stacktrace: this.stacktrace
          };
        }
      };
      exports8.Exception = Exception;
      var InvalidArgumentException = class extends Exception {
        constructor(message, stacktrace) {
          super("invalid argument", message, stacktrace);
        }
      };
      exports8.InvalidArgumentException = InvalidArgumentException;
      var InvalidSessionIdException = class extends Exception {
        constructor(message, stacktrace) {
          super("invalid session id", message, stacktrace);
        }
      };
      exports8.InvalidSessionIdException = InvalidSessionIdException;
      var MoveTargetOutOfBoundsException = class extends Exception {
        constructor(message, stacktrace) {
          super("move target out of bounds", message, stacktrace);
        }
      };
      exports8.MoveTargetOutOfBoundsException = MoveTargetOutOfBoundsException;
      var NoSuchAlertException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such alert", message, stacktrace);
        }
      };
      exports8.NoSuchAlertException = NoSuchAlertException;
      var NoSuchElementException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such element", message, stacktrace);
        }
      };
      exports8.NoSuchElementException = NoSuchElementException;
      var NoSuchFrameException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such frame", message, stacktrace);
        }
      };
      exports8.NoSuchFrameException = NoSuchFrameException;
      var NoSuchHandleException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such handle", message, stacktrace);
        }
      };
      exports8.NoSuchHandleException = NoSuchHandleException;
      var NoSuchHistoryEntryException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such history entry", message, stacktrace);
        }
      };
      exports8.NoSuchHistoryEntryException = NoSuchHistoryEntryException;
      var NoSuchInterceptException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such intercept", message, stacktrace);
        }
      };
      exports8.NoSuchInterceptException = NoSuchInterceptException;
      var NoSuchNodeException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such node", message, stacktrace);
        }
      };
      exports8.NoSuchNodeException = NoSuchNodeException;
      var NoSuchRequestException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such request", message, stacktrace);
        }
      };
      exports8.NoSuchRequestException = NoSuchRequestException;
      var NoSuchScriptException = class extends Exception {
        constructor(message, stacktrace) {
          super("no such script", message, stacktrace);
        }
      };
      exports8.NoSuchScriptException = NoSuchScriptException;
      var SessionNotCreatedException = class extends Exception {
        constructor(message, stacktrace) {
          super("session not created", message, stacktrace);
        }
      };
      exports8.SessionNotCreatedException = SessionNotCreatedException;
      var UnknownCommandException = class extends Exception {
        constructor(message, stacktrace) {
          super("unknown command", message, stacktrace);
        }
      };
      exports8.UnknownCommandException = UnknownCommandException;
      var UnknownErrorException = class extends Exception {
        constructor(message, stacktrace = new Error().stack) {
          super("unknown error", message, stacktrace);
        }
      };
      exports8.UnknownErrorException = UnknownErrorException;
      var UnableToCaptureScreenException = class extends Exception {
        constructor(message, stacktrace) {
          super("unable to capture screen", message, stacktrace);
        }
      };
      exports8.UnableToCaptureScreenException = UnableToCaptureScreenException;
      var UnableToCloseBrowserException = class extends Exception {
        constructor(message, stacktrace) {
          super("unable to close browser", message, stacktrace);
        }
      };
      exports8.UnableToCloseBrowserException = UnableToCloseBrowserException;
      var UnsupportedOperationException = class extends Exception {
        constructor(message, stacktrace) {
          super("unsupported operation", message, stacktrace);
        }
      };
      exports8.UnsupportedOperationException = UnsupportedOperationException;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/protocol/protocol.js
  var require_protocol = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/protocol/protocol.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __createBinding = exports8 && exports8.__createBinding || (Object.create ? function(o8, m6, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        var desc = Object.getOwnPropertyDescriptor(m6, k5);
        if (!desc || ("get" in desc ? !m6.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m6[k5];
          } };
        }
        Object.defineProperty(o8, k22, desc);
      } : function(o8, m6, k5, k22) {
        if (k22 === void 0)
          k22 = k5;
        o8[k22] = m6[k5];
      });
      var __setModuleDefault = exports8 && exports8.__setModuleDefault || (Object.create ? function(o8, v7) {
        Object.defineProperty(o8, "default", { enumerable: true, value: v7 });
      } : function(o8, v7) {
        o8["default"] = v7;
      });
      var __importStar = exports8 && exports8.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k5 in mod)
            if (k5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k5))
              __createBinding(result, mod, k5);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports8 && exports8.__exportStar || function(m6, exports9) {
        for (var p8 in m6)
          if (p8 !== "default" && !Object.prototype.hasOwnProperty.call(exports9, p8))
            __createBinding(exports9, m6, p8);
      };
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ChromiumBidi = exports8.Cdp = void 0;
      exports8.Cdp = __importStar(require_cdp());
      exports8.ChromiumBidi = __importStar(require_chromium_bidi());
      __exportStar(require_webdriver_bidi(), exports8);
      __exportStar(require_ErrorResponse(), exports8);
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js
  var require_BidiNoOpParser = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiNoOpParser.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.BidiNoOpParser = void 0;
      var BidiNoOpParser = class {
        // Browsing Context domain
        // keep-sorted start block=yes
        parseActivateParams(params) {
          return params;
        }
        parseCaptureScreenshotParams(params) {
          return params;
        }
        parseCloseParams(params) {
          return params;
        }
        parseCreateParams(params) {
          return params;
        }
        parseGetTreeParams(params) {
          return params;
        }
        parseHandleUserPromptParams(params) {
          return params;
        }
        parseNavigateParams(params) {
          return params;
        }
        parsePrintParams(params) {
          return params;
        }
        parseReloadParams(params) {
          return params;
        }
        parseSetViewportParams(params) {
          return params;
        }
        parseTraverseHistoryParams(params) {
          return params;
        }
        // keep-sorted end
        // CDP domain
        // keep-sorted start block=yes
        parseGetSessionParams(params) {
          return params;
        }
        parseSendCommandParams(params) {
          return params;
        }
        // keep-sorted end
        // Script domain
        // keep-sorted start block=yes
        parseAddPreloadScriptParams(params) {
          return params;
        }
        parseCallFunctionParams(params) {
          return params;
        }
        parseDisownParams(params) {
          return params;
        }
        parseEvaluateParams(params) {
          return params;
        }
        parseGetRealmsParams(params) {
          return params;
        }
        parseRemovePreloadScriptParams(params) {
          return params;
        }
        // keep-sorted end
        // Input domain
        // keep-sorted start block=yes
        parsePerformActionsParams(params) {
          return params;
        }
        parseReleaseActionsParams(params) {
          return params;
        }
        // keep-sorted end
        // Network domain
        // keep-sorted start block=yes
        parseAddInterceptParams(params) {
          return params;
        }
        parseContinueRequestParams(params) {
          return params;
        }
        parseContinueResponseParams(params) {
          return params;
        }
        parseContinueWithAuthParams(params) {
          return params;
        }
        parseFailRequestParams(params) {
          return params;
        }
        parseProvideResponseParams(params) {
          return params;
        }
        parseRemoveInterceptParams(params) {
          return params;
        }
        // keep-sorted end
        // Session domain
        // keep-sorted start block=yes
        parseSubscribeParams(params) {
          return params;
        }
      };
      exports8.BidiNoOpParser = BidiNoOpParser;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/browser/BrowserProcessor.js
  var require_BrowserProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/browser/BrowserProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.BrowserProcessor = void 0;
      var BrowserProcessor = class {
        #browserCdpClient;
        constructor(browserCdpClient) {
          this.#browserCdpClient = browserCdpClient;
        }
        close() {
          setTimeout(() => this.#browserCdpClient.sendCommand("Browser.close"), 0);
          return {};
        }
      };
      exports8.BrowserProcessor = BrowserProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/cdp/CdpProcessor.js
  var require_CdpProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/cdp/CdpProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.CdpProcessor = void 0;
      var CdpProcessor = class {
        #browsingContextStorage;
        #cdpConnection;
        #browserCdpClient;
        constructor(browsingContextStorage, cdpConnection, browserCdpClient) {
          this.#browsingContextStorage = browsingContextStorage;
          this.#cdpConnection = cdpConnection;
          this.#browserCdpClient = browserCdpClient;
        }
        getSession(params) {
          const context = params.context;
          const sessionId = this.#browsingContextStorage.getContext(context).cdpTarget.cdpSessionId;
          if (sessionId === void 0) {
            return {};
          }
          return { session: sessionId };
        }
        async sendCommand(params) {
          const client = params.session ? this.#cdpConnection.getCdpClient(params.session) : this.#browserCdpClient;
          const result = await client.sendCommand(params.method, params.params);
          return {
            result,
            session: params.session
          };
        }
      };
      exports8.CdpProcessor = CdpProcessor;
    }
  });

  // node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js
  var empty_exports = {};
  __export(empty_exports, {
    default: () => empty_default
  });
  var empty_default;
  var init_empty = __esm({
    "node_modules/esbuild-plugin-polyfill-node/polyfills/empty.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      empty_default = {};
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/uuid.js
  var require_uuid = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/uuid.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.uuidv4 = void 0;
      function uuidv42() {
        if ("crypto" in globalThis && "randomUUID" in globalThis.crypto) {
          return globalThis.crypto.randomUUID();
        }
        const randomValues = new Uint8Array(16);
        if ("crypto" in globalThis && "getRandomValues" in globalThis.crypto) {
          globalThis.crypto.getRandomValues(randomValues);
        } else {
          (init_empty(), __toCommonJS(empty_exports)).webcrypto.getRandomValues(randomValues);
        }
        randomValues[6] = randomValues[6] & 15 | 64;
        randomValues[8] = randomValues[8] & 63 | 128;
        const bytesToHex = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, "0"), "");
        return [
          bytesToHex(randomValues.subarray(0, 4)),
          bytesToHex(randomValues.subarray(4, 6)),
          bytesToHex(randomValues.subarray(6, 8)),
          bytesToHex(randomValues.subarray(8, 10)),
          bytesToHex(randomValues.subarray(10, 16))
        ].join("-");
      }
      exports8.uuidv4 = uuidv42;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/ChannelProxy.js
  var require_ChannelProxy = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/ChannelProxy.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ChannelProxy = void 0;
      var protocol_js_1 = require_protocol();
      var log_js_1 = require_log();
      var uuid_js_1 = require_uuid();
      var ChannelProxy = class _ChannelProxy {
        #properties;
        #id = (0, uuid_js_1.uuidv4)();
        #logger;
        constructor(channel, logger) {
          this.#properties = channel;
          this.#logger = logger;
        }
        /**
         * Creates a channel proxy in the given realm, initialises listener and
         * returns a handle to `sendMessage` delegate.
         */
        async init(realm, eventManager) {
          const channelHandle = await _ChannelProxy.#createAndGetHandleInRealm(realm);
          const sendMessageHandle = await _ChannelProxy.#createSendMessageHandle(realm, channelHandle);
          void this.#startListener(realm, channelHandle, eventManager);
          return sendMessageHandle;
        }
        /** Gets a ChannelProxy from window and returns its handle. */
        async startListenerFromWindow(realm, eventManager) {
          try {
            const channelHandle = await this.#getHandleFromWindow(realm);
            void this.#startListener(realm, channelHandle, eventManager);
          } catch (error) {
            this.#logger?.(log_js_1.LogType.debugError, error);
          }
        }
        /**
         * Evaluation string which creates a ChannelProxy object on the client side.
         */
        static #createChannelProxyEvalStr() {
          const functionStr = String(() => {
            const queue2 = [];
            let queueNonEmptyResolver = null;
            return {
              /**
               * Gets a promise, which is resolved as soon as a message occurs
               * in the queue.
               */
              async getMessage() {
                const onMessage = queue2.length > 0 ? Promise.resolve() : new Promise((resolve3) => {
                  queueNonEmptyResolver = resolve3;
                });
                await onMessage;
                return queue2.shift();
              },
              /**
               * Adds a message to the queue.
               * Resolves the pending promise if needed.
               */
              sendMessage(message) {
                queue2.push(message);
                if (queueNonEmptyResolver !== null) {
                  queueNonEmptyResolver();
                  queueNonEmptyResolver = null;
                }
              }
            };
          });
          return `(${functionStr})()`;
        }
        /** Creates a ChannelProxy in the given realm. */
        static async #createAndGetHandleInRealm(realm) {
          const createChannelHandleResult = await realm.cdpClient.sendCommand("Runtime.evaluate", {
            expression: this.#createChannelProxyEvalStr(),
            contextId: realm.executionContextId,
            serializationOptions: {
              serialization: "idOnly"
            }
          });
          if (createChannelHandleResult.exceptionDetails || createChannelHandleResult.result.objectId === void 0) {
            throw new Error(`Cannot create channel`);
          }
          return createChannelHandleResult.result.objectId;
        }
        /** Gets a handle to `sendMessage` delegate from the ChannelProxy handle. */
        static async #createSendMessageHandle(realm, channelHandle) {
          const sendMessageArgResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((channelHandle2) => {
              return channelHandle2.sendMessage;
            }),
            arguments: [{ objectId: channelHandle }],
            executionContextId: realm.executionContextId,
            serializationOptions: {
              serialization: "idOnly"
            }
          });
          return sendMessageArgResult.result.objectId;
        }
        /** Starts listening for the channel events of the provided ChannelProxy. */
        async #startListener(realm, channelHandle, eventManager) {
          for (; ; ) {
            try {
              const message = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String(async (channelHandle2) => await channelHandle2.getMessage()),
                arguments: [
                  {
                    objectId: channelHandle
                  }
                ],
                awaitPromise: true,
                executionContextId: realm.executionContextId,
                serializationOptions: {
                  serialization: "deep",
                  maxDepth: this.#properties.serializationOptions?.maxObjectDepth ?? void 0
                }
              });
              if (message.exceptionDetails) {
                throw message.exceptionDetails;
              }
              eventManager.registerEvent({
                type: "event",
                method: protocol_js_1.ChromiumBidi.Script.EventNames.Message,
                params: {
                  channel: this.#properties.channel,
                  data: realm.cdpToBidiValue(
                    message,
                    this.#properties.ownership ?? "none"
                    /* Script.ResultOwnership.None */
                  ),
                  source: {
                    realm: realm.realmId,
                    context: realm.browsingContextId
                  }
                }
              }, realm.browsingContextId);
            } catch (error) {
              this.#logger?.(log_js_1.LogType.debugError, error);
              break;
            }
          }
        }
        /**
         * Returns a handle of ChannelProxy from window's property which was set there
         * by `getEvalInWindowStr`. If window property is not set yet, sets a promise
         * resolver to the window property, so that `getEvalInWindowStr` can resolve
         * the promise later on with the channel.
         * This is needed because `getEvalInWindowStr` can be called before or
         * after this method.
         */
        async #getHandleFromWindow(realm) {
          const channelHandleResult = await realm.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((id) => {
              const w5 = window;
              if (w5[id] === void 0) {
                return new Promise((resolve3) => w5[id] = resolve3);
              }
              const channelProxy = w5[id];
              delete w5[id];
              return channelProxy;
            }),
            arguments: [{ value: this.#id }],
            executionContextId: realm.executionContextId,
            awaitPromise: true,
            serializationOptions: {
              serialization: "idOnly"
            }
          });
          if (channelHandleResult.exceptionDetails !== void 0 || channelHandleResult.result.objectId === void 0) {
            throw new Error(`ChannelHandle not found in window["${this.#id}"]`);
          }
          return channelHandleResult.result.objectId;
        }
        /**
         * String to be evaluated to create a ProxyChannel and put it to window.
         * Returns the delegate `sendMessage`. Used to provide an argument for preload
         * script. Does the following:
         * 1. Creates a ChannelProxy.
         * 2. Puts the ChannelProxy to window['${this.#id}'] or resolves the promise
         *    by calling delegate stored in window['${this.#id}'].
         *    This is needed because `#getHandleFromWindow` can be called before or
         *    after this method.
         * 3. Returns the delegate `sendMessage` of the created ChannelProxy.
         */
        getEvalInWindowStr() {
          const delegate = String((id, channelProxy) => {
            const w5 = window;
            if (w5[id] === void 0) {
              w5[id] = channelProxy;
            } else {
              w5[id](channelProxy);
              delete w5[id];
            }
            return channelProxy.sendMessage;
          });
          const channelProxyEval = _ChannelProxy.#createChannelProxyEvalStr();
          return `(${delegate})('${this.#id}',${channelProxyEval})`;
        }
      };
      exports8.ChannelProxy = ChannelProxy;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/Realm.js
  var require_Realm = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/Realm.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.Realm = void 0;
      var protocol_js_1 = require_protocol();
      var log_js_1 = require_log();
      var uuid_js_1 = require_uuid();
      var ChannelProxy_js_1 = require_ChannelProxy();
      var SHARED_ID_DIVIDER = "_element_";
      var Realm2 = class _Realm {
        #realmStorage;
        #browsingContextStorage;
        #realmId;
        #browsingContextId;
        #executionContextId;
        #origin;
        #type;
        #cdpClient;
        #eventManager;
        sandbox;
        #logger;
        constructor(realmStorage, browsingContextStorage, realmId, browsingContextId, executionContextId, origin, type, sandbox, cdpClient, eventManager, logger) {
          this.#realmId = realmId;
          this.#browsingContextId = browsingContextId;
          this.#executionContextId = executionContextId;
          this.sandbox = sandbox;
          this.#origin = origin;
          this.#type = type;
          this.#cdpClient = cdpClient;
          this.#realmStorage = realmStorage;
          this.#browsingContextStorage = browsingContextStorage;
          this.#eventManager = eventManager;
          this.#logger = logger;
          this.#realmStorage.addRealm(this);
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmCreated,
            params: this.realmInfo
          }, this.browsingContextId);
        }
        cdpToBidiValue(cdpValue, resultOwnership) {
          const bidiValue = this.#deepSerializedToBiDi(cdpValue.result.deepSerializedValue, /* @__PURE__ */ new Map());
          if (cdpValue.result.objectId) {
            const objectId = cdpValue.result.objectId;
            if (resultOwnership === "root") {
              bidiValue.handle = objectId;
              this.#realmStorage.knownHandlesToRealmMap.set(objectId, this.realmId);
            } else {
              void this.#releaseObject(objectId).catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
            }
          }
          if (cdpValue.result.type === "object") {
            switch (cdpValue.result.subtype) {
              case "generator":
              case "iterator":
                bidiValue.type = cdpValue.result.subtype;
                delete bidiValue["value"];
                break;
              default:
            }
          }
          return bidiValue;
        }
        /**
         * Relies on the CDP to implement proper BiDi serialization, except:
         * * CDP integer property `backendNodeId` is replaced with `sharedId` of
         * `{documentId}_element_{backendNodeId}`;
         * * CDP integer property `weakLocalObjectReference` is replaced with UUID `internalId`
         * using unique-per serialization `internalIdMap`.
         * * CDP type `platformobject` is replaced with `object`.
         * @param deepSerializedValue - CDP value to be converted to BiDi.
         * @param internalIdMap - Map from CDP integer `weakLocalObjectReference` to BiDi UUID
         * `internalId`.
         */
        #deepSerializedToBiDi(deepSerializedValue, internalIdMap) {
          if (Object.hasOwn(deepSerializedValue, "weakLocalObjectReference")) {
            const weakLocalObjectReference = deepSerializedValue.weakLocalObjectReference;
            if (!internalIdMap.has(weakLocalObjectReference)) {
              internalIdMap.set(weakLocalObjectReference, (0, uuid_js_1.uuidv4)());
            }
            deepSerializedValue.internalId = internalIdMap.get(weakLocalObjectReference);
            delete deepSerializedValue["weakLocalObjectReference"];
          }
          if (deepSerializedValue.type === "platformobject") {
            return { type: "object" };
          }
          const bidiValue = deepSerializedValue.value;
          if (bidiValue === void 0) {
            return deepSerializedValue;
          }
          if (deepSerializedValue.type === "node") {
            if (Object.hasOwn(bidiValue, "backendNodeId")) {
              deepSerializedValue.sharedId = `${this.navigableId}${SHARED_ID_DIVIDER}${bidiValue.backendNodeId}`;
              delete bidiValue["backendNodeId"];
            }
            if (Object.hasOwn(bidiValue, "children")) {
              for (const i7 in bidiValue.children) {
                bidiValue.children[i7] = this.#deepSerializedToBiDi(bidiValue.children[i7], internalIdMap);
              }
            }
            if (Object.hasOwn(bidiValue, "shadowRoot") && bidiValue.shadowRoot !== null) {
              bidiValue.shadowRoot = this.#deepSerializedToBiDi(bidiValue.shadowRoot, internalIdMap);
            }
            if (bidiValue.namespaceURI === "") {
              bidiValue.namespaceURI = null;
            }
          }
          if (["array", "set", "htmlcollection", "nodelist"].includes(deepSerializedValue.type)) {
            for (const i7 in bidiValue) {
              bidiValue[i7] = this.#deepSerializedToBiDi(bidiValue[i7], internalIdMap);
            }
          }
          if (["object", "map"].includes(deepSerializedValue.type)) {
            for (const i7 in bidiValue) {
              bidiValue[i7] = [
                this.#deepSerializedToBiDi(bidiValue[i7][0], internalIdMap),
                this.#deepSerializedToBiDi(bidiValue[i7][1], internalIdMap)
              ];
            }
          }
          return deepSerializedValue;
        }
        get realmId() {
          return this.#realmId;
        }
        get navigableId() {
          return (this.browsingContextId && this.#browsingContextStorage.findContext(this.browsingContextId)?.navigableId) ?? "UNKNOWN";
        }
        get browsingContextId() {
          return this.#browsingContextId;
        }
        get executionContextId() {
          return this.#executionContextId;
        }
        get origin() {
          return this.#origin;
        }
        get type() {
          return this.#type;
        }
        get cdpClient() {
          return this.#cdpClient;
        }
        get realmInfo() {
          switch (this.type) {
            case "window":
              return {
                realm: this.realmId,
                origin: this.origin,
                type: this.type,
                context: this.browsingContextId,
                ...this.sandbox === void 0 ? {} : { sandbox: this.sandbox }
              };
            default:
              return {
                realm: this.realmId,
                origin: this.origin,
                type: this.type
              };
          }
        }
        async evaluate(expression, awaitPromise, resultOwnership, serializationOptions, userActivation = false) {
          await this.#browsingContextStorage.getContext(this.browsingContextId).targetUnblockedOrThrow();
          const cdpEvaluateResult = await this.cdpClient.sendCommand("Runtime.evaluate", {
            contextId: this.executionContextId,
            expression,
            awaitPromise,
            serializationOptions: _Realm.#getSerializationOptions("deep", serializationOptions),
            userGesture: userActivation
          });
          if (cdpEvaluateResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpEvaluateResult.exceptionDetails, 0, resultOwnership);
          }
          return {
            realm: this.realmId,
            result: this.cdpToBidiValue(cdpEvaluateResult, resultOwnership),
            type: "success"
          };
        }
        /**
         * Serializes a given CDP object into BiDi, keeping references in the
         * target's `globalThis`.
         */
        async serializeCdpObject(cdpRemoteObject, resultOwnership) {
          const argument = _Realm.#cdpRemoteObjectToCallArgument(cdpRemoteObject);
          const cdpValue = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((remoteObject) => remoteObject),
            awaitPromise: false,
            arguments: [argument],
            serializationOptions: {
              serialization: "deep"
            },
            executionContextId: this.executionContextId
          });
          return this.cdpToBidiValue(cdpValue, resultOwnership);
        }
        static #cdpRemoteObjectToCallArgument(cdpRemoteObject) {
          if (cdpRemoteObject.objectId !== void 0) {
            return { objectId: cdpRemoteObject.objectId };
          }
          if (cdpRemoteObject.unserializableValue !== void 0) {
            return { unserializableValue: cdpRemoteObject.unserializableValue };
          }
          return { value: cdpRemoteObject.value };
        }
        /**
         * Gets the string representation of an object. This is equivalent to
         * calling `toString()` on the object value.
         */
        async stringifyObject(cdpRemoteObject) {
          const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
            functionDeclaration: String((remoteObject) => String(remoteObject)),
            awaitPromise: false,
            arguments: [cdpRemoteObject],
            returnByValue: true,
            executionContextId: this.executionContextId
          });
          return result.value;
        }
        async #flattenKeyValuePairs(mappingLocalValue) {
          const keyValueArray = [];
          for (const [key, value] of mappingLocalValue) {
            let keyArg;
            if (typeof key === "string") {
              keyArg = { value: key };
            } else {
              keyArg = await this.#deserializeToCdpArg(key);
            }
            const valueArg = await this.#deserializeToCdpArg(value);
            keyValueArray.push(keyArg);
            keyValueArray.push(valueArg);
          }
          return keyValueArray;
        }
        async #flattenValueList(listLocalValue) {
          return await Promise.all(listLocalValue.map((localValue) => this.#deserializeToCdpArg(localValue)));
        }
        async #serializeCdpExceptionDetails(cdpExceptionDetails, lineOffset, resultOwnership) {
          const callFrames = cdpExceptionDetails.stackTrace?.callFrames.map((frame) => ({
            url: frame.url,
            functionName: frame.functionName,
            lineNumber: frame.lineNumber - lineOffset,
            columnNumber: frame.columnNumber
          })) ?? [];
          const exception = cdpExceptionDetails.exception;
          return {
            exception: await this.serializeCdpObject(exception, resultOwnership),
            columnNumber: cdpExceptionDetails.columnNumber,
            lineNumber: cdpExceptionDetails.lineNumber - lineOffset,
            stackTrace: {
              callFrames
            },
            text: await this.stringifyObject(exception) || cdpExceptionDetails.text
          };
        }
        async callFunction(functionDeclaration, thisLocalValue, argumentsLocalValues, awaitPromise, resultOwnership, serializationOptions, userActivation = false) {
          await this.#browsingContextStorage.getContext(this.browsingContextId).targetUnblockedOrThrow();
          const callFunctionAndSerializeScript = `(...args) => {
      function callFunction(f, args) {
        const deserializedThis = args.shift();
        const deserializedArgs = args;
        return f.apply(deserializedThis, deserializedArgs);
      }
      return callFunction((
        ${functionDeclaration}
      ), args);
    }`;
          const thisAndArgumentsList = [
            await this.#deserializeToCdpArg(thisLocalValue),
            ...await Promise.all(argumentsLocalValues.map(async (argumentLocalValue) => await this.#deserializeToCdpArg(argumentLocalValue)))
          ];
          let cdpCallFunctionResult;
          try {
            cdpCallFunctionResult = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
              functionDeclaration: callFunctionAndSerializeScript,
              awaitPromise,
              arguments: thisAndArgumentsList,
              serializationOptions: _Realm.#getSerializationOptions("deep", serializationOptions),
              executionContextId: this.executionContextId,
              userGesture: userActivation
            });
          } catch (error) {
            if (error.code === -32e3 && [
              "Could not find object with given id",
              "Argument should belong to the same JavaScript world as target object",
              "Invalid remote object id"
            ].includes(error.message)) {
              throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
            }
            throw error;
          }
          if (cdpCallFunctionResult.exceptionDetails) {
            return await this.#getExceptionResult(cdpCallFunctionResult.exceptionDetails, 1, resultOwnership);
          }
          return {
            type: "success",
            result: this.cdpToBidiValue(cdpCallFunctionResult, resultOwnership),
            realm: this.realmId
          };
        }
        async #deserializeToCdpArg(localValue) {
          if ("sharedId" in localValue && localValue.sharedId) {
            const [navigableId, rawBackendNodeId] = localValue.sharedId.split(SHARED_ID_DIVIDER);
            const backendNodeId = parseInt(rawBackendNodeId ?? "");
            if (isNaN(backendNodeId) || backendNodeId === void 0 || navigableId === void 0) {
              throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
            }
            if (this.navigableId !== navigableId) {
              throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" belongs to different document. Current document is ${this.navigableId}.`);
            }
            try {
              const { object } = await this.cdpClient.sendCommand("DOM.resolveNode", {
                backendNodeId,
                executionContextId: this.executionContextId
              });
              return { objectId: object.objectId };
            } catch (error) {
              if (error.code === -32e3 && error.message === "No node with given id found") {
                throw new protocol_js_1.NoSuchNodeException(`SharedId "${localValue.sharedId}" was not found.`);
              }
              throw new protocol_js_1.UnknownErrorException(error.message, error.stack);
            }
          } else if ("handle" in localValue && localValue.handle) {
            return { objectId: localValue.handle };
          } else if ("handle" in localValue || "sharedId" in localValue) {
            throw new protocol_js_1.NoSuchHandleException("Handle was not found.");
          }
          switch (localValue.type) {
            case "undefined":
              return { unserializableValue: "undefined" };
            case "null":
              return { unserializableValue: "null" };
            case "string":
              return { value: localValue.value };
            case "number":
              if (localValue.value === "NaN") {
                return { unserializableValue: "NaN" };
              } else if (localValue.value === "-0") {
                return { unserializableValue: "-0" };
              } else if (localValue.value === "Infinity") {
                return { unserializableValue: "Infinity" };
              } else if (localValue.value === "-Infinity") {
                return { unserializableValue: "-Infinity" };
              }
              return {
                value: localValue.value
              };
            case "boolean":
              return { value: Boolean(localValue.value) };
            case "bigint":
              return {
                unserializableValue: `BigInt(${JSON.stringify(localValue.value)})`
              };
            case "date":
              return {
                unserializableValue: `new Date(Date.parse(${JSON.stringify(localValue.value)}))`
              };
            case "regexp":
              return {
                unserializableValue: `new RegExp(${JSON.stringify(localValue.value.pattern)}, ${JSON.stringify(localValue.value.flags)})`
              };
            case "map": {
              const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
              const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String((...args) => {
                  const result2 = /* @__PURE__ */ new Map();
                  for (let i7 = 0; i7 < args.length; i7 += 2) {
                    result2.set(args[i7], args[i7 + 1]);
                  }
                  return result2;
                }),
                awaitPromise: false,
                arguments: keyValueArray,
                returnByValue: false,
                executionContextId: this.executionContextId
              });
              return { objectId: result.objectId };
            }
            case "object": {
              const keyValueArray = await this.#flattenKeyValuePairs(localValue.value);
              const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String((...args) => {
                  const result2 = {};
                  for (let i7 = 0; i7 < args.length; i7 += 2) {
                    const key = args[i7];
                    result2[key] = args[i7 + 1];
                  }
                  return result2;
                }),
                awaitPromise: false,
                arguments: keyValueArray,
                returnByValue: false,
                executionContextId: this.executionContextId
              });
              return { objectId: result.objectId };
            }
            case "array": {
              const args = await this.#flattenValueList(localValue.value);
              const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String((...args2) => args2),
                awaitPromise: false,
                arguments: args,
                returnByValue: false,
                executionContextId: this.executionContextId
              });
              return { objectId: result.objectId };
            }
            case "set": {
              const args = await this.#flattenValueList(localValue.value);
              const { result } = await this.cdpClient.sendCommand("Runtime.callFunctionOn", {
                functionDeclaration: String((...args2) => new Set(args2)),
                awaitPromise: false,
                arguments: args,
                returnByValue: false,
                executionContextId: this.executionContextId
              });
              return { objectId: result.objectId };
            }
            case "channel": {
              const channelProxy = new ChannelProxy_js_1.ChannelProxy(localValue.value, this.#logger);
              const channelProxySendMessageHandle = await channelProxy.init(this, this.#eventManager);
              return { objectId: channelProxySendMessageHandle };
            }
          }
          throw new Error(`Value ${JSON.stringify(localValue)} is not deserializable.`);
        }
        async #getExceptionResult(exceptionDetails, lineOffset, resultOwnership) {
          return {
            exceptionDetails: await this.#serializeCdpExceptionDetails(exceptionDetails, lineOffset, resultOwnership),
            realm: this.realmId,
            type: "exception"
          };
        }
        static #getSerializationOptions(serialization, serializationOptions) {
          return {
            serialization,
            additionalParameters: _Realm.#getAdditionalSerializationParameters(serializationOptions),
            ..._Realm.#getMaxObjectDepth(serializationOptions)
          };
        }
        static #getAdditionalSerializationParameters(serializationOptions) {
          const additionalParameters = {};
          if (serializationOptions.maxDomDepth !== void 0) {
            additionalParameters["maxNodeDepth"] = serializationOptions.maxDomDepth === null ? 1e3 : serializationOptions.maxDomDepth;
          }
          if (serializationOptions.includeShadowTree !== void 0) {
            additionalParameters["includeShadowTree"] = serializationOptions.includeShadowTree;
          }
          return additionalParameters;
        }
        static #getMaxObjectDepth(serializationOptions) {
          return serializationOptions.maxObjectDepth === void 0 || serializationOptions.maxObjectDepth === null ? {} : { maxDepth: serializationOptions.maxObjectDepth };
        }
        async #releaseObject(handle) {
          try {
            await this.cdpClient.sendCommand("Runtime.releaseObject", {
              objectId: handle
            });
          } catch (error) {
            if (!(error.code === -32e3 && error.message === "Invalid remote object id")) {
              throw error;
            }
          }
        }
        async disown(handle) {
          if (this.#realmStorage.knownHandlesToRealmMap.get(handle) !== this.realmId) {
            return;
          }
          await this.#releaseObject(handle);
          this.#realmStorage.knownHandlesToRealmMap.delete(handle);
        }
        dispose() {
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.Script.EventNames.RealmDestroyed,
            params: {
              realm: this.realmId
            }
          }, this.browsingContextId);
        }
      };
      exports8.Realm = Realm2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/assert.js
  var require_assert = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/assert.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.assert = void 0;
      function assert3(predicate, message) {
        if (!predicate) {
          throw new Error(message ?? "Internal assertion failed.");
        }
      }
      exports8.assert = assert3;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/Deferred.js
  var require_Deferred = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/Deferred.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.Deferred = void 0;
      var Deferred2 = class {
        #isFinished = false;
        #promise;
        #resolve;
        #reject;
        get isFinished() {
          return this.#isFinished;
        }
        constructor() {
          this.#promise = new Promise((resolve3, reject) => {
            this.#resolve = resolve3;
            this.#reject = reject;
          });
          this.#promise.catch((_error) => {
          });
        }
        then(onFulfilled, onRejected) {
          return this.#promise.then(onFulfilled, onRejected);
        }
        catch(onRejected) {
          return this.#promise.catch(onRejected);
        }
        resolve(value) {
          if (!this.#isFinished) {
            this.#isFinished = true;
            this.#resolve(value);
          }
        }
        reject(reason) {
          if (!this.#isFinished) {
            this.#isFinished = true;
            this.#reject(reason);
          }
        }
        finally(onFinally) {
          return this.#promise.finally(onFinally);
        }
        [Symbol.toStringTag] = "Promise";
      };
      exports8.Deferred = Deferred2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js
  var require_unitConversions = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/unitConversions.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.inchesFromCm = void 0;
      function inchesFromCm(cm) {
        return cm / 2.54;
      }
      exports8.inchesFromCm = inchesFromCm;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextImpl.js
  var require_BrowsingContextImpl = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextImpl.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.serializeOrigin = exports8.BrowsingContextImpl = void 0;
      var protocol_js_1 = require_protocol();
      var assert_js_1 = require_assert();
      var Deferred_js_1 = require_Deferred();
      var log_js_1 = require_log();
      var unitConversions_js_1 = require_unitConversions();
      var Realm_js_1 = require_Realm();
      var BrowsingContextImpl = class _BrowsingContextImpl {
        static LOGGER_PREFIX = `${log_js_1.LogType.debug}:browsingContext`;
        /** The ID of this browsing context. */
        #id;
        /**
         * The ID of the parent browsing context.
         * If null, this is a top-level context.
         */
        #parentId;
        /** Direct children browsing contexts. */
        #children = /* @__PURE__ */ new Set();
        #browsingContextStorage;
        #deferreds = {
          Page: {
            navigatedWithinDocument: new Deferred_js_1.Deferred(),
            lifecycleEvent: {
              DOMContentLoaded: new Deferred_js_1.Deferred(),
              load: new Deferred_js_1.Deferred()
            },
            frameStartedLoading: new Deferred_js_1.Deferred()
          }
        };
        #url = "about:blank";
        #eventManager;
        #realmStorage;
        #loaderId;
        #cdpTarget;
        #maybeDefaultRealm;
        #logger;
        constructor(cdpTarget, realmStorage, id, parentId, eventManager, browsingContextStorage, logger) {
          this.#cdpTarget = cdpTarget;
          this.#realmStorage = realmStorage;
          this.#id = id;
          this.#parentId = parentId;
          this.#eventManager = eventManager;
          this.#browsingContextStorage = browsingContextStorage;
          this.#logger = logger;
        }
        static create(cdpTarget, realmStorage, id, parentId, eventManager, browsingContextStorage, logger) {
          const context = new _BrowsingContextImpl(cdpTarget, realmStorage, id, parentId, eventManager, browsingContextStorage, logger);
          context.#initListeners();
          browsingContextStorage.addContext(context);
          if (!context.isTopLevelContext()) {
            context.parent.addChild(context.id);
          }
          eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextCreated,
            params: context.serializeToBidiValue()
          }, context.id);
          return context;
        }
        static getTimestamp() {
          return (/* @__PURE__ */ new Date()).getTime();
        }
        /**
         * @see https://html.spec.whatwg.org/multipage/document-sequences.html#navigable
         */
        get navigableId() {
          return this.#loaderId;
        }
        dispose() {
          this.#deleteAllChildren();
          this.#realmStorage.deleteRealms({
            browsingContextId: this.id
          });
          if (!this.isTopLevelContext()) {
            this.parent.#children.delete(this.id);
          }
          this.#failDeferredsIfNotFinished();
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.ContextDestroyed,
            params: this.serializeToBidiValue()
          }, this.id);
          this.#browsingContextStorage.deleteContextById(this.id);
        }
        /** Returns the ID of this context. */
        get id() {
          return this.#id;
        }
        /** Returns the parent context ID. */
        get parentId() {
          return this.#parentId;
        }
        /** Returns the parent context. */
        get parent() {
          if (this.parentId === null) {
            return null;
          }
          return this.#browsingContextStorage.getContext(this.parentId);
        }
        /** Returns all direct children contexts. */
        get directChildren() {
          return [...this.#children].map((id) => this.#browsingContextStorage.getContext(id));
        }
        /** Returns all children contexts, flattened. */
        get allChildren() {
          const children = this.directChildren;
          return children.concat(...children.map((child) => child.allChildren));
        }
        /**
         * Returns true if this is a top-level context.
         * This is the case whenever the parent context ID is null.
         */
        isTopLevelContext() {
          return this.#parentId === null;
        }
        get top() {
          let topContext = this;
          let parent = topContext.parent;
          while (parent) {
            topContext = parent;
            parent = topContext.parent;
          }
          return topContext;
        }
        addChild(childId) {
          this.#children.add(childId);
        }
        #deleteAllChildren() {
          this.directChildren.map((child) => child.dispose());
        }
        get #defaultRealm() {
          (0, assert_js_1.assert)(this.#maybeDefaultRealm, `No default realm for browsing context ${this.#id}`);
          return this.#maybeDefaultRealm;
        }
        get cdpTarget() {
          return this.#cdpTarget;
        }
        updateCdpTarget(cdpTarget) {
          this.#cdpTarget = cdpTarget;
          this.#initListeners();
        }
        get url() {
          return this.#url;
        }
        async lifecycleLoaded() {
          await this.#deferreds.Page.lifecycleEvent.load;
        }
        async targetUnblockedOrThrow() {
          const result = await this.#cdpTarget.targetUnblocked;
          if (result.kind === "error") {
            throw result.error;
          }
        }
        async getOrCreateSandbox(sandbox) {
          if (sandbox === void 0 || sandbox === "") {
            return this.#defaultRealm;
          }
          let maybeSandboxes = this.#realmStorage.findRealms({
            browsingContextId: this.id,
            sandbox
          });
          if (maybeSandboxes.length === 0) {
            await this.#cdpTarget.cdpClient.sendCommand("Page.createIsolatedWorld", {
              frameId: this.id,
              worldName: sandbox
            });
            maybeSandboxes = this.#realmStorage.findRealms({
              browsingContextId: this.id,
              sandbox
            });
            (0, assert_js_1.assert)(maybeSandboxes.length !== 0);
          }
          return maybeSandboxes[0];
        }
        serializeToBidiValue(maxDepth = 0, addParentField = true) {
          return {
            context: this.#id,
            url: this.url,
            children: maxDepth > 0 ? this.directChildren.map((c7) => c7.serializeToBidiValue(maxDepth - 1, false)) : null,
            ...addParentField ? { parent: this.#parentId } : {}
          };
        }
        onTargetInfoChanged(params) {
          this.#url = params.targetInfo.url;
        }
        #initListeners() {
          this.#cdpTarget.cdpClient.on("Page.frameNavigated", (params) => {
            if (this.id !== params.frame.id) {
              return;
            }
            this.#url = params.frame.url + (params.frame.urlFragment ?? "");
            this.#deleteAllChildren();
          });
          this.#cdpTarget.cdpClient.on("Page.navigatedWithinDocument", (params) => {
            if (this.id !== params.frameId) {
              return;
            }
            const timestamp = _BrowsingContextImpl.getTimestamp();
            this.#url = params.url;
            this.#deferreds.Page.navigatedWithinDocument.resolve(params);
            this.#eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.FragmentNavigated,
              params: {
                context: this.id,
                navigation: null,
                timestamp,
                url: this.#url
              }
            }, this.id);
          });
          this.#cdpTarget.cdpClient.on("Page.frameStartedLoading", (params) => {
            if (this.id !== params.frameId) {
              return;
            }
            this.#eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted,
              params: {
                context: this.id,
                navigation: null,
                timestamp: _BrowsingContextImpl.getTimestamp(),
                url: ""
              }
            }, this.id);
          });
          this.#cdpTarget.cdpClient.on("Page.lifecycleEvent", (params) => {
            if (this.id !== params.frameId) {
              return;
            }
            if (params.name === "init") {
              this.#documentChanged(params.loaderId);
              return;
            }
            if (params.name === "commit") {
              this.#loaderId = params.loaderId;
              return;
            }
            if (params.loaderId !== this.#loaderId) {
              return;
            }
            const timestamp = _BrowsingContextImpl.getTimestamp();
            switch (params.name) {
              case "DOMContentLoaded":
                this.#eventManager.registerEvent({
                  type: "event",
                  method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.DomContentLoaded,
                  params: {
                    context: this.id,
                    navigation: this.#loaderId ?? null,
                    timestamp,
                    url: this.#url
                  }
                }, this.id);
                this.#deferreds.Page.lifecycleEvent.DOMContentLoaded.resolve(params);
                break;
              case "load":
                this.#eventManager.registerEvent({
                  type: "event",
                  method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.Load,
                  params: {
                    context: this.id,
                    navigation: this.#loaderId ?? null,
                    timestamp,
                    url: this.#url
                  }
                }, this.id);
                this.#deferreds.Page.lifecycleEvent.load.resolve(params);
                break;
            }
          });
          this.#cdpTarget.cdpClient.on("Runtime.executionContextCreated", (params) => {
            const { auxData, name: name2, uniqueId, id } = params.context;
            if (!auxData || auxData.frameId !== this.id) {
              return;
            }
            let origin;
            let sandbox;
            switch (auxData.type) {
              case "isolated":
                sandbox = name2;
                origin = this.#defaultRealm.origin;
                break;
              case "default":
                origin = serializeOrigin(params.context.origin);
                break;
              default:
                return;
            }
            const realm = new Realm_js_1.Realm(
              this.#realmStorage,
              this.#browsingContextStorage,
              uniqueId,
              this.id,
              id,
              origin,
              // XXX: differentiate types.
              "window",
              // Sandbox name for isolated world.
              sandbox,
              this.#cdpTarget.cdpClient,
              this.#eventManager,
              this.#logger
            );
            if (auxData.isDefault) {
              this.#maybeDefaultRealm = realm;
              void Promise.all(this.#cdpTarget.getChannels().map((channel) => channel.startListenerFromWindow(realm, this.#eventManager)));
            }
          });
          this.#cdpTarget.cdpClient.on("Runtime.executionContextDestroyed", (params) => {
            this.#realmStorage.deleteRealms({
              cdpSessionId: this.#cdpTarget.cdpSessionId,
              executionContextId: params.executionContextId
            });
          });
          this.#cdpTarget.cdpClient.on("Runtime.executionContextsCleared", () => {
            this.#realmStorage.deleteRealms({
              cdpSessionId: this.#cdpTarget.cdpSessionId
            });
          });
          this.#cdpTarget.cdpClient.on("Page.javascriptDialogClosed", (params) => {
            const accepted = params.result;
            this.#eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptClosed,
              params: {
                context: this.id,
                accepted,
                userText: accepted && params.userInput ? params.userInput : void 0
              }
            }, this.id);
          });
          this.#cdpTarget.cdpClient.on("Page.javascriptDialogOpening", (params) => {
            this.#eventManager.registerEvent({
              type: "event",
              method: protocol_js_1.ChromiumBidi.BrowsingContext.EventNames.UserPromptOpened,
              params: {
                context: this.id,
                type: params.type,
                message: params.message,
                // Don't set the value if empty string
                defaultValue: params.defaultPrompt || void 0
              }
            }, this.id);
          });
        }
        #documentChanged(loaderId) {
          if (loaderId === void 0 || this.#loaderId === loaderId) {
            if (this.#deferreds.Page.navigatedWithinDocument.isFinished) {
              this.#deferreds.Page.navigatedWithinDocument = new Deferred_js_1.Deferred();
            } else {
              this.#logger?.(_BrowsingContextImpl.LOGGER_PREFIX, "Document changed (navigatedWithinDocument)");
            }
            return;
          }
          this.#resetDeferredsIfFinished();
          this.#loaderId = loaderId;
        }
        #resetDeferredsIfFinished() {
          if (this.#deferreds.Page.lifecycleEvent.DOMContentLoaded.isFinished) {
            this.#deferreds.Page.lifecycleEvent.DOMContentLoaded = new Deferred_js_1.Deferred();
          } else {
            this.#logger?.(_BrowsingContextImpl.LOGGER_PREFIX, "Document changed (DOMContentLoaded)");
          }
          if (this.#deferreds.Page.lifecycleEvent.load.isFinished) {
            this.#deferreds.Page.lifecycleEvent.load = new Deferred_js_1.Deferred();
          } else {
            this.#logger?.(_BrowsingContextImpl.LOGGER_PREFIX, "Document changed (load)");
          }
        }
        #failDeferredsIfNotFinished() {
          if (!this.#deferreds.Page.lifecycleEvent.DOMContentLoaded.isFinished) {
            this.#deferreds.Page.lifecycleEvent.DOMContentLoaded.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
          }
          if (!this.#deferreds.Page.lifecycleEvent.load.isFinished) {
            this.#deferreds.Page.lifecycleEvent.load.reject(new protocol_js_1.UnknownErrorException("navigation canceled"));
          }
        }
        async navigate(url, wait) {
          try {
            new URL(url);
          } catch {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL: ${url}`);
          }
          await this.targetUnblockedOrThrow();
          const cdpNavigateResult = await this.#cdpTarget.cdpClient.sendCommand("Page.navigate", {
            url,
            frameId: this.id
          });
          if (cdpNavigateResult.errorText) {
            throw new protocol_js_1.UnknownErrorException(cdpNavigateResult.errorText);
          }
          this.#documentChanged(cdpNavigateResult.loaderId);
          switch (wait) {
            case "none":
              break;
            case "interactive":
              if (cdpNavigateResult.loaderId === void 0) {
                await this.#deferreds.Page.navigatedWithinDocument;
              } else {
                await this.#deferreds.Page.lifecycleEvent.DOMContentLoaded;
              }
              break;
            case "complete":
              if (cdpNavigateResult.loaderId === void 0) {
                await this.#deferreds.Page.navigatedWithinDocument;
              } else {
                await this.lifecycleLoaded();
              }
              break;
          }
          return {
            navigation: cdpNavigateResult.loaderId ?? null,
            // Url can change due to redirect get the latest one.
            url: wait === "none" ? url : this.#url
          };
        }
        async reload(ignoreCache, wait) {
          await this.targetUnblockedOrThrow();
          await this.#cdpTarget.cdpClient.sendCommand("Page.reload", {
            ignoreCache
          });
          this.#resetDeferredsIfFinished();
          switch (wait) {
            case "none":
              break;
            case "interactive":
              await this.#deferreds.Page.lifecycleEvent.DOMContentLoaded;
              break;
            case "complete":
              await this.lifecycleLoaded();
              break;
          }
          return {
            navigation: wait === "none" ? null : this.navigableId ?? null,
            url: this.url
          };
        }
        async setViewport(viewport, devicePixelRatio) {
          if (viewport === null && devicePixelRatio === null) {
            await this.#cdpTarget.cdpClient.sendCommand("Emulation.clearDeviceMetricsOverride");
          } else {
            try {
              await this.#cdpTarget.cdpClient.sendCommand("Emulation.setDeviceMetricsOverride", {
                width: viewport ? viewport.width : 0,
                height: viewport ? viewport.height : 0,
                deviceScaleFactor: devicePixelRatio ? devicePixelRatio : 0,
                mobile: false,
                dontSetVisibleSize: true
              });
            } catch (err) {
              if (err.message.startsWith(
                // https://crsrc.org/c/content/browser/devtools/protocol/emulation_handler.cc;l=257;drc=2f6eee84cf98d4227e7c41718dd71b82f26d90ff
                "Width and height values must be positive"
              )) {
                throw new protocol_js_1.UnsupportedOperationException("Provided viewport dimensions are not supported");
              }
              throw err;
            }
          }
        }
        async handleUserPrompt(params) {
          await this.#cdpTarget.cdpClient.sendCommand("Page.handleJavaScriptDialog", {
            accept: params.accept ?? true,
            promptText: params.userText
          });
        }
        async activate() {
          await this.#cdpTarget.cdpClient.sendCommand("Page.bringToFront");
        }
        async captureScreenshot(params) {
          if (!this.isTopLevelContext()) {
            throw new protocol_js_1.UnsupportedOperationException(`Non-top-level 'context' (${params.context}) is currently not supported`);
          }
          const formatParameters = getImageFormatParameters(params);
          await this.#cdpTarget.cdpClient.sendCommand("Page.bringToFront");
          let captureBeyondViewport = false;
          let script;
          params.origin ??= "viewport";
          switch (params.origin) {
            case "document": {
              script = String(() => {
                const element = document.documentElement;
                return {
                  x: 0,
                  y: 0,
                  width: element.scrollWidth,
                  height: element.scrollHeight
                };
              });
              captureBeyondViewport = true;
              break;
            }
            case "viewport": {
              script = String(() => {
                const viewport = window.visualViewport;
                return {
                  x: viewport.pageLeft,
                  y: viewport.pageTop,
                  width: viewport.width,
                  height: viewport.height
                };
              });
              break;
            }
          }
          const realm = await this.getOrCreateSandbox(void 0);
          const originResult = await realm.callFunction(script, { type: "undefined" }, [], false, "none", {}, false);
          (0, assert_js_1.assert)(originResult.type === "success");
          const origin = deserializeDOMRect(originResult.result);
          (0, assert_js_1.assert)(origin);
          const rect = params.clip ? getIntersectionRect2(await this.#parseRect(params.clip), origin) : origin;
          if (rect.width === 0 || rect.height === 0) {
            throw new protocol_js_1.UnableToCaptureScreenException(`Unable to capture screenshot with zero dimensions: width=${rect.width}, height=${rect.height}`);
          }
          return await this.#cdpTarget.cdpClient.sendCommand("Page.captureScreenshot", {
            clip: { ...rect, scale: 1 },
            ...formatParameters,
            captureBeyondViewport
          });
        }
        async print(params) {
          const cdpParams = {};
          if (params.background !== void 0) {
            cdpParams.printBackground = params.background;
          }
          if (params.margin?.bottom !== void 0) {
            cdpParams.marginBottom = (0, unitConversions_js_1.inchesFromCm)(params.margin.bottom);
          }
          if (params.margin?.left !== void 0) {
            cdpParams.marginLeft = (0, unitConversions_js_1.inchesFromCm)(params.margin.left);
          }
          if (params.margin?.right !== void 0) {
            cdpParams.marginRight = (0, unitConversions_js_1.inchesFromCm)(params.margin.right);
          }
          if (params.margin?.top !== void 0) {
            cdpParams.marginTop = (0, unitConversions_js_1.inchesFromCm)(params.margin.top);
          }
          if (params.orientation !== void 0) {
            cdpParams.landscape = params.orientation === "landscape";
          }
          if (params.page?.height !== void 0) {
            cdpParams.paperHeight = (0, unitConversions_js_1.inchesFromCm)(params.page.height);
          }
          if (params.page?.width !== void 0) {
            cdpParams.paperWidth = (0, unitConversions_js_1.inchesFromCm)(params.page.width);
          }
          if (params.pageRanges !== void 0) {
            for (const range of params.pageRanges) {
              if (typeof range === "number") {
                continue;
              }
              const rangeParts = range.split("-");
              if (rangeParts.length < 1 || rangeParts.length > 2) {
                throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${range} is not a valid integer range.`);
              }
              if (rangeParts.length === 1) {
                void parseInteger(rangeParts[0] ?? "");
                continue;
              }
              let lowerBound;
              let upperBound;
              const [rangeLowerPart = "", rangeUpperPart = ""] = rangeParts;
              if (rangeLowerPart === "") {
                lowerBound = 1;
              } else {
                lowerBound = parseInteger(rangeLowerPart);
              }
              if (rangeUpperPart === "") {
                upperBound = Number.MAX_SAFE_INTEGER;
              } else {
                upperBound = parseInteger(rangeUpperPart);
              }
              if (lowerBound > upperBound) {
                throw new protocol_js_1.InvalidArgumentException(`Invalid page range: ${rangeLowerPart} > ${rangeUpperPart}`);
              }
            }
            cdpParams.pageRanges = params.pageRanges.join(",");
          }
          if (params.scale !== void 0) {
            cdpParams.scale = params.scale;
          }
          if (params.shrinkToFit !== void 0) {
            cdpParams.preferCSSPageSize = !params.shrinkToFit;
          }
          try {
            const result = await this.#cdpTarget.cdpClient.sendCommand("Page.printToPDF", cdpParams);
            return {
              data: result.data
            };
          } catch (error) {
            if (error.message === "invalid print parameters: content area is empty") {
              throw new protocol_js_1.UnsupportedOperationException(error.message);
            }
            throw error;
          }
        }
        /**
         * See
         * https://w3c.github.io/webdriver-bidi/#:~:text=If%20command%20parameters%20contains%20%22clip%22%3A
         */
        async #parseRect(clip) {
          switch (clip.type) {
            case "box":
              return { x: clip.x, y: clip.y, width: clip.width, height: clip.height };
            case "element": {
              const sandbox = await this.getOrCreateSandbox(void 0);
              const result = await sandbox.callFunction(String((element) => {
                return element instanceof Element;
              }), { type: "undefined" }, [clip.element], false, "none", {});
              if (result.type === "exception") {
                throw new protocol_js_1.NoSuchElementException(`Element '${clip.element.sharedId}' was not found`);
              }
              (0, assert_js_1.assert)(result.result.type === "boolean");
              if (!result.result.value) {
                throw new protocol_js_1.NoSuchElementException(`Node '${clip.element.sharedId}' is not an Element`);
              }
              {
                const result2 = await sandbox.callFunction(String((element) => {
                  const rect2 = element.getBoundingClientRect();
                  return {
                    x: rect2.x,
                    y: rect2.y,
                    height: rect2.height,
                    width: rect2.width
                  };
                }), { type: "undefined" }, [clip.element], false, "none", {});
                (0, assert_js_1.assert)(result2.type === "success");
                const rect = deserializeDOMRect(result2.result);
                if (!rect) {
                  throw new protocol_js_1.UnableToCaptureScreenException(`Could not get bounding box for Element '${clip.element.sharedId}'`);
                }
                return rect;
              }
            }
          }
        }
        async close() {
          await this.#cdpTarget.cdpClient.sendCommand("Page.close");
        }
        async traverseHistory(delta) {
          if (delta === 0) {
            return;
          }
          const history = await this.#cdpTarget.cdpClient.sendCommand("Page.getNavigationHistory");
          const entry = history.entries[history.currentIndex + delta];
          if (!entry) {
            throw new protocol_js_1.NoSuchHistoryEntryException(`No history entry at delta ${delta}`);
          }
          await this.#cdpTarget.cdpClient.sendCommand("Page.navigateToHistoryEntry", {
            entryId: entry.id
          });
        }
      };
      exports8.BrowsingContextImpl = BrowsingContextImpl;
      function serializeOrigin(origin) {
        if (["://", ""].includes(origin)) {
          origin = "null";
        }
        return origin;
      }
      exports8.serializeOrigin = serializeOrigin;
      function getImageFormatParameters(params) {
        const { quality, type } = params.format ?? {
          type: "image/png"
        };
        switch (type) {
          case "image/png": {
            return { format: "png" };
          }
          case "image/jpeg": {
            return {
              format: "jpeg",
              ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
            };
          }
          case "image/webp": {
            return {
              format: "webp",
              ...quality === void 0 ? {} : { quality: Math.round(quality * 100) }
            };
          }
        }
        throw new protocol_js_1.InvalidArgumentException(`Image format '${type}' is not a supported format`);
      }
      function deserializeDOMRect(result) {
        if (result.type !== "object" || result.value === void 0) {
          return;
        }
        const x4 = result.value.find(([key]) => {
          return key === "x";
        })?.[1];
        const y6 = result.value.find(([key]) => {
          return key === "y";
        })?.[1];
        const height = result.value.find(([key]) => {
          return key === "height";
        })?.[1];
        const width = result.value.find(([key]) => {
          return key === "width";
        })?.[1];
        if (x4?.type !== "number" || y6?.type !== "number" || height?.type !== "number" || width?.type !== "number") {
          return;
        }
        return {
          x: x4.value,
          y: y6.value,
          width: width.value,
          height: height.value
        };
      }
      function normalizeRect(box) {
        return {
          ...box.width < 0 ? {
            x: box.x + box.width,
            width: -box.width
          } : {
            x: box.x,
            width: box.width
          },
          ...box.height < 0 ? {
            y: box.y + box.height,
            height: -box.height
          } : {
            y: box.y,
            height: box.height
          }
        };
      }
      function getIntersectionRect2(first, second) {
        first = normalizeRect(first);
        second = normalizeRect(second);
        const x4 = Math.max(first.x, second.x);
        const y6 = Math.max(first.y, second.y);
        return {
          x: x4,
          y: y6,
          width: Math.max(Math.min(first.x + first.width, second.x + second.width) - x4, 0),
          height: Math.max(Math.min(first.y + first.height, second.y + second.height) - y6, 0)
        };
      }
      function parseInteger(value) {
        value = value.trim();
        if (!/^[0-9]+$/.test(value)) {
          throw new protocol_js_1.InvalidArgumentException(`Invalid integer: ${value}`);
        }
        return parseInt(value);
      }
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logHelper.js
  var require_logHelper = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/logHelper.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.getRemoteValuesText = exports8.logMessageFormatter = void 0;
      var assert_js_1 = require_assert();
      var specifiers = ["%s", "%d", "%i", "%f", "%o", "%O", "%c"];
      function isFormatSpecifier(str) {
        return specifiers.some((spec) => str.includes(spec));
      }
      function logMessageFormatter(args) {
        let output = "";
        const argFormat = args[0].value.toString();
        const argValues = args.slice(1, void 0);
        const tokens = argFormat.split(new RegExp(specifiers.map((spec) => `(${spec})`).join("|"), "g"));
        for (const token of tokens) {
          if (token === void 0 || token === "") {
            continue;
          }
          if (isFormatSpecifier(token)) {
            const arg = argValues.shift();
            (0, assert_js_1.assert)(arg, `Less value is provided: "${getRemoteValuesText(args, false)}"`);
            if (token === "%s") {
              output += stringFromArg(arg);
            } else if (token === "%d" || token === "%i") {
              if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
                output += parseInt(arg.value.toString(), 10);
              } else {
                output += "NaN";
              }
            } else if (token === "%f") {
              if (arg.type === "bigint" || arg.type === "number" || arg.type === "string") {
                output += parseFloat(arg.value.toString());
              } else {
                output += "NaN";
              }
            } else {
              output += toJson(arg);
            }
          } else {
            output += token;
          }
        }
        if (argValues.length > 0) {
          throw new Error(`More value is provided: "${getRemoteValuesText(args, false)}"`);
        }
        return output;
      }
      exports8.logMessageFormatter = logMessageFormatter;
      function toJson(arg) {
        if (arg.type !== "array" && arg.type !== "bigint" && arg.type !== "date" && arg.type !== "number" && arg.type !== "object" && arg.type !== "string") {
          return stringFromArg(arg);
        }
        if (arg.type === "bigint") {
          return `${arg.value.toString()}n`;
        }
        if (arg.type === "number") {
          return arg.value.toString();
        }
        if (["date", "string"].includes(arg.type)) {
          return JSON.stringify(arg.value);
        }
        if (arg.type === "object") {
          return `{${arg.value.map((pair) => {
            return `${JSON.stringify(pair[0])}:${toJson(pair[1])}`;
          }).join(",")}}`;
        }
        if (arg.type === "array") {
          return `[${arg.value?.map((val) => toJson(val)).join(",") ?? ""}]`;
        }
        throw Error(`Invalid value type: ${arg}`);
      }
      function stringFromArg(arg) {
        if (!Object.hasOwn(arg, "value")) {
          return arg.type;
        }
        switch (arg.type) {
          case "string":
          case "number":
          case "boolean":
          case "bigint":
            return String(arg.value);
          case "regexp":
            return `/${arg.value.pattern}/${arg.value.flags ?? ""}`;
          case "date":
            return new Date(arg.value).toString();
          case "object":
            return `Object(${arg.value?.length ?? ""})`;
          case "array":
            return `Array(${arg.value?.length ?? ""})`;
          case "map":
            return `Map(${arg.value?.length})`;
          case "set":
            return `Set(${arg.value?.length})`;
          default:
            return arg.type;
        }
      }
      function getRemoteValuesText(args, formatText) {
        const arg = args[0];
        if (!arg) {
          return "";
        }
        if (arg.type === "string" && isFormatSpecifier(arg.value.toString()) && formatText) {
          return logMessageFormatter(args);
        }
        return args.map((arg2) => {
          return stringFromArg(arg2);
        }).join(" ");
      }
      exports8.getRemoteValuesText = getRemoteValuesText;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/LogManager.js
  var require_LogManager = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/log/LogManager.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.LogManager = void 0;
      var protocol_js_1 = require_protocol();
      var logHelper_js_1 = require_logHelper();
      function getBidiStackTrace(cdpStackTrace) {
        const stackFrames = cdpStackTrace?.callFrames.map((callFrame) => {
          return {
            columnNumber: callFrame.columnNumber,
            functionName: callFrame.functionName,
            lineNumber: callFrame.lineNumber,
            url: callFrame.url
          };
        });
        return stackFrames ? { callFrames: stackFrames } : void 0;
      }
      function getLogLevel(consoleApiType) {
        if (["error", "assert"].includes(consoleApiType)) {
          return "error";
        }
        if (["debug", "trace"].includes(consoleApiType)) {
          return "debug";
        }
        if (["warn", "warning"].includes(consoleApiType)) {
          return "warn";
        }
        return "info";
      }
      var LogManager = class _LogManager {
        #eventManager;
        #realmStorage;
        #cdpTarget;
        constructor(cdpTarget, realmStorage, eventManager) {
          this.#cdpTarget = cdpTarget;
          this.#realmStorage = realmStorage;
          this.#eventManager = eventManager;
        }
        static create(cdpTarget, realmStorage, eventManager) {
          const logManager = new _LogManager(cdpTarget, realmStorage, eventManager);
          logManager.#initializeEntryAddedEventListener();
          return logManager;
        }
        #initializeEntryAddedEventListener() {
          this.#cdpTarget.cdpClient.on("Runtime.consoleAPICalled", (params) => {
            const realm = this.#realmStorage.findRealm({
              cdpSessionId: this.#cdpTarget.cdpSessionId,
              executionContextId: params.executionContextId
            });
            const argsPromise = realm === void 0 ? Promise.resolve(params.args) : (
              // Properly serialize arguments if possible.
              Promise.all(params.args.map((arg) => {
                return realm.serializeCdpObject(
                  arg,
                  "none"
                  /* Script.ResultOwnership.None */
                );
              }))
            );
            this.#eventManager.registerPromiseEvent(argsPromise.then((args) => ({
              kind: "success",
              value: {
                type: "event",
                method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                params: {
                  level: getLogLevel(params.type),
                  source: {
                    realm: realm?.realmId ?? "UNKNOWN",
                    context: realm?.browsingContextId ?? "UNKNOWN"
                  },
                  text: (0, logHelper_js_1.getRemoteValuesText)(args, true),
                  timestamp: Math.round(params.timestamp),
                  stackTrace: getBidiStackTrace(params.stackTrace),
                  type: "console",
                  // Console method is `warn`, not `warning`.
                  method: params.type === "warning" ? "warn" : params.type,
                  args
                }
              }
            })), realm?.browsingContextId ?? "UNKNOWN", protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
          });
          this.#cdpTarget.cdpClient.on("Runtime.exceptionThrown", (params) => {
            const realm = this.#realmStorage.findRealm({
              cdpSessionId: this.#cdpTarget.cdpSessionId,
              executionContextId: params.exceptionDetails.executionContextId
            });
            this.#eventManager.registerPromiseEvent(_LogManager.#getExceptionText(params, realm).then((text) => ({
              kind: "success",
              value: {
                type: "event",
                method: protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded,
                params: {
                  level: "error",
                  source: {
                    realm: realm?.realmId ?? "UNKNOWN",
                    context: realm?.browsingContextId ?? "UNKNOWN"
                  },
                  text,
                  timestamp: Math.round(params.timestamp),
                  stackTrace: getBidiStackTrace(params.exceptionDetails.stackTrace),
                  type: "javascript"
                }
              }
            })), realm?.browsingContextId ?? "UNKNOWN", protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded);
          });
        }
        /**
         * Try the best to get the exception text.
         */
        static async #getExceptionText(params, realm) {
          if (!params.exceptionDetails.exception) {
            return params.exceptionDetails.text;
          }
          if (realm === void 0) {
            return JSON.stringify(params.exceptionDetails.exception);
          }
          return await realm.stringifyObject(params.exceptionDetails.exception);
        }
      };
      exports8.LogManager = LogManager;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkUtils.js
  var require_NetworkUtils = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkUtils.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = exports8.cdpFetchHeadersFromBidiNetworkHeaders = exports8.bidiNetworkHeadersFromCdpFetchHeaders = exports8.cdpNetworkHeadersFromBidiNetworkHeaders = exports8.bidiNetworkHeadersFromCdpNetworkHeaders = exports8.computeHeadersSize = void 0;
      function computeHeadersSize(headers) {
        const requestHeaders = headers.reduce((acc, header) => {
          return `${acc}${header.name}: ${header.value.value}\r
`;
        }, "");
        return new TextEncoder().encode(requestHeaders).length;
      }
      exports8.computeHeadersSize = computeHeadersSize;
      function bidiNetworkHeadersFromCdpNetworkHeaders(headers) {
        if (!headers) {
          return [];
        }
        return Object.entries(headers).map(([name2, value]) => ({
          name: name2,
          value: {
            type: "string",
            value
          }
        }));
      }
      exports8.bidiNetworkHeadersFromCdpNetworkHeaders = bidiNetworkHeadersFromCdpNetworkHeaders;
      function cdpNetworkHeadersFromBidiNetworkHeaders(headers) {
        if (headers === void 0) {
          return void 0;
        }
        return headers.reduce((result, header) => {
          result[header.name] = header.value.value;
          return result;
        }, {});
      }
      exports8.cdpNetworkHeadersFromBidiNetworkHeaders = cdpNetworkHeadersFromBidiNetworkHeaders;
      function bidiNetworkHeadersFromCdpFetchHeaders(headers) {
        if (!headers) {
          return [];
        }
        return headers.map(({ name: name2, value }) => ({
          name: name2,
          value: {
            type: "string",
            value
          }
        }));
      }
      exports8.bidiNetworkHeadersFromCdpFetchHeaders = bidiNetworkHeadersFromCdpFetchHeaders;
      function cdpFetchHeadersFromBidiNetworkHeaders(headers) {
        if (headers === void 0) {
          return void 0;
        }
        return headers.map(({ name: name2, value }) => ({
          name: name2,
          value: value.value
        }));
      }
      exports8.cdpFetchHeadersFromBidiNetworkHeaders = cdpFetchHeadersFromBidiNetworkHeaders;
      function cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction(action) {
        switch (action) {
          case "default":
            return "Default";
          case "cancel":
            return "CancelAuth";
          case "provideCredentials":
            return "ProvideCredentials";
        }
      }
      exports8.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction = cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkRequest.js
  var require_NetworkRequest = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkRequest.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.NetworkRequest = void 0;
      var protocol_js_1 = require_protocol();
      var assert_js_1 = require_assert();
      var Deferred_js_1 = require_Deferred();
      var NetworkUtils_js_1 = require_NetworkUtils();
      var NetworkRequest = class _NetworkRequest {
        static #unknown = "UNKNOWN";
        /**
         * Each network request has an associated request id, which is a string
         * uniquely identifying that request.
         *
         * The identifier for a request resulting from a redirect matches that of the
         * request that initiated it.
         */
        #requestId;
        // TODO: Handle auth required?
        /**
         * Indicates the network intercept phase, if the request is currently blocked.
         * Undefined necessarily implies that the request is not blocked.
         */
        #interceptPhase = void 0;
        #servedFromCache = false;
        #redirectCount;
        #eventManager;
        #networkStorage;
        #request = {};
        #response = {};
        #beforeRequestSentDeferred = new Deferred_js_1.Deferred();
        #responseStartedDeferred = new Deferred_js_1.Deferred();
        #responseCompletedDeferred = new Deferred_js_1.Deferred();
        #cdpTarget;
        constructor(requestId, eventManager, networkStorage, cdpTarget, redirectCount = 0) {
          this.#requestId = requestId;
          this.#eventManager = eventManager;
          this.#networkStorage = networkStorage;
          this.#cdpTarget = cdpTarget;
          this.#redirectCount = redirectCount;
        }
        get requestId() {
          return this.#requestId;
        }
        get url() {
          return this.#response.info?.url ?? this.#request.info?.request.url;
        }
        get redirectCount() {
          return this.#redirectCount;
        }
        get cdpTarget() {
          return this.#cdpTarget;
        }
        isRedirecting() {
          return Boolean(this.#request.info);
        }
        handleRedirect(event) {
          this.#queueResponseStartedEvent();
          this.#queueResponseCompletedEvent();
          this.#response.hasExtraInfo = event.redirectHasExtraInfo;
          this.#response.info = event.redirectResponse;
          this.#emitEventsIfReady(true);
        }
        #emitEventsIfReady(wasRedirected = false) {
          const requestExtraInfoCompleted = (
            // Flush redirects
            wasRedirected || Boolean(this.#request.extraInfo) || // Requests from cache don't have extra info
            this.#servedFromCache || // Sometimes there is no extra info and the response
            // is the only place we can find out
            Boolean(this.#response.info && !this.#response.hasExtraInfo) || this.#interceptPhase === "beforeRequestSent"
          );
          if (this.#request.info && requestExtraInfoCompleted) {
            this.#beforeRequestSentDeferred.resolve({
              kind: "success",
              value: void 0
            });
          }
          const responseExtraInfoCompleted = Boolean(this.#response.extraInfo) || // Response from cache don't have extra info
          this.#servedFromCache || // Don't expect extra info if the flag is false
          Boolean(this.#response.info && !this.#response.hasExtraInfo) || this.#interceptPhase === "responseStarted";
          if (this.#response.info && responseExtraInfoCompleted) {
            this.#responseStartedDeferred.resolve({
              kind: "success",
              value: void 0
            });
            this.#responseCompletedDeferred.resolve({
              kind: "success",
              value: void 0
            });
          }
        }
        onRequestWillBeSentEvent(event) {
          this.#request.info = event;
          this.#queueBeforeRequestSentEvent();
          this.#emitEventsIfReady();
        }
        onRequestWillBeSentExtraInfoEvent(event) {
          this.#request.extraInfo = event;
          this.#emitEventsIfReady();
        }
        onResponseReceivedExtraInfoEvent(event) {
          this.#response.extraInfo = event;
          this.#emitEventsIfReady();
        }
        onResponseReceivedEvent(event) {
          this.#response.hasExtraInfo = event.hasExtraInfo;
          this.#response.info = event.response;
          this.#queueResponseStartedEvent();
          this.#queueResponseCompletedEvent();
          this.#emitEventsIfReady();
        }
        onServedFromCache() {
          this.#servedFromCache = true;
          this.#emitEventsIfReady();
        }
        onLoadingFailedEvent(event) {
          this.#beforeRequestSentDeferred.resolve({
            kind: "success",
            value: void 0
          });
          this.#responseStartedDeferred.resolve({
            kind: "error",
            error: new Error("Network event loading failed")
          });
          this.#responseCompletedDeferred.resolve({
            kind: "error",
            error: new Error("Network event loading failed")
          });
          this.#eventManager.registerEvent({
            type: "event",
            method: protocol_js_1.ChromiumBidi.Network.EventNames.FetchError,
            params: {
              ...this.#getBaseEventParams(),
              errorText: event.errorText
            }
          }, this.#context);
        }
        /** Fired whenever a network request interception is hit. */
        onRequestPaused(params, networkStorage) {
          if (this.#isIgnoredEvent()) {
            void this.continueRequest(params.requestId).catch(() => {
            });
            return;
          }
          let phase;
          if (params.responseErrorReason === void 0 && params.responseStatusCode === void 0) {
            phase = "beforeRequestSent";
          } else if (params.responseStatusCode === 401 && params.responseStatusText === "Unauthorized") {
            phase = "authRequired";
          } else {
            phase = "responseStarted";
          }
          const headers = (0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpFetchHeaders)(
            // TODO: Use params.request.headers if request?
            params.responseHeaders
          );
          (0, assert_js_1.assert)(this.requestId === params.networkId);
          networkStorage.addBlockedRequest(this.requestId, {
            request: params.requestId,
            // intercept request id
            phase,
            // TODO: Finish populating response / ResponseData.
            response: {
              url: params.request.url,
              // TODO: populate.
              protocol: "",
              status: params.responseStatusCode ?? 0,
              statusText: params.responseStatusText ?? "",
              // TODO: populate.
              fromCache: false,
              headers,
              // TODO: populate.
              mimeType: "",
              // TODO: populate.
              bytesReceived: 0,
              headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
              // TODO: consider removing from spec.
              bodySize: 0,
              // TODO: consider removing from spec.
              content: {
                size: 0
              },
              // TODO: populate.
              authChallenge: void 0
            }
          });
          this.#interceptPhase = phase;
          this.#emitEventsIfReady();
        }
        /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-failRequest */
        async failRequest(networkId, errorReason) {
          await this.#cdpTarget.cdpClient.sendCommand("Fetch.failRequest", {
            requestId: networkId,
            errorReason
          });
          this.#interceptPhase = void 0;
        }
        /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueRequest */
        async continueRequest(cdpFetchRequestId, url, method, headers) {
          await this.#cdpTarget.cdpClient.sendCommand("Fetch.continueRequest", {
            requestId: cdpFetchRequestId,
            url,
            method,
            headers
            // TODO: Set?
            // postData:,
            // interceptResponse:,
          });
          this.#interceptPhase = void 0;
        }
        /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueResponse */
        async continueResponse(cdpFetchRequestId, responseCode, responsePhrase, responseHeaders) {
          await this.#cdpTarget.cdpClient.sendCommand("Fetch.continueResponse", {
            requestId: cdpFetchRequestId,
            responseCode,
            responsePhrase,
            responseHeaders
          });
          this.#interceptPhase = void 0;
        }
        /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-continueWithAuth */
        async continueWithAuth(cdpFetchRequestId, response, username, password) {
          await this.#cdpTarget.cdpClient.sendCommand("Fetch.continueWithAuth", {
            requestId: cdpFetchRequestId,
            authChallengeResponse: {
              response,
              username,
              password
            }
          });
          this.#interceptPhase = void 0;
        }
        /** @see https://chromedevtools.github.io/devtools-protocol/tot/Fetch/#method-provideResponse */
        async provideResponse(cdpFetchRequestId, responseCode, responsePhrase, responseHeaders, body) {
          await this.#cdpTarget.cdpClient.sendCommand("Fetch.fulfillRequest", {
            requestId: cdpFetchRequestId,
            responseCode,
            responsePhrase,
            responseHeaders,
            ...body ? { body: btoa(body) } : {}
            // TODO: Double-check if btoa usage is correct.
          });
          this.#interceptPhase = void 0;
        }
        dispose() {
          const result = {
            kind: "error",
            error: new Error("Network processor detached")
          };
          this.#beforeRequestSentDeferred.resolve(result);
          this.#responseStartedDeferred.resolve(result);
          this.#responseCompletedDeferred.resolve(result);
        }
        get #context() {
          return this.#request.info?.frameId ?? null;
        }
        /** Returns the HTTP status code associated with this request if any. */
        get statusCode() {
          return this.#response.info?.status ?? this.#response.extraInfo?.statusCode ?? -1;
        }
        #getBaseEventParams(phase) {
          const isBlocked = phase !== void 0 && phase === this.#interceptPhase;
          const intercepts = this.#networkStorage.getNetworkIntercepts(this.#requestId, phase);
          return {
            isBlocked,
            context: this.#context,
            navigation: this.#getNavigationId(),
            redirectCount: this.#redirectCount,
            request: this.#getRequestData(),
            // Timestamp should be in milliseconds, while CDP provides it in seconds.
            timestamp: Math.round((this.#request.info?.wallTime ?? 0) * 1e3),
            // XXX: we should return correct types from the function.
            intercepts: isBlocked ? intercepts : void 0
          };
        }
        #getNavigationId() {
          if (!this.#request.info || !this.#request.info.loaderId || // When we navigate all CDP network events have `loaderId`
          // CDP's `loaderId` and `requestId` match when
          // that request triggered the loading
          this.#request.info.loaderId !== this.#request.info.requestId) {
            return null;
          }
          return this.#request.info.loaderId;
        }
        #getRequestData() {
          const cookies = this.#request.extraInfo ? _NetworkRequest.#getCookies(this.#request.extraInfo.associatedCookies) : [];
          const headers = (0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#request.info?.request.headers);
          return {
            request: this.#request.info?.requestId ?? _NetworkRequest.#unknown,
            url: this.#request.info?.request.url ?? _NetworkRequest.#unknown,
            method: this.#request.info?.request.method ?? _NetworkRequest.#unknown,
            headers,
            cookies,
            headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
            // TODO: implement.
            bodySize: 0,
            timings: this.#getTimings()
          };
        }
        // TODO: implement.
        #getTimings() {
          return {
            timeOrigin: 0,
            requestTime: 0,
            redirectStart: 0,
            redirectEnd: 0,
            fetchStart: 0,
            dnsStart: 0,
            dnsEnd: 0,
            connectStart: 0,
            connectEnd: 0,
            tlsStart: 0,
            requestStart: 0,
            responseStart: 0,
            responseEnd: 0
          };
        }
        #queueBeforeRequestSentEvent() {
          if (this.#isIgnoredEvent()) {
            return;
          }
          this.#eventManager.registerPromiseEvent(this.#beforeRequestSentDeferred.then((result) => {
            if (result.kind === "success") {
              try {
                return {
                  kind: "success",
                  value: Object.assign(this.#getBeforeRequestEvent(), {
                    type: "event"
                  })
                };
              } catch (error) {
                return {
                  kind: "error",
                  error: error instanceof Error ? error : new Error("Unknown")
                };
              }
            }
            return result;
          }), this.#context, protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent);
        }
        #getBeforeRequestEvent() {
          (0, assert_js_1.assert)(this.#request.info, "RequestWillBeSentEvent is not set");
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.BeforeRequestSent,
            params: {
              ...this.#getBaseEventParams(
                "beforeRequestSent"
                /* Network.InterceptPhase.BeforeRequestSent */
              ),
              initiator: {
                type: _NetworkRequest.#getInitiatorType(this.#request.info.initiator.type)
              }
            }
          };
        }
        #queueResponseStartedEvent() {
          if (this.#isIgnoredEvent()) {
            return;
          }
          this.#eventManager.registerPromiseEvent(this.#responseStartedDeferred.then((result) => {
            if (result.kind === "success") {
              try {
                return {
                  kind: "success",
                  value: Object.assign(this.#getResponseStartedEvent(), {
                    type: "event"
                  })
                };
              } catch (error) {
                return {
                  kind: "error",
                  error: error instanceof Error ? error : new Error("Unknown")
                };
              }
            }
            return result;
          }), this.#context, protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted);
        }
        #getResponseStartedEvent() {
          (0, assert_js_1.assert)(this.#request.info, "RequestWillBeSentEvent is not set");
          (0, assert_js_1.assert)(this.#response.info, "ResponseReceivedEvent is not set");
          if (this.#response.info.fromDiskCache) {
            this.#response.extraInfo = void 0;
          }
          const headers = (0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.info.headers);
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseStarted,
            params: {
              ...this.#getBaseEventParams(),
              response: {
                url: this.#response.info.url ?? _NetworkRequest.#unknown,
                protocol: this.#response.info.protocol ?? "",
                status: this.statusCode,
                statusText: this.#response.info.statusText,
                fromCache: this.#response.info.fromDiskCache || this.#response.info.fromPrefetchCache || this.#servedFromCache,
                headers,
                mimeType: this.#response.info.mimeType,
                bytesReceived: this.#response.info.encodedDataLength,
                headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
                // TODO: consider removing from spec.
                bodySize: 0,
                content: {
                  // TODO: consider removing from spec.
                  size: 0
                }
              }
            }
          };
        }
        #queueResponseCompletedEvent() {
          if (this.#isIgnoredEvent()) {
            return;
          }
          this.#eventManager.registerPromiseEvent(this.#responseCompletedDeferred.then((result) => {
            if (result.kind === "success") {
              try {
                return {
                  kind: "success",
                  value: Object.assign(this.#getResponseReceivedEvent(), {
                    type: "event"
                  })
                };
              } catch (error) {
                return {
                  kind: "error",
                  error: error instanceof Error ? error : new Error("Unknown")
                };
              }
            }
            return result;
          }), this.#context, protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted);
        }
        #getResponseReceivedEvent() {
          (0, assert_js_1.assert)(this.#request.info, "RequestWillBeSentEvent is not set");
          (0, assert_js_1.assert)(this.#response.info, "ResponseReceivedEvent is not set");
          if (this.#response.info.fromDiskCache) {
            this.#response.extraInfo = void 0;
          }
          const headers = (0, NetworkUtils_js_1.bidiNetworkHeadersFromCdpNetworkHeaders)(this.#response.info.headers);
          return {
            method: protocol_js_1.ChromiumBidi.Network.EventNames.ResponseCompleted,
            params: {
              ...this.#getBaseEventParams(),
              response: {
                url: this.#response.info.url ?? _NetworkRequest.#unknown,
                protocol: this.#response.info.protocol ?? "",
                status: this.statusCode,
                statusText: this.#response.info.statusText,
                fromCache: this.#response.info.fromDiskCache || this.#response.info.fromPrefetchCache || this.#servedFromCache,
                headers,
                mimeType: this.#response.info.mimeType,
                bytesReceived: this.#response.info.encodedDataLength,
                headersSize: (0, NetworkUtils_js_1.computeHeadersSize)(headers),
                // TODO: consider removing from spec.
                bodySize: 0,
                content: {
                  // TODO: consider removing from spec.
                  size: 0
                }
              }
            }
          };
        }
        #isIgnoredEvent() {
          return this.#request.info?.request.url.endsWith("/favicon.ico") ?? false;
        }
        static #getInitiatorType(initiatorType) {
          switch (initiatorType) {
            case "parser":
            case "script":
            case "preflight":
              return initiatorType;
            default:
              return "other";
          }
        }
        static #getCookies(associatedCookies) {
          return associatedCookies.filter(({ blockedReasons }) => {
            return !Array.isArray(blockedReasons) || blockedReasons.length === 0;
          }).map(({ cookie }) => {
            return {
              name: cookie.name,
              value: {
                type: "string",
                value: cookie.value
              },
              domain: cookie.domain,
              path: cookie.path,
              expires: cookie.expires,
              size: cookie.size,
              httpOnly: cookie.httpOnly,
              secure: cookie.secure,
              sameSite: _NetworkRequest.#getCookiesSameSite(cookie.sameSite)
            };
          });
        }
        static #getCookiesSameSite(cdpSameSiteValue) {
          switch (cdpSameSiteValue) {
            case "Strict":
              return "strict";
            case "Lax":
              return "lax";
            default:
              return "none";
          }
        }
      };
      exports8.NetworkRequest = NetworkRequest;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkManager.js
  var require_NetworkManager = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkManager.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.NetworkManager = void 0;
      var NetworkRequest_js_1 = require_NetworkRequest();
      var NetworkManager2 = class _NetworkManager {
        #cdpTarget;
        #eventManager;
        #networkStorage;
        constructor(cdpTarget, eventManager, networkStorage) {
          this.#cdpTarget = cdpTarget;
          this.#eventManager = eventManager;
          this.#networkStorage = networkStorage;
        }
        /** Returns the CDP Target associated with this NetworkManager instance. */
        get cdpTarget() {
          return this.#cdpTarget;
        }
        /**
         * Gets the network request with the given ID, if any.
         * Otherwise, creates a new network request with the given ID and cdp target.
         */
        #getOrCreateNetworkRequest(id, redirectCount) {
          let request = this.#networkStorage.getRequest(id);
          if (request) {
            return request;
          }
          request = new NetworkRequest_js_1.NetworkRequest(id, this.#eventManager, this.#networkStorage, this.#cdpTarget, redirectCount);
          this.#networkStorage.addRequest(request);
          return request;
        }
        static create(cdpTarget, eventManager, networkStorage) {
          const networkManager = new _NetworkManager(cdpTarget, eventManager, networkStorage);
          cdpTarget.browserCdpClient.on("Target.detachedFromTarget", (params) => {
            if (cdpTarget.cdpClient.sessionId === params.sessionId) {
              networkManager.#networkStorage.disposeRequestMap();
            }
          });
          cdpTarget.cdpClient.on("Network.requestWillBeSent", (params) => {
            const request = networkManager.#networkStorage.getRequest(params.requestId);
            if (request && request.isRedirecting()) {
              request.handleRedirect(params);
              networkManager.#networkStorage.deleteRequest(params.requestId);
              networkManager.#getOrCreateNetworkRequest(params.requestId, request.redirectCount + 1).onRequestWillBeSentEvent(params);
            } else if (request) {
              request.onRequestWillBeSentEvent(params);
            } else {
              networkManager.#getOrCreateNetworkRequest(params.requestId).onRequestWillBeSentEvent(params);
            }
          });
          cdpTarget.cdpClient.on("Network.requestWillBeSentExtraInfo", (params) => {
            networkManager.#getOrCreateNetworkRequest(params.requestId).onRequestWillBeSentExtraInfoEvent(params);
          });
          cdpTarget.cdpClient.on("Network.responseReceived", (params) => {
            networkManager.#getOrCreateNetworkRequest(params.requestId).onResponseReceivedEvent(params);
          });
          cdpTarget.cdpClient.on("Network.responseReceivedExtraInfo", (params) => {
            networkManager.#getOrCreateNetworkRequest(params.requestId).onResponseReceivedExtraInfoEvent(params);
          });
          cdpTarget.cdpClient.on("Network.requestServedFromCache", (params) => {
            networkManager.#getOrCreateNetworkRequest(params.requestId).onServedFromCache();
          });
          cdpTarget.cdpClient.on("Network.loadingFailed", (params) => {
            networkManager.#getOrCreateNetworkRequest(params.requestId).onLoadingFailedEvent(params);
          });
          cdpTarget.cdpClient.on("Fetch.requestPaused", (params) => {
            if (params.networkId) {
              networkManager.#getOrCreateNetworkRequest(params.networkId).onRequestPaused(params, networkManager.#networkStorage);
            }
          });
          return networkManager;
        }
      };
      exports8.NetworkManager = NetworkManager2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/CdpTarget.js
  var require_CdpTarget = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/CdpTarget.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.CdpTarget = void 0;
      var Deferred_js_1 = require_Deferred();
      var LogManager_js_1 = require_LogManager();
      var NetworkManager_js_1 = require_NetworkManager();
      var CdpTarget2 = class _CdpTarget {
        #targetId;
        #cdpClient;
        #browserCdpClient;
        #cdpSessionId;
        #eventManager;
        #preloadScriptStorage;
        #networkStorage;
        #targetUnblocked = new Deferred_js_1.Deferred();
        #acceptInsecureCerts;
        static create(targetId, cdpClient, browserCdpClient, cdpSessionId, realmStorage, eventManager, preloadScriptStorage, networkStorage, acceptInsecureCerts) {
          const cdpTarget = new _CdpTarget(targetId, cdpClient, browserCdpClient, cdpSessionId, eventManager, preloadScriptStorage, networkStorage, acceptInsecureCerts);
          LogManager_js_1.LogManager.create(cdpTarget, realmStorage, eventManager);
          NetworkManager_js_1.NetworkManager.create(cdpTarget, eventManager, networkStorage);
          cdpTarget.#setEventListeners();
          void cdpTarget.#unblock();
          return cdpTarget;
        }
        constructor(targetId, cdpClient, browserCdpClient, cdpSessionId, eventManager, preloadScriptStorage, networkStorage, acceptInsecureCerts) {
          this.#targetId = targetId;
          this.#cdpClient = cdpClient;
          this.#cdpSessionId = cdpSessionId;
          this.#eventManager = eventManager;
          this.#preloadScriptStorage = preloadScriptStorage;
          this.#networkStorage = networkStorage;
          this.#browserCdpClient = browserCdpClient;
          this.#acceptInsecureCerts = acceptInsecureCerts;
        }
        /** Returns a promise that resolves when the target is unblocked. */
        get targetUnblocked() {
          return this.#targetUnblocked;
        }
        get targetId() {
          return this.#targetId;
        }
        get cdpClient() {
          return this.#cdpClient;
        }
        get browserCdpClient() {
          return this.#browserCdpClient;
        }
        /** Needed for CDP escape path. */
        get cdpSessionId() {
          return this.#cdpSessionId;
        }
        /** Calls `Fetch.enable` with the added network intercepts. */
        async fetchEnable() {
          await this.#cdpClient.sendCommand("Fetch.enable", this.#networkStorage.getFetchEnableParams());
        }
        /** Calls `Fetch.disable`. */
        async fetchDisable() {
          await this.#cdpClient.sendCommand("Fetch.disable");
        }
        /**
         * Enables all the required CDP domains and unblocks the target.
         */
        async #unblock() {
          try {
            await Promise.all([
              this.#cdpClient.sendCommand("Runtime.enable"),
              this.#cdpClient.sendCommand("Page.enable"),
              this.#cdpClient.sendCommand("Page.setLifecycleEventsEnabled", {
                enabled: true
              }),
              // Set ignore certificate errors for each target.
              this.#cdpClient.sendCommand("Security.setIgnoreCertificateErrors", {
                ignore: this.#acceptInsecureCerts
              }),
              // XXX: #1080: Do not always enable the network domain globally.
              // TODO: enable Network domain for OOPiF targets.
              this.#cdpClient.sendCommand("Network.enable"),
              // XXX: #1080: Do not always enable the fetch domain globally.
              this.fetchEnable(),
              this.#cdpClient.sendCommand("Target.setAutoAttach", {
                autoAttach: true,
                waitForDebuggerOnStart: true,
                flatten: true
              }),
              this.#initAndEvaluatePreloadScripts(),
              this.#cdpClient.sendCommand("Runtime.runIfWaitingForDebugger")
            ]);
          } catch (error) {
            if (!this.#cdpClient.isCloseError(error)) {
              this.#targetUnblocked.resolve({
                kind: "error",
                error
              });
              return;
            }
          }
          this.#targetUnblocked.resolve({
            kind: "success",
            value: void 0
          });
        }
        #setEventListeners() {
          this.#cdpClient.on("*", (event, params) => {
            if (typeof event !== "string") {
              return;
            }
            this.#eventManager.registerEvent({
              type: "event",
              method: `cdp.${event}`,
              params: {
                event,
                params,
                session: this.#cdpSessionId
              }
            }, null);
          });
        }
        /**
         * All the ProxyChannels from all the preload scripts of the given
         * BrowsingContext.
         */
        getChannels() {
          return this.#preloadScriptStorage.find().flatMap((script) => script.channels);
        }
        /** Loads all top-level preload scripts. */
        async #initAndEvaluatePreloadScripts() {
          for (const script of this.#preloadScriptStorage.find({
            global: true
          })) {
            await script.initInTarget(this, true);
          }
        }
      };
      exports8.CdpTarget = CdpTarget2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextProcessor.js
  var require_BrowsingContextProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.BrowsingContextProcessor = void 0;
      var protocol_js_1 = require_protocol();
      var log_js_1 = require_log();
      var Realm_js_1 = require_Realm();
      var BrowsingContextImpl_js_1 = require_BrowsingContextImpl();
      var CdpTarget_js_1 = require_CdpTarget();
      var BrowsingContextProcessor = class {
        #browserCdpClient;
        #cdpConnection;
        #selfTargetId;
        #eventManager;
        #browsingContextStorage;
        #networkStorage;
        #acceptInsecureCerts;
        #preloadScriptStorage;
        #realmStorage;
        #logger;
        constructor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, preloadScriptStorage, acceptInsecureCerts, logger) {
          this.#acceptInsecureCerts = acceptInsecureCerts;
          this.#cdpConnection = cdpConnection;
          this.#browserCdpClient = browserCdpClient;
          this.#selfTargetId = selfTargetId;
          this.#eventManager = eventManager;
          this.#browsingContextStorage = browsingContextStorage;
          this.#preloadScriptStorage = preloadScriptStorage;
          this.#networkStorage = networkStorage;
          this.#realmStorage = realmStorage;
          this.#logger = logger;
          this.#setEventListeners(browserCdpClient);
        }
        getTree(params) {
          const resultContexts = params.root === void 0 ? this.#browsingContextStorage.getTopLevelContexts() : [this.#browsingContextStorage.getContext(params.root)];
          return {
            contexts: resultContexts.map((c7) => c7.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE))
          };
        }
        async create(params) {
          let referenceContext;
          if (params.referenceContext !== void 0) {
            referenceContext = this.#browsingContextStorage.getContext(params.referenceContext);
            if (!referenceContext.isTopLevelContext()) {
              throw new protocol_js_1.InvalidArgumentException(`referenceContext should be a top-level context`);
            }
          }
          let result;
          switch (params.type) {
            case "tab":
              result = await this.#browserCdpClient.sendCommand("Target.createTarget", {
                url: "about:blank",
                newWindow: false
              });
              break;
            case "window":
              result = await this.#browserCdpClient.sendCommand("Target.createTarget", {
                url: "about:blank",
                newWindow: true
              });
              break;
          }
          const contextId = result.targetId;
          const context = this.#browsingContextStorage.getContext(contextId);
          await context.lifecycleLoaded();
          return { context: context.id };
        }
        navigate(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          return context.navigate(
            params.url,
            params.wait ?? "none"
            /* BrowsingContext.ReadinessState.None */
          );
        }
        reload(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          return context.reload(
            params.ignoreCache ?? false,
            params.wait ?? "none"
            /* BrowsingContext.ReadinessState.None */
          );
        }
        async activate(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException("Activation is only supported on the top-level context");
          }
          await context.activate();
          return {};
        }
        async captureScreenshot(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          return await context.captureScreenshot(params);
        }
        async print(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          return await context.print(params);
        }
        async setViewport(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException("Emulating viewport is only supported on the top-level context");
          }
          await context.setViewport(params.viewport, params.devicePixelRatio);
          return {};
        }
        async traverseHistory(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          if (!context) {
            throw new protocol_js_1.InvalidArgumentException(`No browsing context with id ${params.context}`);
          }
          await context.traverseHistory(params.delta);
          return {};
        }
        async handleUserPrompt(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          await context.handleUserPrompt(params);
          return {};
        }
        async close(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          if (!context.isTopLevelContext()) {
            throw new protocol_js_1.InvalidArgumentException(`Non top-level browsing context ${context.id} cannot be closed.`);
          }
          try {
            const detachedFromTargetPromise = new Promise((resolve3) => {
              const onContextDestroyed = (event) => {
                if (event.targetId === params.context) {
                  this.#browserCdpClient.off("Target.detachedFromTarget", onContextDestroyed);
                  resolve3();
                }
              };
              this.#browserCdpClient.on("Target.detachedFromTarget", onContextDestroyed);
            });
            if (params.promptUnload) {
              await context.close();
            } else {
              await this.#browserCdpClient.sendCommand("Target.closeTarget", {
                targetId: params.context
              });
            }
            await detachedFromTargetPromise;
          } catch (error) {
            if (!(error.code === -32e3 && error.message === "Not attached to an active page")) {
              throw error;
            }
          }
          return {};
        }
        /**
         * This method is called for each CDP session, since this class is responsible
         * for creating and destroying all targets and browsing contexts.
         */
        #setEventListeners(cdpClient) {
          cdpClient.on("Target.attachedToTarget", (params) => {
            this.#handleAttachedToTargetEvent(params, cdpClient);
          });
          cdpClient.on("Target.detachedFromTarget", (params) => {
            this.#handleDetachedFromTargetEvent(params);
          });
          cdpClient.on("Target.targetInfoChanged", (params) => {
            this.#handleTargetInfoChangedEvent(params);
          });
          cdpClient.on("Page.frameAttached", (params) => {
            this.#handleFrameAttachedEvent(params);
          });
          cdpClient.on("Page.frameDetached", (params) => {
            this.#handleFrameDetachedEvent(params);
          });
        }
        #handleFrameAttachedEvent(params) {
          const parentBrowsingContext = this.#browsingContextStorage.findContext(params.parentFrameId);
          if (parentBrowsingContext !== void 0) {
            BrowsingContextImpl_js_1.BrowsingContextImpl.create(parentBrowsingContext.cdpTarget, this.#realmStorage, params.frameId, params.parentFrameId, this.#eventManager, this.#browsingContextStorage, this.#logger);
          }
        }
        #handleFrameDetachedEvent(params) {
          if (params.reason === "swap") {
            return;
          }
          this.#browsingContextStorage.findContext(params.frameId)?.dispose();
        }
        #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
          const { sessionId, targetInfo } = params;
          const targetCdpClient = this.#cdpConnection.getCdpClient(sessionId);
          this.#logger?.(log_js_1.LogType.debugInfo, "AttachedToTarget event received:", params);
          switch (targetInfo.type) {
            case "page":
            case "iframe": {
              if (targetInfo.targetId === this.#selfTargetId) {
                break;
              }
              this.#setEventListeners(targetCdpClient);
              const cdpTarget = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, this.#browserCdpClient, sessionId, this.#realmStorage, this.#eventManager, this.#preloadScriptStorage, this.#networkStorage, this.#acceptInsecureCerts);
              const maybeContext = this.#browsingContextStorage.findContext(targetInfo.targetId);
              if (maybeContext) {
                maybeContext.updateCdpTarget(cdpTarget);
              } else {
                BrowsingContextImpl_js_1.BrowsingContextImpl.create(cdpTarget, this.#realmStorage, targetInfo.targetId, null, this.#eventManager, this.#browsingContextStorage, this.#logger);
              }
              return;
            }
            case "worker": {
              this.#setEventListeners(targetCdpClient);
              const cdpTarget = CdpTarget_js_1.CdpTarget.create(targetInfo.targetId, targetCdpClient, this.#browserCdpClient, sessionId, this.#realmStorage, this.#eventManager, this.#preloadScriptStorage, this.#networkStorage, this.#acceptInsecureCerts);
              const browsingContext = parentSessionCdpClient.sessionId && this.#browsingContextStorage.findContextBySession(parentSessionCdpClient.sessionId);
              if (!browsingContext) {
                break;
              }
              this.#handleWorkerTarget(cdpTarget, browsingContext.id);
              return;
            }
          }
          targetCdpClient.sendCommand("Runtime.runIfWaitingForDebugger").then(() => parentSessionCdpClient.sendCommand("Target.detachFromTarget", params)).catch((error) => this.#logger?.(log_js_1.LogType.debugError, error));
        }
        #workers = /* @__PURE__ */ new Map();
        #handleWorkerTarget(cdpTarget, browsingContextId) {
          cdpTarget.cdpClient.on("Runtime.executionContextCreated", (params) => {
            const { uniqueId, id, origin } = params.context;
            const realm = new Realm_js_1.Realm(this.#realmStorage, this.#browsingContextStorage, uniqueId, browsingContextId, id, (0, BrowsingContextImpl_js_1.serializeOrigin)(origin), "dedicated-worker", void 0, cdpTarget.cdpClient, this.#eventManager, this.#logger);
            this.#workers.set(cdpTarget.cdpSessionId, realm);
          });
        }
        #handleDetachedFromTargetEvent(params) {
          const context = this.#browsingContextStorage.findContextBySession(params.sessionId);
          if (context) {
            context.dispose();
            this.#preloadScriptStorage.find({ targetId: context.id }).map((preloadScript) => preloadScript.dispose(context.id));
            return;
          }
          const worker = this.#workers.get(params.sessionId);
          if (worker) {
            this.#realmStorage.deleteRealms({
              cdpSessionId: worker.cdpClient.sessionId
            });
          }
        }
        #handleTargetInfoChangedEvent(params) {
          const context = this.#browsingContextStorage.findContext(params.targetInfo.targetId);
          if (context) {
            context.onTargetInfoChanged(params);
          }
        }
      };
      exports8.BrowsingContextProcessor = BrowsingContextProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputSource.js
  var require_InputSource = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputSource.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.WheelSource = exports8.PointerSource = exports8.KeySource = exports8.NoneSource = void 0;
      var NoneSource = class {
        type = "none";
      };
      exports8.NoneSource = NoneSource;
      var KeySource = class {
        type = "key";
        pressed = /* @__PURE__ */ new Set();
        // This is a bitfield that matches the modifiers parameter of
        // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchKeyEvent
        #modifiers = 0;
        get modifiers() {
          return this.#modifiers;
        }
        get alt() {
          return (this.#modifiers & 1) === 1;
        }
        set alt(value) {
          this.#setModifier(value, 1);
        }
        get ctrl() {
          return (this.#modifiers & 2) === 2;
        }
        set ctrl(value) {
          this.#setModifier(value, 2);
        }
        get meta() {
          return (this.#modifiers & 4) === 4;
        }
        set meta(value) {
          this.#setModifier(value, 4);
        }
        get shift() {
          return (this.#modifiers & 8) === 8;
        }
        set shift(value) {
          this.#setModifier(value, 8);
        }
        #setModifier(value, bit) {
          if (value) {
            this.#modifiers |= bit;
          } else {
            this.#modifiers &= ~bit;
          }
        }
      };
      exports8.KeySource = KeySource;
      var PointerSource = class {
        type = "pointer";
        subtype;
        pointerId;
        pressed = /* @__PURE__ */ new Set();
        x = 0;
        y = 0;
        constructor(id, subtype) {
          this.pointerId = id;
          this.subtype = subtype;
        }
        // This is a bitfield that matches the buttons parameter of
        // https://chromedevtools.github.io/devtools-protocol/tot/Input/#method-dispatchMouseEvent
        get buttons() {
          let buttons = 0;
          for (const button of this.pressed) {
            switch (button) {
              case 0:
                buttons |= 1;
                break;
              case 1:
                buttons |= 4;
                break;
              case 2:
                buttons |= 2;
                break;
              case 3:
                buttons |= 8;
                break;
              case 4:
                buttons |= 16;
                break;
            }
          }
          return buttons;
        }
        // --- Platform-specific code starts here ---
        // Input.dispatchMouseEvent doesn't know the concept of double click, so we
        // need to create the logic, similar to how it's done for OSes:
        // https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:ui/events/event.cc;l=479
        static ClickContext = class ClickContext {
          static #DOUBLE_CLICK_TIME_MS = 500;
          static #MAX_DOUBLE_CLICK_RADIUS = 2;
          count = 0;
          #x;
          #y;
          #time;
          constructor(x4, y6, time) {
            this.#x = x4;
            this.#y = y6;
            this.#time = time;
          }
          compare(context) {
            return (
              // The click needs to be within a certain amount of ms.
              context.#time - this.#time > ClickContext.#DOUBLE_CLICK_TIME_MS || // The click needs to be within a certain square radius.
              Math.abs(context.#x - this.#x) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS || Math.abs(context.#y - this.#y) > ClickContext.#MAX_DOUBLE_CLICK_RADIUS
            );
          }
        };
        #clickContexts = /* @__PURE__ */ new Map();
        setClickCount(button, context) {
          let storedContext = this.#clickContexts.get(button);
          if (!storedContext || storedContext.compare(context)) {
            storedContext = context;
          }
          ++storedContext.count;
          this.#clickContexts.set(button, storedContext);
          return storedContext.count;
        }
        getClickCount(button) {
          return this.#clickContexts.get(button)?.count ?? 0;
        }
      };
      exports8.PointerSource = PointerSource;
      var WheelSource = class {
        type = "wheel";
      };
      exports8.WheelSource = WheelSource;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/keyUtils.js
  var require_keyUtils = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/keyUtils.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.getKeyLocation = exports8.getKeyCode = exports8.getNormalizedKey = void 0;
      function getNormalizedKey(value) {
        switch (value) {
          case "\uE000":
            return "Unidentified";
          case "\uE001":
            return "Cancel";
          case "\uE002":
            return "Help";
          case "\uE003":
            return "Backspace";
          case "\uE004":
            return "Tab";
          case "\uE005":
            return "Clear";
          case "\uE006":
            return "Return";
          case "\uE007":
            return "Enter";
          case "\uE008":
            return "Shift";
          case "\uE009":
            return "Control";
          case "\uE00A":
            return "Alt";
          case "\uE00B":
            return "Pause";
          case "\uE00C":
            return "Escape";
          case "\uE00D":
            return " ";
          case "\uE00E":
            return "PageUp";
          case "\uE00F":
            return "PageDown";
          case "\uE010":
            return "End";
          case "\uE011":
            return "Home";
          case "\uE012":
            return "ArrowLeft";
          case "\uE013":
            return "ArrowUp";
          case "\uE014":
            return "ArrowRight";
          case "\uE015":
            return "ArrowDown";
          case "\uE016":
            return "Insert";
          case "\uE017":
            return "Delete";
          case "\uE018":
            return ";";
          case "\uE019":
            return "=";
          case "\uE01A":
            return "0";
          case "\uE01B":
            return "1";
          case "\uE01C":
            return "2";
          case "\uE01D":
            return "3";
          case "\uE01E":
            return "4";
          case "\uE01F":
            return "5";
          case "\uE020":
            return "6";
          case "\uE021":
            return "7";
          case "\uE022":
            return "8";
          case "\uE023":
            return "9";
          case "\uE024":
            return "*";
          case "\uE025":
            return "+";
          case "\uE026":
            return ",";
          case "\uE027":
            return "-";
          case "\uE028":
            return ".";
          case "\uE029":
            return "/";
          case "\uE031":
            return "F1";
          case "\uE032":
            return "F2";
          case "\uE033":
            return "F3";
          case "\uE034":
            return "F4";
          case "\uE035":
            return "F5";
          case "\uE036":
            return "F6";
          case "\uE037":
            return "F7";
          case "\uE038":
            return "F8";
          case "\uE039":
            return "F9";
          case "\uE03A":
            return "F10";
          case "\uE03B":
            return "F11";
          case "\uE03C":
            return "F12";
          case "\uE03D":
            return "Meta";
          case "\uE040":
            return "ZenkakuHankaku";
          case "\uE050":
            return "Shift";
          case "\uE051":
            return "Control";
          case "\uE052":
            return "Alt";
          case "\uE053":
            return "Meta";
          case "\uE054":
            return "PageUp";
          case "\uE055":
            return "PageDown";
          case "\uE056":
            return "End";
          case "\uE057":
            return "Home";
          case "\uE058":
            return "ArrowLeft";
          case "\uE059":
            return "ArrowUp";
          case "\uE05A":
            return "ArrowRight";
          case "\uE05B":
            return "ArrowDown";
          case "\uE05C":
            return "Insert";
          case "\uE05D":
            return "Delete";
          default:
            return value;
        }
      }
      exports8.getNormalizedKey = getNormalizedKey;
      function getKeyCode(key) {
        switch (key) {
          case "`":
          case "~":
            return "Backquote";
          case "\\":
          case "|":
            return "Backslash";
          case "\uE003":
            return "Backspace";
          case "[":
          case "{":
            return "BracketLeft";
          case "]":
          case "}":
            return "BracketRight";
          case ",":
          case "<":
            return "Comma";
          case "0":
          case ")":
            return "Digit0";
          case "1":
          case "!":
            return "Digit1";
          case "2":
          case "@":
            return "Digit2";
          case "3":
          case "#":
            return "Digit3";
          case "4":
          case "$":
            return "Digit4";
          case "5":
          case "%":
            return "Digit5";
          case "6":
          case "^":
            return "Digit6";
          case "7":
          case "&":
            return "Digit7";
          case "8":
          case "*":
            return "Digit8";
          case "9":
          case "(":
            return "Digit9";
          case "=":
          case "+":
            return "Equal";
          case "a":
          case "A":
            return "KeyA";
          case "b":
          case "B":
            return "KeyB";
          case "c":
          case "C":
            return "KeyC";
          case "d":
          case "D":
            return "KeyD";
          case "e":
          case "E":
            return "KeyE";
          case "f":
          case "F":
            return "KeyF";
          case "g":
          case "G":
            return "KeyG";
          case "h":
          case "H":
            return "KeyH";
          case "i":
          case "I":
            return "KeyI";
          case "j":
          case "J":
            return "KeyJ";
          case "k":
          case "K":
            return "KeyK";
          case "l":
          case "L":
            return "KeyL";
          case "m":
          case "M":
            return "KeyM";
          case "n":
          case "N":
            return "KeyN";
          case "o":
          case "O":
            return "KeyO";
          case "p":
          case "P":
            return "KeyP";
          case "q":
          case "Q":
            return "KeyQ";
          case "r":
          case "R":
            return "KeyR";
          case "s":
          case "S":
            return "KeyS";
          case "t":
          case "T":
            return "KeyT";
          case "u":
          case "U":
            return "KeyU";
          case "v":
          case "V":
            return "KeyV";
          case "w":
          case "W":
            return "KeyW";
          case "x":
          case "X":
            return "KeyX";
          case "y":
          case "Y":
            return "KeyY";
          case "z":
          case "Z":
            return "KeyZ";
          case "-":
          case "_":
            return "Minus";
          case ".":
            return "Period";
          case "'":
          case '"':
            return "Quote";
          case ";":
          case ":":
            return "Semicolon";
          case "/":
          case "?":
            return "Slash";
          case "\uE00A":
            return "AltLeft";
          case "\uE052":
            return "AltRight";
          case "\uE009":
            return "ControlLeft";
          case "\uE051":
            return "ControlRight";
          case "\uE006":
            return "Enter";
          case "\uE03D":
            return "MetaLeft";
          case "\uE053":
            return "MetaRight";
          case "\uE008":
            return "ShiftLeft";
          case "\uE050":
            return "ShiftRight";
          case " ":
          case "\uE00D":
            return "Space";
          case "\uE004":
            return "Tab";
          case "\uE017":
            return "Delete";
          case "\uE010":
            return "End";
          case "\uE002":
            return "Help";
          case "\uE011":
            return "Home";
          case "\uE016":
            return "Insert";
          case "\uE00F":
            return "PageDown";
          case "\uE00E":
            return "PageUp";
          case "\uE015":
            return "ArrowDown";
          case "\uE012":
            return "ArrowLeft";
          case "\uE014":
            return "ArrowRight";
          case "\uE013":
            return "ArrowUp";
          case "\uE00C":
            return "Escape";
          case "\uE031":
            return "F1";
          case "\uE032":
            return "F2";
          case "\uE033":
            return "F3";
          case "\uE034":
            return "F4";
          case "\uE035":
            return "F5";
          case "\uE036":
            return "F6";
          case "\uE037":
            return "F7";
          case "\uE038":
            return "F8";
          case "\uE039":
            return "F9";
          case "\uE03A":
            return "F10";
          case "\uE03B":
            return "F11";
          case "\uE03C":
            return "F12";
          case "\uE01A":
          case "\uE05C":
            return "Numpad0";
          case "\uE01B":
          case "\uE056":
            return "Numpad1";
          case "\uE01C":
          case "\uE05B":
            return "Numpad2";
          case "\uE01D":
          case "\uE055":
            return "Numpad3";
          case "\uE01E":
          case "\uE058":
            return "Numpad4";
          case "\uE01F":
            return "Numpad5";
          case "\uE020":
          case "\uE05A":
            return "Numpad6";
          case "\uE021":
          case "\uE057":
            return "Numpad7";
          case "\uE022":
          case "\uE059":
            return "Numpad8";
          case "\uE023":
          case "\uE054":
            return "Numpad9";
          case "\uE025":
            return "NumpadAdd";
          case "\uE026":
            return "NumpadComma";
          case "\uE028":
          case "\uE05D":
            return "NumpadDecimal";
          case "\uE029":
            return "NumpadDivide";
          case "\uE007":
            return "NumpadEnter";
          case "\uE024":
            return "NumpadMultiply";
          case "\uE027":
            return "NumpadSubtract";
          default:
            return;
        }
      }
      exports8.getKeyCode = getKeyCode;
      function getKeyLocation(key) {
        switch (key) {
          case "\uE007":
          case "\uE008":
          case "\uE009":
          case "\uE00A":
          case "\uE03D":
            return 1;
          case "\uE01A":
          case "\uE01B":
          case "\uE01C":
          case "\uE01D":
          case "\uE01E":
          case "\uE01F":
          case "\uE020":
          case "\uE021":
          case "\uE022":
          case "\uE023":
          case "\uE024":
          case "\uE025":
          case "\uE026":
          case "\uE027":
          case "\uE028":
          case "\uE029":
          case "\uE054":
          case "\uE055":
          case "\uE056":
          case "\uE057":
          case "\uE058":
          case "\uE059":
          case "\uE05A":
          case "\uE05B":
          case "\uE05C":
          case "\uE05D":
            return 3;
          case "\uE050":
          case "\uE051":
          case "\uE052":
          case "\uE053":
            return 2;
          default:
            return 0;
        }
      }
      exports8.getKeyLocation = getKeyLocation;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/USKeyboardLayout.js
  var require_USKeyboardLayout = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/USKeyboardLayout.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.KeyToKeyCode = void 0;
      exports8.KeyToKeyCode = {
        "0": 48,
        "1": 49,
        "2": 50,
        "3": 51,
        "4": 52,
        "5": 53,
        "6": 54,
        "7": 55,
        "8": 56,
        "9": 57,
        Abort: 3,
        Help: 6,
        Backspace: 8,
        Tab: 9,
        Numpad5: 12,
        NumpadEnter: 13,
        Enter: 13,
        "\\r": 13,
        "\\n": 13,
        ShiftLeft: 16,
        ShiftRight: 16,
        ControlLeft: 17,
        ControlRight: 17,
        AltLeft: 18,
        AltRight: 18,
        Pause: 19,
        CapsLock: 20,
        Escape: 27,
        Convert: 28,
        NonConvert: 29,
        Space: 32,
        Numpad9: 33,
        PageUp: 33,
        Numpad3: 34,
        PageDown: 34,
        End: 35,
        Numpad1: 35,
        Home: 36,
        Numpad7: 36,
        ArrowLeft: 37,
        Numpad4: 37,
        Numpad8: 38,
        ArrowUp: 38,
        ArrowRight: 39,
        Numpad6: 39,
        Numpad2: 40,
        ArrowDown: 40,
        Select: 41,
        Open: 43,
        PrintScreen: 44,
        Insert: 45,
        Numpad0: 45,
        Delete: 46,
        NumpadDecimal: 46,
        Digit0: 48,
        Digit1: 49,
        Digit2: 50,
        Digit3: 51,
        Digit4: 52,
        Digit5: 53,
        Digit6: 54,
        Digit7: 55,
        Digit8: 56,
        Digit9: 57,
        KeyA: 65,
        KeyB: 66,
        KeyC: 67,
        KeyD: 68,
        KeyE: 69,
        KeyF: 70,
        KeyG: 71,
        KeyH: 72,
        KeyI: 73,
        KeyJ: 74,
        KeyK: 75,
        KeyL: 76,
        KeyM: 77,
        KeyN: 78,
        KeyO: 79,
        KeyP: 80,
        KeyQ: 81,
        KeyR: 82,
        KeyS: 83,
        KeyT: 84,
        KeyU: 85,
        KeyV: 86,
        KeyW: 87,
        KeyX: 88,
        KeyY: 89,
        KeyZ: 90,
        MetaLeft: 91,
        MetaRight: 92,
        ContextMenu: 93,
        NumpadMultiply: 106,
        NumpadAdd: 107,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        F13: 124,
        F14: 125,
        F15: 126,
        F16: 127,
        F17: 128,
        F18: 129,
        F19: 130,
        F20: 131,
        F21: 132,
        F22: 133,
        F23: 134,
        F24: 135,
        NumLock: 144,
        ScrollLock: 145,
        AudioVolumeMute: 173,
        AudioVolumeDown: 174,
        AudioVolumeUp: 175,
        MediaTrackNext: 176,
        MediaTrackPrevious: 177,
        MediaStop: 178,
        MediaPlayPause: 179,
        Semicolon: 186,
        Equal: 187,
        NumpadEqual: 187,
        Comma: 188,
        Minus: 189,
        Period: 190,
        Slash: 191,
        Backquote: 192,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Quote: 222,
        AltGraph: 225,
        Props: 247,
        Cancel: 3,
        Clear: 12,
        Shift: 16,
        Control: 17,
        Alt: 18,
        Accept: 30,
        ModeChange: 31,
        " ": 32,
        Print: 42,
        Execute: 43,
        "\\u0000": 46,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        Meta: 91,
        "*": 106,
        "+": 107,
        "-": 109,
        "/": 111,
        ";": 186,
        "=": 187,
        ",": 188,
        ".": 190,
        "`": 192,
        "[": 219,
        "\\\\": 220,
        "]": 221,
        "'": 222,
        Attn: 246,
        CrSel: 247,
        ExSel: 248,
        EraseEof: 249,
        Play: 250,
        ZoomOut: 251,
        ")": 48,
        "!": 49,
        "@": 50,
        "#": 51,
        $: 52,
        "%": 53,
        "^": 54,
        "&": 55,
        "(": 57,
        A: 65,
        B: 66,
        C: 67,
        D: 68,
        E: 69,
        F: 70,
        G: 71,
        H: 72,
        I: 73,
        J: 74,
        K: 75,
        L: 76,
        M: 77,
        N: 78,
        O: 79,
        P: 80,
        Q: 81,
        R: 82,
        S: 83,
        T: 84,
        U: 85,
        V: 86,
        W: 87,
        X: 88,
        Y: 89,
        Z: 90,
        ":": 186,
        "<": 188,
        _: 189,
        ">": 190,
        "?": 191,
        "~": 192,
        "{": 219,
        "|": 220,
        "}": 221,
        '"': 222,
        Camera: 44,
        EndCall: 95,
        VolumeDown: 182,
        VolumeUp: 183
      };
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/ActionDispatcher.js
  var require_ActionDispatcher = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/ActionDispatcher.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ActionDispatcher = void 0;
      var protocol_js_1 = require_protocol();
      var assert_js_1 = require_assert();
      var InputSource_js_1 = require_InputSource();
      var keyUtils_js_1 = require_keyUtils();
      var USKeyboardLayout_js_1 = require_USKeyboardLayout();
      var CALCULATE_IN_VIEW_CENTER_PT_DECL = ((i7) => {
        const t8 = i7.getClientRects()[0], e9 = Math.max(0, Math.min(t8.x, t8.x + t8.width)), n8 = Math.min(window.innerWidth, Math.max(t8.x, t8.x + t8.width)), h8 = Math.max(0, Math.min(t8.y, t8.y + t8.height)), m6 = Math.min(window.innerHeight, Math.max(t8.y, t8.y + t8.height));
        return [e9 + (n8 - e9 >> 1), h8 + (m6 - h8 >> 1)];
      }).toString();
      var IS_MAC_DECL = (() => {
        return navigator.platform.toLowerCase().includes("mac");
      }).toString();
      async function getElementCenter(context, element) {
        const sandbox = await context.getOrCreateSandbox(void 0);
        const result = await sandbox.callFunction(CALCULATE_IN_VIEW_CENTER_PT_DECL, { type: "undefined" }, [element], false, "none", {});
        if (result.type === "exception") {
          throw new protocol_js_1.NoSuchElementException(`Origin element ${element.sharedId} was not found`);
        }
        (0, assert_js_1.assert)(result.result.type === "array");
        (0, assert_js_1.assert)(result.result.value?.[0]?.type === "number");
        (0, assert_js_1.assert)(result.result.value?.[1]?.type === "number");
        const { result: { value: [{ value: x4 }, { value: y6 }] } } = result;
        return { x: x4, y: y6 };
      }
      var ActionDispatcher = class {
        static isMacOS = async (context) => {
          const result = await (await context.getOrCreateSandbox(void 0)).callFunction(IS_MAC_DECL, { type: "undefined" }, [], false, "none", {});
          (0, assert_js_1.assert)(result.type !== "exception");
          (0, assert_js_1.assert)(result.result.type === "boolean");
          return result.result.value;
        };
        #tickStart = 0;
        #tickDuration = 0;
        #inputState;
        #context;
        #isMacOS;
        constructor(inputState, context, isMacOS) {
          this.#inputState = inputState;
          this.#context = context;
          this.#isMacOS = isMacOS;
        }
        async dispatchActions(optionsByTick) {
          await this.#inputState.queue.run(async () => {
            for (const options of optionsByTick) {
              await this.dispatchTickActions(options);
            }
          });
        }
        async dispatchTickActions(options) {
          this.#tickStart = performance.now();
          this.#tickDuration = 0;
          for (const { action } of options) {
            if ("duration" in action && action.duration !== void 0) {
              this.#tickDuration = Math.max(this.#tickDuration, action.duration);
            }
          }
          const promises3 = [
            new Promise((resolve3) => setTimeout(resolve3, this.#tickDuration))
          ];
          for (const option of options) {
            promises3.push(this.#dispatchAction(option));
          }
          await Promise.all(promises3);
        }
        async #dispatchAction({ id, action }) {
          const source2 = this.#inputState.get(id);
          const keyState = this.#inputState.getGlobalKeyState();
          switch (action.type) {
            case "keyDown": {
              await this.#dispatchKeyDownAction(source2, action);
              this.#inputState.cancelList.push({
                id,
                action: {
                  ...action,
                  type: "keyUp"
                }
              });
              break;
            }
            case "keyUp": {
              await this.#dispatchKeyUpAction(source2, action);
              break;
            }
            case "pause": {
              break;
            }
            case "pointerDown": {
              await this.#dispatchPointerDownAction(source2, keyState, action);
              this.#inputState.cancelList.push({
                id,
                action: {
                  ...action,
                  type: "pointerUp"
                }
              });
              break;
            }
            case "pointerMove": {
              await this.#dispatchPointerMoveAction(source2, keyState, action);
              break;
            }
            case "pointerUp": {
              await this.#dispatchPointerUpAction(source2, keyState, action);
              break;
            }
            case "scroll": {
              await this.#dispatchScrollAction(source2, keyState, action);
              break;
            }
          }
        }
        #dispatchPointerDownAction(source2, keyState, action) {
          const { button } = action;
          if (source2.pressed.has(button)) {
            return;
          }
          source2.pressed.add(button);
          const { x: x4, y: y6, subtype: pointerType } = source2;
          const { width, height, pressure, twist, tangentialPressure } = action;
          const { tiltX, tiltY } = getTilt(action);
          const { modifiers } = keyState;
          switch (pointerType) {
            case "mouse":
            case "pen":
              return this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                type: "mousePressed",
                x: x4,
                y: y6,
                modifiers,
                button: getCdpButton(button),
                buttons: source2.buttons,
                clickCount: source2.setClickCount(button, new InputSource_js_1.PointerSource.ClickContext(x4, y6, performance.now())),
                pointerType,
                tangentialPressure,
                tiltX,
                tiltY,
                twist,
                force: pressure
              });
            case "touch":
              return this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                type: "touchStart",
                touchPoints: [
                  {
                    x: x4,
                    y: y6,
                    ...getRadii(width ?? 1, height ?? 1),
                    tangentialPressure,
                    tiltX,
                    tiltY,
                    twist,
                    force: pressure,
                    id: source2.pointerId
                  }
                ],
                modifiers
              });
          }
        }
        #dispatchPointerUpAction(source2, keyState, action) {
          const { button } = action;
          if (!source2.pressed.has(button)) {
            return;
          }
          source2.pressed.delete(button);
          const { x: x4, y: y6, subtype: pointerType } = source2;
          const { modifiers } = keyState;
          switch (pointerType) {
            case "mouse":
            case "pen":
              return this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                type: "mouseReleased",
                x: x4,
                y: y6,
                modifiers,
                button: getCdpButton(button),
                buttons: source2.buttons,
                clickCount: source2.getClickCount(button),
                pointerType
              });
            case "touch":
              return this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                type: "touchEnd",
                touchPoints: [
                  {
                    x: x4,
                    y: y6,
                    id: source2.pointerId
                  }
                ],
                modifiers
              });
          }
        }
        async #dispatchPointerMoveAction(source2, keyState, action) {
          const { x: startX, y: startY, subtype: pointerType } = source2;
          const { width, height, pressure, twist, tangentialPressure, x: offsetX, y: offsetY, origin = "viewport", duration = this.#tickDuration } = action;
          const { tiltX, tiltY } = getTilt(action);
          const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY);
          if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
          }
          let last;
          do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let x4;
            let y6;
            if (last) {
              x4 = targetX;
              y6 = targetY;
            } else {
              x4 = Math.round(ratio * (targetX - startX) + startX);
              y6 = Math.round(ratio * (targetY - startY) + startY);
            }
            if (source2.x !== x4 || source2.y !== y6) {
              const { modifiers } = keyState;
              switch (pointerType) {
                case "mouse":
                  await this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                    type: "mouseMoved",
                    x: x4,
                    y: y6,
                    modifiers,
                    clickCount: 0,
                    button: getCdpButton(source2.pressed.values().next().value ?? 5),
                    buttons: source2.buttons,
                    pointerType,
                    tangentialPressure,
                    tiltX,
                    tiltY,
                    twist,
                    force: pressure
                  });
                  break;
                case "pen":
                  if (source2.pressed.size !== 0) {
                    await this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                      type: "mouseMoved",
                      x: x4,
                      y: y6,
                      modifiers,
                      clickCount: 0,
                      button: getCdpButton(source2.pressed.values().next().value ?? 5),
                      buttons: source2.buttons,
                      pointerType,
                      tangentialPressure,
                      tiltX,
                      tiltY,
                      twist,
                      force: pressure
                    });
                  }
                  break;
                case "touch":
                  if (source2.pressed.size !== 0) {
                    await this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchTouchEvent", {
                      type: "touchMove",
                      touchPoints: [
                        {
                          x: x4,
                          y: y6,
                          ...getRadii(width ?? 1, height ?? 1),
                          tangentialPressure,
                          tiltX,
                          tiltY,
                          twist,
                          force: pressure,
                          id: source2.pointerId
                        }
                      ],
                      modifiers
                    });
                  }
                  break;
              }
              source2.x = x4;
              source2.y = y6;
            }
          } while (!last);
        }
        async #getCoordinateFromOrigin(origin, offsetX, offsetY, startX, startY) {
          let targetX;
          let targetY;
          switch (origin) {
            case "viewport":
              targetX = offsetX;
              targetY = offsetY;
              break;
            case "pointer":
              targetX = startX + offsetX;
              targetY = startY + offsetY;
              break;
            default: {
              const { x: posX, y: posY } = await getElementCenter(this.#context, origin.element);
              targetX = posX + offsetX;
              targetY = posY + offsetY;
              break;
            }
          }
          return { targetX, targetY };
        }
        async #dispatchScrollAction(_source, keyState, action) {
          const { deltaX: targetDeltaX, deltaY: targetDeltaY, x: offsetX, y: offsetY, origin = "viewport", duration = this.#tickDuration } = action;
          if (origin === "pointer") {
            throw new protocol_js_1.InvalidArgumentException('"pointer" origin is invalid for scrolling.');
          }
          const { targetX, targetY } = await this.#getCoordinateFromOrigin(origin, offsetX, offsetY, 0, 0);
          if (targetX < 0 || targetY < 0) {
            throw new protocol_js_1.MoveTargetOutOfBoundsException(`Cannot move beyond viewport (x: ${targetX}, y: ${targetY})`);
          }
          let currentDeltaX = 0;
          let currentDeltaY = 0;
          let last;
          do {
            const ratio = duration > 0 ? (performance.now() - this.#tickStart) / duration : 1;
            last = ratio >= 1;
            let deltaX;
            let deltaY;
            if (last) {
              deltaX = targetDeltaX - currentDeltaX;
              deltaY = targetDeltaY - currentDeltaY;
            } else {
              deltaX = Math.round(ratio * targetDeltaX - currentDeltaX);
              deltaY = Math.round(ratio * targetDeltaY - currentDeltaY);
            }
            if (deltaX !== 0 || deltaY !== 0) {
              const { modifiers } = keyState;
              await this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchMouseEvent", {
                type: "mouseWheel",
                deltaX,
                deltaY,
                x: targetX,
                y: targetY,
                modifiers
              });
              currentDeltaX += deltaX;
              currentDeltaY += deltaY;
            }
          } while (!last);
        }
        async #dispatchKeyDownAction(source2, action) {
          if ([...action.value].length > 1) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${action.value}`);
          }
          const rawKey = action.value;
          const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
          const repeat = source2.pressed.has(key);
          const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
          const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
          switch (key) {
            case "Alt":
              source2.alt = true;
              break;
            case "Shift":
              source2.shift = true;
              break;
            case "Control":
              source2.ctrl = true;
              break;
            case "Meta":
              source2.meta = true;
              break;
          }
          source2.pressed.add(key);
          const { modifiers } = source2;
          const unmodifiedText = getKeyEventUnmodifiedText(key, source2);
          const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
          let command;
          if (this.#isMacOS && source2.meta) {
            switch (code) {
              case "KeyA":
                command = "SelectAll";
                break;
              case "KeyC":
                command = "Copy";
                break;
              case "KeyV":
                command = source2.shift ? "PasteAndMatchStyle" : "Paste";
                break;
              case "KeyX":
                command = "Cut";
                break;
              case "KeyZ":
                command = source2.shift ? "Redo" : "Undo";
                break;
              default:
            }
          }
          const promises3 = [
            this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
              type: text ? "keyDown" : "rawKeyDown",
              windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
              key,
              code,
              text,
              unmodifiedText,
              autoRepeat: repeat,
              isSystemKey: source2.alt || void 0,
              location: location < 3 ? location : void 0,
              isKeypad: location === 3,
              modifiers,
              commands: command ? [command] : void 0
            })
          ];
          if (key === "Escape") {
            if (!source2.alt && (this.#isMacOS && !source2.ctrl && !source2.meta || !this.#isMacOS)) {
              promises3.push(this.#context.cdpTarget.cdpClient.sendCommand("Input.cancelDragging"));
            }
          }
          await Promise.all(promises3);
        }
        #dispatchKeyUpAction(source2, action) {
          if ([...action.value].length > 1) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid key value: ${action.value}`);
          }
          const rawKey = action.value;
          const key = (0, keyUtils_js_1.getNormalizedKey)(rawKey);
          if (!source2.pressed.has(key)) {
            return;
          }
          const code = (0, keyUtils_js_1.getKeyCode)(rawKey);
          const location = (0, keyUtils_js_1.getKeyLocation)(rawKey);
          switch (key) {
            case "Alt":
              source2.alt = false;
              break;
            case "Shift":
              source2.shift = false;
              break;
            case "Control":
              source2.ctrl = false;
              break;
            case "Meta":
              source2.meta = false;
              break;
          }
          source2.pressed.delete(key);
          const { modifiers } = source2;
          const unmodifiedText = getKeyEventUnmodifiedText(key, source2);
          const text = getKeyEventText(code ?? "", source2) ?? unmodifiedText;
          return this.#context.cdpTarget.cdpClient.sendCommand("Input.dispatchKeyEvent", {
            type: "keyUp",
            windowsVirtualKeyCode: USKeyboardLayout_js_1.KeyToKeyCode[key],
            key,
            code,
            text,
            unmodifiedText,
            location: location < 3 ? location : void 0,
            isSystemKey: source2.alt || void 0,
            isKeypad: location === 3,
            modifiers
          });
        }
      };
      exports8.ActionDispatcher = ActionDispatcher;
      var getKeyEventUnmodifiedText = (key, source2) => {
        if (key === "Enter") {
          return "\r";
        }
        return [...key].length === 1 ? source2.shift ? key.toLocaleUpperCase("en-US") : key : void 0;
      };
      var getKeyEventText = (code, source2) => {
        if (source2.ctrl) {
          switch (code) {
            case "Digit2":
              if (source2.shift) {
                return "\0";
              }
              break;
            case "KeyA":
              return "";
            case "KeyB":
              return "";
            case "KeyC":
              return "";
            case "KeyD":
              return "";
            case "KeyE":
              return "";
            case "KeyF":
              return "";
            case "KeyG":
              return "\x07";
            case "KeyH":
              return "\b";
            case "KeyI":
              return "	";
            case "KeyJ":
              return "\n";
            case "KeyK":
              return "\v";
            case "KeyL":
              return "\f";
            case "KeyM":
              return "\r";
            case "KeyN":
              return "";
            case "KeyO":
              return "";
            case "KeyP":
              return "";
            case "KeyQ":
              return "";
            case "KeyR":
              return "";
            case "KeyS":
              return "";
            case "KeyT":
              return "";
            case "KeyU":
              return "";
            case "KeyV":
              return "";
            case "KeyW":
              return "";
            case "KeyX":
              return "";
            case "KeyY":
              return "";
            case "KeyZ":
              return "";
            case "BracketLeft":
              return "\x1B";
            case "Backslash":
              return "";
            case "BracketRight":
              return "";
            case "Digit6":
              if (source2.shift) {
                return "";
              }
              break;
            case "Minus":
              return "";
          }
          return "";
        }
        if (source2.alt) {
          return "";
        }
        return;
      };
      function getCdpButton(button) {
        switch (button) {
          case 0:
            return "left";
          case 1:
            return "middle";
          case 2:
            return "right";
          case 3:
            return "back";
          case 4:
            return "forward";
          default:
            return "none";
        }
      }
      function getTilt(action) {
        const altitudeAngle = action.altitudeAngle ?? 0;
        const azimuthAngle = action.azimuthAngle ?? 0;
        let tiltXRadians = 0;
        let tiltYRadians = 0;
        if (altitudeAngle === 0) {
          if (azimuthAngle === 0 || azimuthAngle === 2 * Math.PI) {
            tiltXRadians = Math.PI / 2;
          }
          if (azimuthAngle === Math.PI / 2) {
            tiltYRadians = Math.PI / 2;
          }
          if (azimuthAngle === Math.PI) {
            tiltXRadians = -Math.PI / 2;
          }
          if (azimuthAngle === 3 * Math.PI / 2) {
            tiltYRadians = -Math.PI / 2;
          }
          if (azimuthAngle > 0 && azimuthAngle < Math.PI / 2) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = Math.PI / 2;
          }
          if (azimuthAngle > Math.PI / 2 && azimuthAngle < Math.PI) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = Math.PI / 2;
          }
          if (azimuthAngle > Math.PI && azimuthAngle < 3 * Math.PI / 2) {
            tiltXRadians = -Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
          }
          if (azimuthAngle > 3 * Math.PI / 2 && azimuthAngle < 2 * Math.PI) {
            tiltXRadians = Math.PI / 2;
            tiltYRadians = -Math.PI / 2;
          }
        }
        if (altitudeAngle !== 0) {
          const tanAlt = Math.tan(altitudeAngle);
          tiltXRadians = Math.atan(Math.cos(azimuthAngle) / tanAlt);
          tiltYRadians = Math.atan(Math.sin(azimuthAngle) / tanAlt);
        }
        const factor = 180 / Math.PI;
        return {
          tiltX: Math.round(tiltXRadians * factor),
          tiltY: Math.round(tiltYRadians * factor)
        };
      }
      function getRadii(width, height) {
        return {
          radiusX: width ? width / 2 : 0.5,
          radiusY: height ? height / 2 : 0.5
        };
      }
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/Mutex.js
  var require_Mutex = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/Mutex.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.Mutex = void 0;
      var Mutex2 = class {
        #locked = false;
        #acquirers = [];
        // This is FIFO.
        acquire() {
          const state = { resolved: false };
          if (this.#locked) {
            return new Promise((resolve3) => {
              this.#acquirers.push(() => resolve3(this.#release.bind(this, state)));
            });
          }
          this.#locked = true;
          return Promise.resolve(this.#release.bind(this, state));
        }
        #release(state) {
          if (state.resolved) {
            throw new Error("Cannot release more than once.");
          }
          state.resolved = true;
          const resolve3 = this.#acquirers.shift();
          if (!resolve3) {
            this.#locked = false;
            return;
          }
          resolve3();
        }
        async run(action) {
          const release2 = await this.acquire();
          try {
            const result = await action();
            return result;
          } finally {
            release2();
          }
        }
      };
      exports8.Mutex = Mutex2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputState.js
  var require_InputState = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputState.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.InputState = void 0;
      var protocol_js_1 = require_protocol();
      var Mutex_js_1 = require_Mutex();
      var InputSource_js_1 = require_InputSource();
      var InputState = class {
        cancelList = [];
        #sources = /* @__PURE__ */ new Map();
        #mutex = new Mutex_js_1.Mutex();
        getOrCreate(id, type, subtype) {
          let source2 = this.#sources.get(id);
          if (!source2) {
            switch (type) {
              case "none":
                source2 = new InputSource_js_1.NoneSource();
                break;
              case "key":
                source2 = new InputSource_js_1.KeySource();
                break;
              case "pointer": {
                let pointerId = subtype === "mouse" ? 0 : 2;
                const pointerIds = /* @__PURE__ */ new Set();
                for (const [, source3] of this.#sources) {
                  if (source3.type === "pointer") {
                    pointerIds.add(source3.pointerId);
                  }
                }
                while (pointerIds.has(pointerId)) {
                  ++pointerId;
                }
                source2 = new InputSource_js_1.PointerSource(pointerId, subtype);
                break;
              }
              case "wheel":
                source2 = new InputSource_js_1.WheelSource();
                break;
              default:
                throw new protocol_js_1.InvalidArgumentException(`Expected "${"none"}", "${"key"}", "${"pointer"}", or "${"wheel"}". Found unknown source type ${type}.`);
            }
            this.#sources.set(id, source2);
            return source2;
          }
          if (source2.type !== type) {
            throw new protocol_js_1.InvalidArgumentException(`Input source type of ${id} is ${source2.type}, but received ${type}.`);
          }
          return source2;
        }
        get(id) {
          const source2 = this.#sources.get(id);
          if (!source2) {
            throw new protocol_js_1.UnknownErrorException(`Internal error.`);
          }
          return source2;
        }
        getGlobalKeyState() {
          const state = new InputSource_js_1.KeySource();
          for (const [, source2] of this.#sources) {
            if (source2.type !== "key") {
              continue;
            }
            for (const pressed of source2.pressed) {
              state.pressed.add(pressed);
            }
            state.alt ||= source2.alt;
            state.ctrl ||= source2.ctrl;
            state.meta ||= source2.meta;
            state.shift ||= source2.shift;
          }
          return state;
        }
        get queue() {
          return this.#mutex;
        }
      };
      exports8.InputState = InputState;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputStateManager.js
  var require_InputStateManager = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputStateManager.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.InputStateManager = void 0;
      var assert_js_1 = require_assert();
      var InputState_js_1 = require_InputState();
      var InputStateManager = class extends WeakMap {
        get(context) {
          (0, assert_js_1.assert)(context.isTopLevelContext());
          if (!this.has(context)) {
            this.set(context, new InputState_js_1.InputState());
          }
          return super.get(context);
        }
      };
      exports8.InputStateManager = InputStateManager;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputProcessor.js
  var require_InputProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/input/InputProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.InputProcessor = void 0;
      var protocol_js_1 = require_protocol();
      var ActionDispatcher_js_1 = require_ActionDispatcher();
      var InputStateManager_js_1 = require_InputStateManager();
      var InputProcessor = class {
        #browsingContextStorage;
        #inputStateManager = new InputStateManager_js_1.InputStateManager();
        constructor(browsingContextStorage) {
          this.#browsingContextStorage = browsingContextStorage;
        }
        async performActions(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          const inputState = this.#inputStateManager.get(context.top);
          const actionsByTick = this.#getActionsByTick(params, inputState);
          const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
          await dispatcher.dispatchActions(actionsByTick);
          return {};
        }
        async releaseActions(params) {
          const context = this.#browsingContextStorage.getContext(params.context);
          const topContext = context.top;
          const inputState = this.#inputStateManager.get(topContext);
          const dispatcher = new ActionDispatcher_js_1.ActionDispatcher(inputState, context, await ActionDispatcher_js_1.ActionDispatcher.isMacOS(context).catch(() => false));
          await dispatcher.dispatchTickActions(inputState.cancelList.reverse());
          this.#inputStateManager.delete(topContext);
          return {};
        }
        #getActionsByTick(params, inputState) {
          const actionsByTick = [];
          for (const action of params.actions) {
            switch (action.type) {
              case "pointer": {
                action.parameters ??= {
                  pointerType: "mouse"
                  /* Input.PointerType.Mouse */
                };
                action.parameters.pointerType ??= "mouse";
                const source2 = inputState.getOrCreate(action.id, "pointer", action.parameters.pointerType);
                if (source2.subtype !== action.parameters.pointerType) {
                  throw new protocol_js_1.InvalidArgumentException(`Expected input source ${action.id} to be ${source2.subtype}; got ${action.parameters.pointerType}.`);
                }
                break;
              }
              default:
                inputState.getOrCreate(action.id, action.type);
            }
            const actions = action.actions.map((item) => ({
              id: action.id,
              action: item
            }));
            for (let i7 = 0; i7 < actions.length; i7++) {
              if (actionsByTick.length === i7) {
                actionsByTick.push([]);
              }
              actionsByTick[i7].push(actions[i7]);
            }
          }
          return actionsByTick;
        }
      };
      exports8.InputProcessor = InputProcessor;
    }
  });

  // node_modules/urlpattern-polyfill/dist/urlpattern.cjs
  var require_urlpattern = __commonJS({
    "node_modules/urlpattern-polyfill/dist/urlpattern.cjs"(exports8, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var M4 = Object.defineProperty;
      var Se3 = Object.getOwnPropertyDescriptor;
      var ke3 = Object.getOwnPropertyNames;
      var Ee3 = Object.prototype.hasOwnProperty;
      var Re2 = (e9, t8) => {
        for (var r9 in t8)
          M4(e9, r9, { get: t8[r9], enumerable: true });
      };
      var ye3 = (e9, t8, r9, n8) => {
        if (t8 && typeof t8 == "object" || typeof t8 == "function")
          for (let a8 of ke3(t8))
            !Ee3.call(e9, a8) && a8 !== r9 && M4(e9, a8, { get: () => t8[a8], enumerable: !(n8 = Se3(t8, a8)) || n8.enumerable });
        return e9;
      };
      var Oe3 = (e9) => ye3(M4({}, "__esModule", { value: true }), e9);
      var Ne2 = {};
      Re2(Ne2, { URLPattern: () => Y5 });
      module.exports = Oe3(Ne2);
      var k5 = class {
        type = 3;
        name = "";
        prefix = "";
        value = "";
        suffix = "";
        modifier = 3;
        constructor(t8, r9, n8, a8, c7, l7) {
          this.type = t8, this.name = r9, this.prefix = n8, this.value = a8, this.suffix = c7, this.modifier = l7;
        }
        hasCustomName() {
          return this.name !== "" && typeof this.name != "number";
        }
      };
      var Te2 = /[$_\p{ID_Start}]/u;
      var Ae3 = /[$_\u200C\u200D\p{ID_Continue}]/u;
      var v7 = ".*";
      function we3(e9, t8) {
        return (t8 ? /^[\x00-\xFF]*$/ : /^[\x00-\x7F]*$/).test(e9);
      }
      function D5(e9, t8 = false) {
        let r9 = [], n8 = 0;
        for (; n8 < e9.length; ) {
          let a8 = e9[n8], c7 = function(l7) {
            if (!t8)
              throw new TypeError(l7);
            r9.push({ type: "INVALID_CHAR", index: n8, value: e9[n8++] });
          };
          if (a8 === "*") {
            r9.push({ type: "ASTERISK", index: n8, value: e9[n8++] });
            continue;
          }
          if (a8 === "+" || a8 === "?") {
            r9.push({ type: "OTHER_MODIFIER", index: n8, value: e9[n8++] });
            continue;
          }
          if (a8 === "\\") {
            r9.push({ type: "ESCAPED_CHAR", index: n8++, value: e9[n8++] });
            continue;
          }
          if (a8 === "{") {
            r9.push({ type: "OPEN", index: n8, value: e9[n8++] });
            continue;
          }
          if (a8 === "}") {
            r9.push({ type: "CLOSE", index: n8, value: e9[n8++] });
            continue;
          }
          if (a8 === ":") {
            let l7 = "", s7 = n8 + 1;
            for (; s7 < e9.length; ) {
              let i7 = e9.substr(s7, 1);
              if (s7 === n8 + 1 && Te2.test(i7) || s7 !== n8 + 1 && Ae3.test(i7)) {
                l7 += e9[s7++];
                continue;
              }
              break;
            }
            if (!l7) {
              c7(`Missing parameter name at ${n8}`);
              continue;
            }
            r9.push({ type: "NAME", index: n8, value: l7 }), n8 = s7;
            continue;
          }
          if (a8 === "(") {
            let l7 = 1, s7 = "", i7 = n8 + 1, o8 = false;
            if (e9[i7] === "?") {
              c7(`Pattern cannot start with "?" at ${i7}`);
              continue;
            }
            for (; i7 < e9.length; ) {
              if (!we3(e9[i7], false)) {
                c7(`Invalid character '${e9[i7]}' at ${i7}.`), o8 = true;
                break;
              }
              if (e9[i7] === "\\") {
                s7 += e9[i7++] + e9[i7++];
                continue;
              }
              if (e9[i7] === ")") {
                if (l7--, l7 === 0) {
                  i7++;
                  break;
                }
              } else if (e9[i7] === "(" && (l7++, e9[i7 + 1] !== "?")) {
                c7(`Capturing groups are not allowed at ${i7}`), o8 = true;
                break;
              }
              s7 += e9[i7++];
            }
            if (o8)
              continue;
            if (l7) {
              c7(`Unbalanced pattern at ${n8}`);
              continue;
            }
            if (!s7) {
              c7(`Missing pattern at ${n8}`);
              continue;
            }
            r9.push({ type: "REGEX", index: n8, value: s7 }), n8 = i7;
            continue;
          }
          r9.push({ type: "CHAR", index: n8, value: e9[n8++] });
        }
        return r9.push({ type: "END", index: n8, value: "" }), r9;
      }
      function F5(e9, t8 = {}) {
        let r9 = D5(e9);
        t8.delimiter ??= "/#?", t8.prefixes ??= "./";
        let n8 = `[^${x4(t8.delimiter)}]+?`, a8 = [], c7 = 0, l7 = 0, s7 = "", i7 = /* @__PURE__ */ new Set(), o8 = (f7) => {
          if (l7 < r9.length && r9[l7].type === f7)
            return r9[l7++].value;
        }, h8 = () => o8("OTHER_MODIFIER") ?? o8("ASTERISK"), p8 = (f7) => {
          let u7 = o8(f7);
          if (u7 !== void 0)
            return u7;
          let { type: d7, index: T6 } = r9[l7];
          throw new TypeError(`Unexpected ${d7} at ${T6}, expected ${f7}`);
        }, O5 = () => {
          let f7 = "", u7;
          for (; u7 = o8("CHAR") ?? o8("ESCAPED_CHAR"); )
            f7 += u7;
          return f7;
        }, be3 = (f7) => f7, L5 = t8.encodePart || be3, I5 = "", H4 = (f7) => {
          I5 += f7;
        }, $4 = () => {
          I5.length && (a8.push(new k5(3, "", "", L5(I5), "", 3)), I5 = "");
        }, X4 = (f7, u7, d7, T6, Z3) => {
          let g5 = 3;
          switch (Z3) {
            case "?":
              g5 = 1;
              break;
            case "*":
              g5 = 0;
              break;
            case "+":
              g5 = 2;
              break;
          }
          if (!u7 && !d7 && g5 === 3) {
            H4(f7);
            return;
          }
          if ($4(), !u7 && !d7) {
            if (!f7)
              return;
            a8.push(new k5(3, "", "", L5(f7), "", g5));
            return;
          }
          let m6;
          d7 ? d7 === "*" ? m6 = v7 : m6 = d7 : m6 = n8;
          let R5 = 2;
          m6 === n8 ? (R5 = 1, m6 = "") : m6 === v7 && (R5 = 0, m6 = "");
          let S5;
          if (u7 ? S5 = u7 : d7 && (S5 = c7++), i7.has(S5))
            throw new TypeError(`Duplicate name '${S5}'.`);
          i7.add(S5), a8.push(new k5(R5, S5, L5(f7), m6, L5(T6), g5));
        };
        for (; l7 < r9.length; ) {
          let f7 = o8("CHAR"), u7 = o8("NAME"), d7 = o8("REGEX");
          if (!u7 && !d7 && (d7 = o8("ASTERISK")), u7 || d7) {
            let g5 = f7 ?? "";
            t8.prefixes.indexOf(g5) === -1 && (H4(g5), g5 = ""), $4();
            let m6 = h8();
            X4(g5, u7, d7, "", m6);
            continue;
          }
          let T6 = f7 ?? o8("ESCAPED_CHAR");
          if (T6) {
            H4(T6);
            continue;
          }
          if (o8("OPEN")) {
            let g5 = O5(), m6 = o8("NAME"), R5 = o8("REGEX");
            !m6 && !R5 && (R5 = o8("ASTERISK"));
            let S5 = O5();
            p8("CLOSE");
            let Pe2 = h8();
            X4(g5, m6, R5, S5, Pe2);
            continue;
          }
          $4(), p8("END");
        }
        return a8;
      }
      function x4(e9) {
        return e9.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
      }
      function B5(e9) {
        return e9 && e9.ignoreCase ? "ui" : "u";
      }
      function q4(e9, t8, r9) {
        return W4(F5(e9, r9), t8, r9);
      }
      function y6(e9) {
        switch (e9) {
          case 0:
            return "*";
          case 1:
            return "?";
          case 2:
            return "+";
          case 3:
            return "";
        }
      }
      function W4(e9, t8, r9 = {}) {
        r9.delimiter ??= "/#?", r9.prefixes ??= "./", r9.sensitive ??= false, r9.strict ??= false, r9.end ??= true, r9.start ??= true, r9.endsWith = "";
        let n8 = r9.start ? "^" : "";
        for (let s7 of e9) {
          if (s7.type === 3) {
            s7.modifier === 3 ? n8 += x4(s7.value) : n8 += `(?:${x4(s7.value)})${y6(s7.modifier)}`;
            continue;
          }
          t8 && t8.push(s7.name);
          let i7 = `[^${x4(r9.delimiter)}]+?`, o8 = s7.value;
          if (s7.type === 1 ? o8 = i7 : s7.type === 0 && (o8 = v7), !s7.prefix.length && !s7.suffix.length) {
            s7.modifier === 3 || s7.modifier === 1 ? n8 += `(${o8})${y6(s7.modifier)}` : n8 += `((?:${o8})${y6(s7.modifier)})`;
            continue;
          }
          if (s7.modifier === 3 || s7.modifier === 1) {
            n8 += `(?:${x4(s7.prefix)}(${o8})${x4(s7.suffix)})`, n8 += y6(s7.modifier);
            continue;
          }
          n8 += `(?:${x4(s7.prefix)}`, n8 += `((?:${o8})(?:`, n8 += x4(s7.suffix), n8 += x4(s7.prefix), n8 += `(?:${o8}))*)${x4(s7.suffix)})`, s7.modifier === 0 && (n8 += "?");
        }
        let a8 = `[${x4(r9.endsWith)}]|$`, c7 = `[${x4(r9.delimiter)}]`;
        if (r9.end)
          return r9.strict || (n8 += `${c7}?`), r9.endsWith.length ? n8 += `(?=${a8})` : n8 += "$", new RegExp(n8, B5(r9));
        r9.strict || (n8 += `(?:${c7}(?=${a8}))?`);
        let l7 = false;
        if (e9.length) {
          let s7 = e9[e9.length - 1];
          s7.type === 3 && s7.modifier === 3 && (l7 = r9.delimiter.indexOf(s7) > -1);
        }
        return l7 || (n8 += `(?=${c7}|${a8})`), new RegExp(n8, B5(r9));
      }
      var b6 = { delimiter: "", prefixes: "", sensitive: true, strict: true };
      var J4 = { delimiter: ".", prefixes: "", sensitive: true, strict: true };
      var Q4 = { delimiter: "/", prefixes: "/", sensitive: true, strict: true };
      function ee3(e9, t8) {
        return e9.length ? e9[0] === "/" ? true : !t8 || e9.length < 2 ? false : (e9[0] == "\\" || e9[0] == "{") && e9[1] == "/" : false;
      }
      function te3(e9, t8) {
        return e9.startsWith(t8) ? e9.substring(t8.length, e9.length) : e9;
      }
      function Ce2(e9, t8) {
        return e9.endsWith(t8) ? e9.substr(0, e9.length - t8.length) : e9;
      }
      function _5(e9) {
        return !e9 || e9.length < 2 ? false : e9[0] === "[" || (e9[0] === "\\" || e9[0] === "{") && e9[1] === "[";
      }
      var re3 = ["ftp", "file", "http", "https", "ws", "wss"];
      function N5(e9) {
        if (!e9)
          return true;
        for (let t8 of re3)
          if (e9.test(t8))
            return true;
        return false;
      }
      function ne3(e9, t8) {
        if (e9 = te3(e9, "#"), t8 || e9 === "")
          return e9;
        let r9 = new URL("https://example.com");
        return r9.hash = e9, r9.hash ? r9.hash.substring(1, r9.hash.length) : "";
      }
      function se3(e9, t8) {
        if (e9 = te3(e9, "?"), t8 || e9 === "")
          return e9;
        let r9 = new URL("https://example.com");
        return r9.search = e9, r9.search ? r9.search.substring(1, r9.search.length) : "";
      }
      function ie2(e9, t8) {
        return t8 || e9 === "" ? e9 : _5(e9) ? K4(e9) : j5(e9);
      }
      function ae3(e9, t8) {
        if (t8 || e9 === "")
          return e9;
        let r9 = new URL("https://example.com");
        return r9.password = e9, r9.password;
      }
      function oe3(e9, t8) {
        if (t8 || e9 === "")
          return e9;
        let r9 = new URL("https://example.com");
        return r9.username = e9, r9.username;
      }
      function ce3(e9, t8, r9) {
        if (r9 || e9 === "")
          return e9;
        if (t8 && !re3.includes(t8))
          return new URL(`${t8}:${e9}`).pathname;
        let n8 = e9[0] == "/";
        return e9 = new URL(n8 ? e9 : "/-" + e9, "https://example.com").pathname, n8 || (e9 = e9.substring(2, e9.length)), e9;
      }
      function le3(e9, t8, r9) {
        return z5(t8) === e9 && (e9 = ""), r9 || e9 === "" ? e9 : V4(e9);
      }
      function he3(e9, t8) {
        return e9 = Ce2(e9, ":"), t8 || e9 === "" ? e9 : A5(e9);
      }
      function z5(e9) {
        switch (e9) {
          case "ws":
          case "http":
            return "80";
          case "wws":
          case "https":
            return "443";
          case "ftp":
            return "21";
          default:
            return "";
        }
      }
      function A5(e9) {
        if (e9 === "")
          return e9;
        if (/^[-+.A-Za-z0-9]*$/.test(e9))
          return e9.toLowerCase();
        throw new TypeError(`Invalid protocol '${e9}'.`);
      }
      function fe3(e9) {
        if (e9 === "")
          return e9;
        let t8 = new URL("https://example.com");
        return t8.username = e9, t8.username;
      }
      function ue3(e9) {
        if (e9 === "")
          return e9;
        let t8 = new URL("https://example.com");
        return t8.password = e9, t8.password;
      }
      function j5(e9) {
        if (e9 === "")
          return e9;
        if (/[\t\n\r #%/:<>?@[\]^\\|]/g.test(e9))
          throw new TypeError(`Invalid hostname '${e9}'`);
        let t8 = new URL("https://example.com");
        return t8.hostname = e9, t8.hostname;
      }
      function K4(e9) {
        if (e9 === "")
          return e9;
        if (/[^0-9a-fA-F[\]:]/g.test(e9))
          throw new TypeError(`Invalid IPv6 hostname '${e9}'`);
        return e9.toLowerCase();
      }
      function V4(e9) {
        if (e9 === "" || /^[0-9]*$/.test(e9) && parseInt(e9) <= 65535)
          return e9;
        throw new TypeError(`Invalid port '${e9}'.`);
      }
      function pe3(e9) {
        if (e9 === "")
          return e9;
        let t8 = new URL("https://example.com");
        return t8.pathname = e9[0] !== "/" ? "/-" + e9 : e9, e9[0] !== "/" ? t8.pathname.substring(2, t8.pathname.length) : t8.pathname;
      }
      function de3(e9) {
        return e9 === "" ? e9 : new URL(`data:${e9}`).pathname;
      }
      function ge3(e9) {
        if (e9 === "")
          return e9;
        let t8 = new URL("https://example.com");
        return t8.search = e9, t8.search.substring(1, t8.search.length);
      }
      function me3(e9) {
        if (e9 === "")
          return e9;
        let t8 = new URL("https://example.com");
        return t8.hash = e9, t8.hash.substring(1, t8.hash.length);
      }
      var U5 = class {
        #i;
        #n = [];
        #t = {};
        #e = 0;
        #s = 1;
        #u = 0;
        #c = 0;
        #p = 0;
        #d = 0;
        #g = false;
        constructor(t8) {
          this.#i = t8;
        }
        get result() {
          return this.#t;
        }
        parse() {
          for (this.#n = D5(this.#i, true); this.#e < this.#n.length; this.#e += this.#s) {
            if (this.#s = 1, this.#n[this.#e].type === "END") {
              if (this.#c === 0) {
                this.#P(), this.#l() ? this.#r(9, 1) : this.#h() ? (this.#r(8, 1), this.#t.hash = "") : (this.#r(7, 0), this.#t.search = "", this.#t.hash = "");
                continue;
              } else if (this.#c === 2) {
                this.#f(5);
                continue;
              }
              this.#r(10, 0);
              break;
            }
            if (this.#p > 0)
              if (this.#T())
                this.#p -= 1;
              else
                continue;
            if (this.#O()) {
              this.#p += 1;
              continue;
            }
            switch (this.#c) {
              case 0:
                this.#S() && (this.#t.username = "", this.#t.password = "", this.#t.hostname = "", this.#t.port = "", this.#t.pathname = "", this.#t.search = "", this.#t.hash = "", this.#f(1));
                break;
              case 1:
                if (this.#S()) {
                  this.#C();
                  let t8 = 7, r9 = 1;
                  this.#g && (this.#t.pathname = "/"), this.#E() ? (t8 = 2, r9 = 3) : this.#g && (t8 = 2), this.#r(t8, r9);
                }
                break;
              case 2:
                this.#x() ? this.#f(3) : (this.#b() || this.#h() || this.#l()) && this.#f(5);
                break;
              case 3:
                this.#R() ? this.#r(4, 1) : this.#x() && this.#r(5, 1);
                break;
              case 4:
                this.#x() && this.#r(5, 1);
                break;
              case 5:
                this.#A() ? this.#d += 1 : this.#w() && (this.#d -= 1), this.#y() && !this.#d ? this.#r(6, 1) : this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
                break;
              case 6:
                this.#b() ? this.#r(7, 0) : this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
                break;
              case 7:
                this.#h() ? this.#r(8, 1) : this.#l() && this.#r(9, 1);
                break;
              case 8:
                this.#l() && this.#r(9, 1);
                break;
              case 9:
                break;
              case 10:
                break;
            }
          }
        }
        #r(t8, r9) {
          switch (this.#c) {
            case 0:
              break;
            case 1:
              this.#t.protocol = this.#o();
              break;
            case 2:
              break;
            case 3:
              this.#t.username = this.#o();
              break;
            case 4:
              this.#t.password = this.#o();
              break;
            case 5:
              this.#t.hostname = this.#o();
              break;
            case 6:
              this.#t.port = this.#o();
              break;
            case 7:
              this.#t.pathname = this.#o();
              break;
            case 8:
              this.#t.search = this.#o();
              break;
            case 9:
              this.#t.hash = this.#o();
              break;
            case 10:
              break;
          }
          this.#k(t8, r9);
        }
        #k(t8, r9) {
          this.#c = t8, this.#u = this.#e + r9, this.#e += r9, this.#s = 0;
        }
        #P() {
          this.#e = this.#u, this.#s = 0;
        }
        #f(t8) {
          this.#P(), this.#c = t8;
        }
        #m(t8) {
          return t8 < 0 && (t8 = this.#n.length - t8), t8 < this.#n.length ? this.#n[t8] : this.#n[this.#n.length - 1];
        }
        #a(t8, r9) {
          let n8 = this.#m(t8);
          return n8.value === r9 && (n8.type === "CHAR" || n8.type === "ESCAPED_CHAR" || n8.type === "INVALID_CHAR");
        }
        #S() {
          return this.#a(this.#e, ":");
        }
        #E() {
          return this.#a(this.#e + 1, "/") && this.#a(this.#e + 2, "/");
        }
        #x() {
          return this.#a(this.#e, "@");
        }
        #R() {
          return this.#a(this.#e, ":");
        }
        #y() {
          return this.#a(this.#e, ":");
        }
        #b() {
          return this.#a(this.#e, "/");
        }
        #h() {
          if (this.#a(this.#e, "?"))
            return true;
          if (this.#n[this.#e].value !== "?")
            return false;
          let t8 = this.#m(this.#e - 1);
          return t8.type !== "NAME" && t8.type !== "REGEX" && t8.type !== "CLOSE" && t8.type !== "ASTERISK";
        }
        #l() {
          return this.#a(this.#e, "#");
        }
        #O() {
          return this.#n[this.#e].type == "OPEN";
        }
        #T() {
          return this.#n[this.#e].type == "CLOSE";
        }
        #A() {
          return this.#a(this.#e, "[");
        }
        #w() {
          return this.#a(this.#e, "]");
        }
        #o() {
          let t8 = this.#n[this.#e], r9 = this.#m(this.#u).index;
          return this.#i.substring(r9, t8.index);
        }
        #C() {
          let t8 = {};
          Object.assign(t8, b6), t8.encodePart = A5;
          let r9 = q4(this.#o(), void 0, t8);
          this.#g = N5(r9);
        }
      };
      var G4 = ["protocol", "username", "password", "hostname", "port", "pathname", "search", "hash"];
      var E5 = "*";
      function xe2(e9, t8) {
        if (typeof e9 != "string")
          throw new TypeError("parameter 1 is not of type 'string'.");
        let r9 = new URL(e9, t8);
        return { protocol: r9.protocol.substring(0, r9.protocol.length - 1), username: r9.username, password: r9.password, hostname: r9.hostname, port: r9.port, pathname: r9.pathname, search: r9.search !== "" ? r9.search.substring(1, r9.search.length) : void 0, hash: r9.hash !== "" ? r9.hash.substring(1, r9.hash.length) : void 0 };
      }
      function P5(e9, t8) {
        return t8 ? C5(e9) : e9;
      }
      function w5(e9, t8, r9) {
        let n8;
        if (typeof t8.baseURL == "string")
          try {
            n8 = new URL(t8.baseURL), e9.protocol = P5(n8.protocol.substring(0, n8.protocol.length - 1), r9), e9.username = P5(n8.username, r9), e9.password = P5(n8.password, r9), e9.hostname = P5(n8.hostname, r9), e9.port = P5(n8.port, r9), e9.pathname = P5(n8.pathname, r9), e9.search = P5(n8.search.substring(1, n8.search.length), r9), e9.hash = P5(n8.hash.substring(1, n8.hash.length), r9);
          } catch {
            throw new TypeError(`invalid baseURL '${t8.baseURL}'.`);
          }
        if (typeof t8.protocol == "string" && (e9.protocol = he3(t8.protocol, r9)), typeof t8.username == "string" && (e9.username = oe3(t8.username, r9)), typeof t8.password == "string" && (e9.password = ae3(t8.password, r9)), typeof t8.hostname == "string" && (e9.hostname = ie2(t8.hostname, r9)), typeof t8.port == "string" && (e9.port = le3(t8.port, e9.protocol, r9)), typeof t8.pathname == "string") {
          if (e9.pathname = t8.pathname, n8 && !ee3(e9.pathname, r9)) {
            let a8 = n8.pathname.lastIndexOf("/");
            a8 >= 0 && (e9.pathname = P5(n8.pathname.substring(0, a8 + 1), r9) + e9.pathname);
          }
          e9.pathname = ce3(e9.pathname, e9.protocol, r9);
        }
        return typeof t8.search == "string" && (e9.search = se3(t8.search, r9)), typeof t8.hash == "string" && (e9.hash = ne3(t8.hash, r9)), e9;
      }
      function C5(e9) {
        return e9.replace(/([+*?:{}()\\])/g, "\\$1");
      }
      function Le2(e9) {
        return e9.replace(/([.+*?^${}()[\]|/\\])/g, "\\$1");
      }
      function Ie2(e9, t8) {
        t8.delimiter ??= "/#?", t8.prefixes ??= "./", t8.sensitive ??= false, t8.strict ??= false, t8.end ??= true, t8.start ??= true, t8.endsWith = "";
        let r9 = ".*", n8 = `[^${Le2(t8.delimiter)}]+?`, a8 = /[$_\u200C\u200D\p{ID_Continue}]/u, c7 = "";
        for (let l7 = 0; l7 < e9.length; ++l7) {
          let s7 = e9[l7];
          if (s7.type === 3) {
            if (s7.modifier === 3) {
              c7 += C5(s7.value);
              continue;
            }
            c7 += `{${C5(s7.value)}}${y6(s7.modifier)}`;
            continue;
          }
          let i7 = s7.hasCustomName(), o8 = !!s7.suffix.length || !!s7.prefix.length && (s7.prefix.length !== 1 || !t8.prefixes.includes(s7.prefix)), h8 = l7 > 0 ? e9[l7 - 1] : null, p8 = l7 < e9.length - 1 ? e9[l7 + 1] : null;
          if (!o8 && i7 && s7.type === 1 && s7.modifier === 3 && p8 && !p8.prefix.length && !p8.suffix.length)
            if (p8.type === 3) {
              let O5 = p8.value.length > 0 ? p8.value[0] : "";
              o8 = a8.test(O5);
            } else
              o8 = !p8.hasCustomName();
          if (!o8 && !s7.prefix.length && h8 && h8.type === 3) {
            let O5 = h8.value[h8.value.length - 1];
            o8 = t8.prefixes.includes(O5);
          }
          o8 && (c7 += "{"), c7 += C5(s7.prefix), i7 && (c7 += `:${s7.name}`), s7.type === 2 ? c7 += `(${s7.value})` : s7.type === 1 ? i7 || (c7 += `(${n8})`) : s7.type === 0 && (!i7 && (!h8 || h8.type === 3 || h8.modifier !== 3 || o8 || s7.prefix !== "") ? c7 += "*" : c7 += `(${r9})`), s7.type === 1 && i7 && s7.suffix.length && a8.test(s7.suffix[0]) && (c7 += "\\"), c7 += C5(s7.suffix), o8 && (c7 += "}"), s7.modifier !== 3 && (c7 += y6(s7.modifier));
        }
        return c7;
      }
      var Y5 = class {
        #i;
        #n = {};
        #t = {};
        #e = {};
        #s = {};
        constructor(t8 = {}, r9, n8) {
          try {
            let a8;
            if (typeof r9 == "string" ? a8 = r9 : n8 = r9, typeof t8 == "string") {
              let i7 = new U5(t8);
              if (i7.parse(), t8 = i7.result, a8 === void 0 && typeof t8.protocol != "string")
                throw new TypeError("A base URL must be provided for a relative constructor string.");
              t8.baseURL = a8;
            } else {
              if (!t8 || typeof t8 != "object")
                throw new TypeError("parameter 1 is not of type 'string' and cannot convert to dictionary.");
              if (a8)
                throw new TypeError("parameter 1 is not of type 'string'.");
            }
            typeof n8 > "u" && (n8 = { ignoreCase: false });
            let c7 = { ignoreCase: n8.ignoreCase === true }, l7 = { pathname: E5, protocol: E5, username: E5, password: E5, hostname: E5, port: E5, search: E5, hash: E5 };
            this.#i = w5(l7, t8, true), z5(this.#i.protocol) === this.#i.port && (this.#i.port = "");
            let s7;
            for (s7 of G4) {
              if (!(s7 in this.#i))
                continue;
              let i7 = {}, o8 = this.#i[s7];
              switch (this.#t[s7] = [], s7) {
                case "protocol":
                  Object.assign(i7, b6), i7.encodePart = A5;
                  break;
                case "username":
                  Object.assign(i7, b6), i7.encodePart = fe3;
                  break;
                case "password":
                  Object.assign(i7, b6), i7.encodePart = ue3;
                  break;
                case "hostname":
                  Object.assign(i7, J4), _5(o8) ? i7.encodePart = K4 : i7.encodePart = j5;
                  break;
                case "port":
                  Object.assign(i7, b6), i7.encodePart = V4;
                  break;
                case "pathname":
                  N5(this.#n.protocol) ? (Object.assign(i7, Q4, c7), i7.encodePart = pe3) : (Object.assign(i7, b6, c7), i7.encodePart = de3);
                  break;
                case "search":
                  Object.assign(i7, b6, c7), i7.encodePart = ge3;
                  break;
                case "hash":
                  Object.assign(i7, b6, c7), i7.encodePart = me3;
                  break;
              }
              try {
                this.#s[s7] = F5(o8, i7), this.#n[s7] = W4(this.#s[s7], this.#t[s7], i7), this.#e[s7] = Ie2(this.#s[s7], i7);
              } catch {
                throw new TypeError(`invalid ${s7} pattern '${this.#i[s7]}'.`);
              }
            }
          } catch (a8) {
            throw new TypeError(`Failed to construct 'URLPattern': ${a8.message}`);
          }
        }
        test(t8 = {}, r9) {
          let n8 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
          if (typeof t8 != "string" && r9)
            throw new TypeError("parameter 1 is not of type 'string'.");
          if (typeof t8 > "u")
            return false;
          try {
            typeof t8 == "object" ? n8 = w5(n8, t8, false) : n8 = w5(n8, xe2(t8, r9), false);
          } catch {
            return false;
          }
          let a8;
          for (a8 of G4)
            if (!this.#n[a8].exec(n8[a8]))
              return false;
          return true;
        }
        exec(t8 = {}, r9) {
          let n8 = { pathname: "", protocol: "", username: "", password: "", hostname: "", port: "", search: "", hash: "" };
          if (typeof t8 != "string" && r9)
            throw new TypeError("parameter 1 is not of type 'string'.");
          if (typeof t8 > "u")
            return;
          try {
            typeof t8 == "object" ? n8 = w5(n8, t8, false) : n8 = w5(n8, xe2(t8, r9), false);
          } catch {
            return null;
          }
          let a8 = {};
          r9 ? a8.inputs = [t8, r9] : a8.inputs = [t8];
          let c7;
          for (c7 of G4) {
            let l7 = this.#n[c7].exec(n8[c7]);
            if (!l7)
              return null;
            let s7 = {};
            for (let [i7, o8] of this.#t[c7].entries())
              if (typeof o8 == "string" || typeof o8 == "number") {
                let h8 = l7[i7 + 1];
                s7[o8] = h8;
              }
            a8[c7] = { input: n8[c7] ?? "", groups: s7 };
          }
          return a8;
        }
        static compareComponent(t8, r9, n8) {
          let a8 = (i7, o8) => {
            for (let h8 of ["type", "modifier", "prefix", "value", "suffix"]) {
              if (i7[h8] < o8[h8])
                return -1;
              if (i7[h8] === o8[h8])
                continue;
              return 1;
            }
            return 0;
          }, c7 = new k5(3, "", "", "", "", 3), l7 = new k5(0, "", "", "", "", 3), s7 = (i7, o8) => {
            let h8 = 0;
            for (; h8 < Math.min(i7.length, o8.length); ++h8) {
              let p8 = a8(i7[h8], o8[h8]);
              if (p8)
                return p8;
            }
            return i7.length === o8.length ? 0 : a8(i7[h8] ?? c7, o8[h8] ?? c7);
          };
          return !r9.#e[t8] && !n8.#e[t8] ? 0 : r9.#e[t8] && !n8.#e[t8] ? s7(r9.#s[t8], [l7]) : !r9.#e[t8] && n8.#e[t8] ? s7([l7], n8.#s[t8]) : s7(r9.#s[t8], n8.#s[t8]);
        }
        get protocol() {
          return this.#e.protocol;
        }
        get username() {
          return this.#e.username;
        }
        get password() {
          return this.#e.password;
        }
        get hostname() {
          return this.#e.hostname;
        }
        get port() {
          return this.#e.port;
        }
        get pathname() {
          return this.#e.pathname;
        }
        get search() {
          return this.#e.search;
        }
        get hash() {
          return this.#e.hash;
        }
      };
    }
  });

  // node_modules/urlpattern-polyfill/index.cjs
  var require_urlpattern_polyfill = __commonJS({
    "node_modules/urlpattern-polyfill/index.cjs"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var { URLPattern } = require_urlpattern();
      module.exports = { URLPattern };
      if (!globalThis.URLPattern) {
        globalThis.URLPattern = URLPattern;
      }
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js
  var require_UrlPattern = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/UrlPattern.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.URLPattern = void 0;
      var urlpattern_polyfill_1 = require_urlpattern_polyfill();
      Object.defineProperty(exports8, "URLPattern", { enumerable: true, get: function() {
        return urlpattern_polyfill_1.URLPattern;
      } });
      if ("URLPattern" in globalThis) {
        urlpattern_polyfill_1.URLPattern = globalThis.URLPattern;
      }
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkStorage.js
  var require_NetworkStorage = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkStorage.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.NetworkStorage = void 0;
      var protocol_js_1 = require_protocol();
      var UrlPattern_js_1 = require_UrlPattern();
      var uuid_js_1 = require_uuid();
      var NetworkStorage = class _NetworkStorage {
        /**
         * A map from network request ID to Network Request objects.
         * Needed as long as information about requests comes from different events.
         */
        #requestMap = /* @__PURE__ */ new Map();
        /** A map from intercept ID to track active network intercepts. */
        #interceptMap = /* @__PURE__ */ new Map();
        /** A map from network request ID to track actively blocked requests. */
        #blockedRequestMap = /* @__PURE__ */ new Map();
        disposeRequestMap() {
          for (const request of this.#requestMap.values()) {
            request.dispose();
          }
          this.#requestMap.clear();
        }
        /**
         * Adds the given entry to the intercept map.
         * URL patterns are assumed to be parsed.
         *
         * @return The intercept ID.
         */
        addIntercept(value) {
          for (const [interceptId2, { urlPatterns, phases }] of this.#interceptMap.entries()) {
            if (JSON.stringify(value.urlPatterns) === JSON.stringify(urlPatterns) && JSON.stringify(value.phases) === JSON.stringify(phases)) {
              return interceptId2;
            }
          }
          const interceptId = (0, uuid_js_1.uuidv4)();
          this.#interceptMap.set(interceptId, value);
          return interceptId;
        }
        /**
         * Removes the given intercept from the intercept map.
         * Throws NoSuchInterceptException if the intercept does not exist.
         */
        removeIntercept(intercept) {
          if (!this.#interceptMap.has(intercept)) {
            throw new protocol_js_1.NoSuchInterceptException(`Intercept '${intercept}' does not exist.`);
          }
          this.#interceptMap.delete(intercept);
        }
        /** Returns true if there's at least one added intercept. */
        hasIntercepts() {
          return this.#interceptMap.size > 0;
        }
        /** Gets parameters for CDP 'Fetch.enable' command from the intercept map. */
        getFetchEnableParams() {
          const patterns = [];
          for (const value of this.#interceptMap.values()) {
            for (const phase of value.phases) {
              const requestStage = _NetworkStorage.requestStageFromPhase(phase);
              if (value.urlPatterns.length === 0) {
                patterns.push({
                  urlPattern: "*",
                  requestStage
                });
                continue;
              }
              for (const urlPatternSpec of value.urlPatterns) {
                const urlPattern = _NetworkStorage.cdpFromSpecUrlPattern(urlPatternSpec);
                patterns.push({
                  urlPattern,
                  requestStage
                });
              }
            }
          }
          return {
            patterns,
            // If there's at least one intercept that requires auth, enable the
            // 'Fetch.authRequired' event.
            handleAuthRequests: [...this.#interceptMap.values()].some((param) => {
              return param.phases.includes(
                "authRequired"
                /* Network.InterceptPhase.AuthRequired */
              );
            })
          };
        }
        getRequest(id) {
          return this.#requestMap.get(id);
        }
        addRequest(request) {
          this.#requestMap.set(request.requestId, request);
        }
        deleteRequest(id) {
          const request = this.#requestMap.get(id);
          if (request) {
            request.dispose();
            this.#requestMap.delete(id);
          }
        }
        /** Returns true if there's at least one network request. */
        hasNetworkRequests() {
          return this.#requestMap.size > 0;
        }
        /** Returns true if there's at least one blocked network request. */
        hasBlockedRequests() {
          return this.#blockedRequestMap.size > 0;
        }
        /** Converts a URL pattern from the spec to a CDP URL pattern. */
        static cdpFromSpecUrlPattern(urlPattern) {
          switch (urlPattern.type) {
            case "string":
              return urlPattern.pattern;
            case "pattern":
              return _NetworkStorage.buildUrlPatternString(urlPattern);
          }
        }
        static buildUrlPatternString({ protocol, hostname, port, pathname, search }) {
          if (!protocol && !hostname && !port && !pathname && !search) {
            return "*";
          }
          let url = "";
          if (protocol) {
            url += `${protocol}`;
            if (!protocol.endsWith(":")) {
              url += ":";
            }
            if (_NetworkStorage.isSpecialScheme(protocol)) {
              url += "//";
            }
          }
          if (hostname) {
            url += hostname;
          }
          if (port) {
            url += `:${port}`;
          }
          if (pathname) {
            if (!pathname.startsWith("/")) {
              url += "/";
            }
            url += pathname;
          }
          if (search) {
            if (!search.startsWith("?")) {
              url += "?";
            }
            url += `${search}`;
          }
          return url;
        }
        /**
         * Maps spec Network.InterceptPhase to CDP Fetch.RequestStage.
         * AuthRequired has no CDP equivalent..
         */
        static requestStageFromPhase(phase) {
          switch (phase) {
            case "beforeRequestSent":
              return "Request";
            case "responseStarted":
            case "authRequired":
              return "Response";
          }
        }
        /**
         * Returns true if the given protocol is special.
         * Special protocols are those that have a default port.
         *
         * Example inputs: 'http', 'http:'
         *
         * @see https://url.spec.whatwg.org/#special-scheme
         */
        static isSpecialScheme(protocol) {
          return ["ftp", "file", "http", "https", "ws", "wss"].includes(protocol.replace(/:$/, ""));
        }
        addBlockedRequest(requestId, value) {
          this.#blockedRequestMap.set(requestId, value);
        }
        removeBlockedRequest(requestId) {
          this.#blockedRequestMap.delete(requestId);
        }
        /**
         * Returns the blocked request associated with the given network ID, if any.
         */
        getBlockedRequest(networkId) {
          return this.#blockedRequestMap.get(networkId);
        }
        /** #@see https://w3c.github.io/webdriver-bidi/#get-the-network-intercepts */
        getNetworkIntercepts(requestId, phase) {
          const request = this.#requestMap.get(requestId);
          if (!request) {
            return [];
          }
          const interceptIds = [];
          for (const [interceptId, { phases, urlPatterns }] of this.#interceptMap.entries()) {
            if (phase && phases.includes(phase)) {
              if (urlPatterns.length === 0) {
                interceptIds.push(interceptId);
              } else if (urlPatterns.some((urlPattern) => _NetworkStorage.matchUrlPattern(urlPattern, request.url))) {
                interceptIds.push(interceptId);
              }
            }
          }
          return interceptIds;
        }
        /** Matches the given URLPattern against the given URL. */
        static matchUrlPattern(urlPattern, url) {
          switch (urlPattern.type) {
            case "string":
              return urlPattern.pattern === url;
            case "pattern": {
              return new UrlPattern_js_1.URLPattern({
                protocol: urlPattern.protocol,
                hostname: urlPattern.hostname,
                port: urlPattern.port,
                pathname: urlPattern.pathname,
                search: urlPattern.search
              }).exec(url) !== null;
            }
          }
        }
      };
      exports8.NetworkStorage = NetworkStorage;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkProcessor.js
  var require_NetworkProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/network/NetworkProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.NetworkProcessor = void 0;
      var protocol_js_1 = require_protocol();
      var assert_js_1 = require_assert();
      var NetworkStorage_js_1 = require_NetworkStorage();
      var NetworkUtils_js_1 = require_NetworkUtils();
      var NetworkProcessor = class _NetworkProcessor {
        #browsingContextStorage;
        #networkStorage;
        constructor(browsingContextStorage, networkStorage) {
          this.#browsingContextStorage = browsingContextStorage;
          this.#networkStorage = networkStorage;
        }
        async addIntercept(params) {
          if (params.phases.length === 0) {
            throw new protocol_js_1.InvalidArgumentException("At least one phase must be specified.");
          }
          if (params.phases.includes(
            "authRequired"
            /* Network.InterceptPhase.AuthRequired */
          ) && !params.phases.includes(
            "beforeRequestSent"
            /* Network.InterceptPhase.BeforeRequestSent */
          )) {
            params.phases.unshift(
              "beforeRequestSent"
              /* Network.InterceptPhase.BeforeRequestSent */
            );
          }
          const urlPatterns = params.urlPatterns ?? [];
          const parsedUrlPatterns = _NetworkProcessor.parseUrlPatterns(urlPatterns);
          const intercept = this.#networkStorage.addIntercept({
            urlPatterns: parsedUrlPatterns,
            phases: params.phases
          });
          await this.#fetchApply();
          return {
            intercept
          };
        }
        async continueRequest(params) {
          const networkId = params.request;
          const { request: fetchId, phase } = this.#getBlockedRequest(networkId);
          if (phase !== "beforeRequestSent") {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is not in 'BeforeRequestSent' phase`);
          }
          if (params.url !== void 0) {
            _NetworkProcessor.parseUrlString(params.url);
          }
          const { url, method, headers } = params;
          const requestHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(headers);
          const request = this.#networkStorage.getRequest(networkId);
          (0, assert_js_1.assert)(request, `Network request with ID ${networkId} doesn't exist`);
          await request.continueRequest(fetchId, url, method, requestHeaders);
          this.#networkStorage.removeBlockedRequest(networkId);
          return {};
        }
        async continueResponse(params) {
          const networkId = params.request;
          const { request: fetchId, phase } = this.#getBlockedRequest(networkId);
          if (phase === "beforeRequestSent") {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is in 'BeforeRequestSent' phase`);
          }
          const { statusCode, reasonPhrase, headers } = params;
          const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(headers);
          const request = this.#networkStorage.getRequest(networkId);
          (0, assert_js_1.assert)(request, `Network request with ID ${networkId} doesn't exist`);
          await request.continueResponse(fetchId, statusCode, reasonPhrase, responseHeaders);
          this.#networkStorage.removeBlockedRequest(networkId);
          return {};
        }
        async continueWithAuth(params) {
          const networkId = params.request;
          const { request: fetchId, phase } = this.#getBlockedRequest(networkId);
          if (phase !== "authRequired") {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is not in 'AuthRequired' phase`);
          }
          const request = this.#networkStorage.getRequest(networkId);
          (0, assert_js_1.assert)(request, `Network request with ID ${networkId} doesn't exist`);
          let username;
          let password;
          if (params.action === "provideCredentials") {
            const { credentials } = params;
            username = params.credentials.username;
            password = params.credentials.password;
            (0, assert_js_1.assert)(credentials.type === "password", `Credentials type ${credentials.type} must be 'password'`);
          }
          const response = (0, NetworkUtils_js_1.cdpAuthChallengeResponseFromBidiAuthContinueWithAuthAction)(params.action);
          await request.continueWithAuth(fetchId, response, username, password);
          return {};
        }
        async failRequest(params) {
          const networkId = params.request;
          const blockedRequest = this.#getBlockedRequest(networkId);
          const { request: fetchId, phase } = blockedRequest;
          if (phase === "authRequired") {
            throw new protocol_js_1.InvalidArgumentException(`Blocked request for network id '${networkId}' is in 'AuthRequired' phase`);
          }
          const request = this.#networkStorage.getRequest(networkId);
          (0, assert_js_1.assert)(request, `Network request with ID ${networkId} doesn't exist`);
          await request.failRequest(fetchId, "Failed");
          this.#networkStorage.removeBlockedRequest(networkId);
          return {};
        }
        async provideResponse(params) {
          const networkId = params.request;
          const { request: fetchId } = this.#getBlockedRequest(networkId);
          const { statusCode, reasonPhrase, headers, body } = params;
          const responseHeaders = (0, NetworkUtils_js_1.cdpFetchHeadersFromBidiNetworkHeaders)(headers);
          const request = this.#networkStorage.getRequest(networkId);
          (0, assert_js_1.assert)(request, `Network request with ID ${networkId} doesn't exist`);
          await request.provideResponse(
            fetchId,
            statusCode ?? request.statusCode,
            reasonPhrase,
            responseHeaders,
            body?.value
            // TODO: Differ base64 / string
          );
          this.#networkStorage.removeBlockedRequest(networkId);
          return {};
        }
        async removeIntercept(params) {
          this.#networkStorage.removeIntercept(params.intercept);
          await this.#fetchApply();
          return {};
        }
        /** Applies all existing network intercepts to all CDP targets concurrently. */
        async #fetchEnable() {
          await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchEnable();
          }));
        }
        /** Removes all existing network intercepts from all CDP targets concurrently. */
        async #fetchDisable() {
          await Promise.all(this.#browsingContextStorage.getAllContexts().map(async (context) => {
            await context.cdpTarget.fetchDisable();
          }));
        }
        /**
         * Either enables or disables the Fetch domain.
         *
         * If enabling, applies all existing network intercepts to all CDP targets.
         * If disabling, removes all existing network intercepts from all CDP targets.
         *
         * Disabling is only performed when there are no remaining intercepts or
         * // blocked requests.
         */
        async #fetchApply() {
          if (this.#networkStorage.hasIntercepts() || this.#networkStorage.hasBlockedRequests() || this.#networkStorage.hasNetworkRequests()) {
            await this.#fetchEnable();
          } else {
            await this.#fetchDisable();
          }
        }
        /**
         * Returns the blocked request associated with the given network ID.
         * If none, throws a NoSuchRequestException.
         */
        #getBlockedRequest(networkId) {
          const blockedRequest = this.#networkStorage.getBlockedRequest(networkId);
          if (!blockedRequest) {
            throw new protocol_js_1.NoSuchRequestException(`No blocked request found for network id '${networkId}'`);
          }
          return blockedRequest;
        }
        /**
         * Attempts to parse the given url.
         * Throws an InvalidArgumentException if the url is invalid.
         */
        static parseUrlString(url) {
          try {
            return new URL(url);
          } catch (error) {
            throw new protocol_js_1.InvalidArgumentException(`Invalid URL '${url}': ${error}`);
          }
        }
        static parseUrlPatterns(urlPatterns) {
          return urlPatterns.map((urlPattern) => {
            switch (urlPattern.type) {
              case "string": {
                _NetworkProcessor.parseUrlString(urlPattern.pattern);
                return urlPattern;
              }
              case "pattern":
                if (urlPattern.protocol === void 0 && urlPattern.hostname === void 0 && urlPattern.port === void 0 && urlPattern.pathname === void 0 && urlPattern.search === void 0) {
                  return urlPattern;
                }
                if (urlPattern.protocol === "") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a protocol`);
                }
                if (urlPattern.hostname === "") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a hostname`);
                }
                if ((urlPattern.hostname?.length ?? 0) > 0) {
                  if (urlPattern.protocol?.match(/^file/i)) {
                    throw new protocol_js_1.InvalidArgumentException(`URL pattern protocol cannot be 'file'`);
                  }
                  if (urlPattern.hostname?.includes(":")) {
                    throw new protocol_js_1.InvalidArgumentException(`URL pattern hostname must not contain a colon`);
                  }
                }
                if (urlPattern.port === "") {
                  throw new protocol_js_1.InvalidArgumentException(`URL pattern must specify a port`);
                }
                try {
                  new URL(NetworkStorage_js_1.NetworkStorage.buildUrlPatternString(urlPattern));
                } catch (error) {
                  throw new protocol_js_1.InvalidArgumentException(`${error}`);
                }
                return urlPattern;
            }
          });
        }
      };
      exports8.NetworkProcessor = NetworkProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/PreloadScriptStorage.js
  var require_PreloadScriptStorage = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/PreloadScriptStorage.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.PreloadScriptStorage = void 0;
      var PreloadScriptStorage = class {
        /** Tracks all BiDi preload scripts.  */
        #scripts = /* @__PURE__ */ new Set();
        /** Finds all entries that match the given filter. */
        find(filter) {
          if (!filter) {
            return [...this.#scripts];
          }
          return [...this.#scripts].filter((script) => {
            if (filter.id !== void 0 && filter.id !== script.id) {
              return false;
            }
            if (filter.targetId !== void 0 && !script.targetIds.has(filter.targetId)) {
              return false;
            }
            if (filter.global !== void 0 && // Global scripts have no contexts
            (filter.global && script.contexts !== void 0 || // Non global scripts always have contexts
            !filter.global && script.contexts === void 0)) {
              return false;
            }
            return true;
          });
        }
        add(preloadScript) {
          this.#scripts.add(preloadScript);
        }
        /** Deletes all BiDi preload script entries that match the given filter. */
        remove(filter) {
          for (const preloadScript of this.find(filter)) {
            this.#scripts.delete(preloadScript);
          }
        }
      };
      exports8.PreloadScriptStorage = PreloadScriptStorage;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/PreloadScript.js
  var require_PreloadScript = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/PreloadScript.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.PreloadScript = void 0;
      var uuid_js_1 = require_uuid();
      var ChannelProxy_js_1 = require_ChannelProxy();
      var PreloadScript = class {
        /** BiDi ID, an automatically generated UUID. */
        #id = (0, uuid_js_1.uuidv4)();
        /** CDP preload scripts. */
        #cdpPreloadScripts = [];
        /** The script itself, in a format expected by the spec i.e. a function. */
        #functionDeclaration;
        /** Targets, in which the preload script is initialized. */
        #targetIds = /* @__PURE__ */ new Set();
        /** Channels to be added as arguments to functionDeclaration. */
        #channels;
        /** The script sandbox / world name. */
        #sandbox;
        /** The browsing contexts to execute the preload scripts in, if any. */
        #contexts;
        get id() {
          return this.#id;
        }
        get targetIds() {
          return this.#targetIds;
        }
        constructor(params, logger) {
          this.#channels = params.arguments?.map((a8) => new ChannelProxy_js_1.ChannelProxy(a8.value, logger)) ?? [];
          this.#functionDeclaration = params.functionDeclaration;
          this.#sandbox = params.sandbox;
          this.#contexts = params.contexts;
        }
        /** Channels of the preload script. */
        get channels() {
          return this.#channels;
        }
        /** Contexts of the preload script, if any */
        get contexts() {
          return this.#contexts;
        }
        /**
         * String to be evaluated. Wraps user-provided function so that the following
         * steps are run:
         * 1. Create channels.
         * 2. Store the created channels in window.
         * 3. Call the user-provided function with channels as arguments.
         */
        #getEvaluateString() {
          const channelsArgStr = `[${this.channels.map((c7) => c7.getEvalInWindowStr()).join(", ")}]`;
          return `(()=>{(${this.#functionDeclaration})(...${channelsArgStr})})()`;
        }
        /**
         * Adds the script to the given CDP targets by calling the
         * `Page.addScriptToEvaluateOnNewDocument` command.
         */
        async initInTargets(cdpTargets, runImmediately) {
          await Promise.all(Array.from(cdpTargets).map((cdpTarget) => this.initInTarget(cdpTarget, runImmediately)));
        }
        /**
         * Adds the script to the given CDP target by calling the
         * `Page.addScriptToEvaluateOnNewDocument` command.
         */
        async initInTarget(cdpTarget, runImmediately) {
          const addCdpPreloadScriptResult = await cdpTarget.cdpClient.sendCommand("Page.addScriptToEvaluateOnNewDocument", {
            source: this.#getEvaluateString(),
            worldName: this.#sandbox,
            runImmediately
          });
          this.#cdpPreloadScripts.push({
            target: cdpTarget,
            preloadScriptId: addCdpPreloadScriptResult.identifier
          });
          this.#targetIds.add(cdpTarget.targetId);
        }
        /**
         * Removes this script from all CDP targets.
         */
        async remove() {
          for (const cdpPreloadScript of this.#cdpPreloadScripts) {
            const cdpTarget = cdpPreloadScript.target;
            const cdpPreloadScriptId = cdpPreloadScript.preloadScriptId;
            await cdpTarget.cdpClient.sendCommand("Page.removeScriptToEvaluateOnNewDocument", {
              identifier: cdpPreloadScriptId
            });
          }
        }
        /** Removes the provided cdp target from the list of cdp preload scripts. */
        dispose(cdpTargetId) {
          this.#cdpPreloadScripts = this.#cdpPreloadScripts.filter((cdpPreloadScript) => cdpPreloadScript.target?.targetId !== cdpTargetId);
          this.#targetIds.delete(cdpTargetId);
        }
      };
      exports8.PreloadScript = PreloadScript;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/ScriptProcessor.js
  var require_ScriptProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/ScriptProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ScriptProcessor = void 0;
      var protocol_1 = require_protocol();
      var PreloadScript_1 = require_PreloadScript();
      var ScriptProcessor = class {
        #browsingContextStorage;
        #realmStorage;
        #preloadScriptStorage;
        #logger;
        constructor(browsingContextStorage, realmStorage, preloadScriptStorage, logger) {
          this.#browsingContextStorage = browsingContextStorage;
          this.#realmStorage = realmStorage;
          this.#preloadScriptStorage = preloadScriptStorage;
          this.#logger = logger;
        }
        async addPreloadScript(params) {
          const contexts = /* @__PURE__ */ new Set();
          if (params.contexts) {
            if (params.contexts.length === 0) {
              throw new protocol_1.InvalidArgumentException("Contexts list is empty.");
            }
            for (const contextId of params.contexts) {
              const context = this.#browsingContextStorage.getContext(contextId);
              if (context.isTopLevelContext()) {
                contexts.add(context);
              } else {
                throw new protocol_1.InvalidArgumentException(`Non top-level context '${contextId}' given.`);
              }
            }
          }
          const preloadScript = new PreloadScript_1.PreloadScript(params, this.#logger);
          this.#preloadScriptStorage.add(preloadScript);
          const cdpTargets = contexts.size === 0 ? new Set(this.#browsingContextStorage.getTopLevelContexts().map((context) => context.cdpTarget)) : new Set([...contexts.values()].map((context) => context.cdpTarget));
          await preloadScript.initInTargets(cdpTargets, false);
          return {
            script: preloadScript.id
          };
        }
        async removePreloadScript(params) {
          const bidiId = params.script;
          const scripts = this.#preloadScriptStorage.find({
            id: bidiId
          });
          if (scripts.length === 0) {
            throw new protocol_1.NoSuchScriptException(`No preload script with BiDi ID '${bidiId}'`);
          }
          await Promise.all(scripts.map((script) => script.remove()));
          this.#preloadScriptStorage.remove({
            id: bidiId
          });
          return {};
        }
        async callFunction(params) {
          const realm = await this.#getRealm(params.target);
          return await realm.callFunction(
            params.functionDeclaration,
            params.this ?? {
              type: "undefined"
            },
            // `this` is `undefined` by default.
            params.arguments ?? [],
            // `arguments` is `[]` by default.
            params.awaitPromise,
            params.resultOwnership ?? "none",
            params.serializationOptions ?? {},
            params.userActivation ?? false
          );
        }
        async evaluate(params) {
          const realm = await this.#getRealm(params.target);
          return await realm.evaluate(params.expression, params.awaitPromise, params.resultOwnership ?? "none", params.serializationOptions ?? {}, params.userActivation ?? false);
        }
        async disown(params) {
          const realm = await this.#getRealm(params.target);
          await Promise.all(params.handles.map(async (handle) => await realm.disown(handle)));
          return {};
        }
        getRealms(params) {
          if (params.context !== void 0) {
            this.#browsingContextStorage.getContext(params.context);
          }
          const realms = this.#realmStorage.findRealms({
            browsingContextId: params.context,
            type: params.type
          }).map((realm) => realm.realmInfo);
          return { realms };
        }
        async #getRealm(target) {
          if ("realm" in target) {
            return this.#realmStorage.getRealm({
              realmId: target.realm
            });
          }
          const context = this.#browsingContextStorage.getContext(target.context);
          return await context.getOrCreateSandbox(target.sandbox);
        }
      };
      exports8.ScriptProcessor = ScriptProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/session/SessionProcessor.js
  var require_SessionProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/session/SessionProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.SessionProcessor = void 0;
      var SessionProcessor = class {
        #eventManager;
        constructor(eventManager) {
          this.#eventManager = eventManager;
        }
        status() {
          return { ready: false, message: "already connected" };
        }
        subscribe(params, channel = null) {
          this.#eventManager.subscribe(params.events, params.contexts ?? [null], channel);
          return {};
        }
        unsubscribe(params, channel = null) {
          this.#eventManager.unsubscribe(params.events, params.contexts ?? [null], channel);
          return {};
        }
      };
      exports8.SessionProcessor = SessionProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js
  var require_OutgoingMessage = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/OutgoingMessage.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.OutgoingMessage = void 0;
      var OutgoingMessage = class _OutgoingMessage {
        #message;
        #channel;
        constructor(message, channel = null) {
          this.#message = message;
          this.#channel = channel;
        }
        static createFromPromise(messagePromise, channel) {
          return messagePromise.then((message) => {
            if (message.kind === "success") {
              return {
                kind: "success",
                value: new _OutgoingMessage(message.value, channel)
              };
            }
            return message;
          });
        }
        static createResolved(message, channel) {
          return Promise.resolve({
            kind: "success",
            value: new _OutgoingMessage(message, channel)
          });
        }
        get message() {
          return this.#message;
        }
        get channel() {
          return this.#channel;
        }
      };
      exports8.OutgoingMessage = OutgoingMessage;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js
  var require_CommandProcessor = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/CommandProcessor.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.CommandProcessor = void 0;
      var protocol_js_1 = require_protocol();
      var EventEmitter_js_1 = require_EventEmitter();
      var log_js_1 = require_log();
      var BidiNoOpParser_js_1 = require_BidiNoOpParser();
      var BrowserProcessor_js_1 = require_BrowserProcessor();
      var CdpProcessor_js_1 = require_CdpProcessor();
      var BrowsingContextProcessor_js_1 = require_BrowsingContextProcessor();
      var InputProcessor_js_1 = require_InputProcessor();
      var NetworkProcessor_js_1 = require_NetworkProcessor();
      var NetworkStorage_js_1 = require_NetworkStorage();
      var PreloadScriptStorage_js_1 = require_PreloadScriptStorage();
      var ScriptProcessor_js_1 = require_ScriptProcessor();
      var SessionProcessor_js_1 = require_SessionProcessor();
      var OutgoingMessage_js_1 = require_OutgoingMessage();
      var CommandProcessor = class extends EventEmitter_js_1.EventEmitter {
        // keep-sorted start
        #browserProcessor;
        #browsingContextProcessor;
        #cdpProcessor;
        #inputProcessor;
        #networkProcessor;
        #scriptProcessor;
        #sessionProcessor;
        // keep-sorted end
        #parser;
        #logger;
        constructor(cdpConnection, browserCdpClient, eventManager, selfTargetId, browsingContextStorage, realmStorage, acceptInsecureCerts, parser = new BidiNoOpParser_js_1.BidiNoOpParser(), logger) {
          super();
          this.#parser = parser;
          this.#logger = logger;
          const networkStorage = new NetworkStorage_js_1.NetworkStorage();
          const preloadScriptStorage = new PreloadScriptStorage_js_1.PreloadScriptStorage();
          this.#browserProcessor = new BrowserProcessor_js_1.BrowserProcessor(browserCdpClient);
          this.#browsingContextProcessor = new BrowsingContextProcessor_js_1.BrowsingContextProcessor(cdpConnection, browserCdpClient, selfTargetId, eventManager, browsingContextStorage, realmStorage, networkStorage, preloadScriptStorage, acceptInsecureCerts, logger);
          this.#cdpProcessor = new CdpProcessor_js_1.CdpProcessor(browsingContextStorage, cdpConnection, browserCdpClient);
          this.#inputProcessor = new InputProcessor_js_1.InputProcessor(browsingContextStorage);
          this.#networkProcessor = new NetworkProcessor_js_1.NetworkProcessor(browsingContextStorage, networkStorage);
          this.#scriptProcessor = new ScriptProcessor_js_1.ScriptProcessor(browsingContextStorage, realmStorage, preloadScriptStorage, logger);
          this.#sessionProcessor = new SessionProcessor_js_1.SessionProcessor(eventManager);
        }
        async #processCommand(command) {
          switch (command.method) {
            case "session.end":
            case "session.new":
              break;
            case "browser.close":
              return this.#browserProcessor.close();
            case "browsingContext.activate":
              return await this.#browsingContextProcessor.activate(this.#parser.parseActivateParams(command.params));
            case "browsingContext.captureScreenshot":
              return await this.#browsingContextProcessor.captureScreenshot(this.#parser.parseCaptureScreenshotParams(command.params));
            case "browsingContext.close":
              return await this.#browsingContextProcessor.close(this.#parser.parseCloseParams(command.params));
            case "browsingContext.create":
              return await this.#browsingContextProcessor.create(this.#parser.parseCreateParams(command.params));
            case "browsingContext.getTree":
              return this.#browsingContextProcessor.getTree(this.#parser.parseGetTreeParams(command.params));
            case "browsingContext.handleUserPrompt":
              return await this.#browsingContextProcessor.handleUserPrompt(this.#parser.parseHandleUserPromptParams(command.params));
            case "browsingContext.locateNodes":
              throw new protocol_js_1.UnsupportedOperationException(`Command '${command.method}' not yet implemented.`);
            case "browsingContext.navigate":
              return await this.#browsingContextProcessor.navigate(this.#parser.parseNavigateParams(command.params));
            case "browsingContext.print":
              return await this.#browsingContextProcessor.print(this.#parser.parsePrintParams(command.params));
            case "browsingContext.reload":
              return await this.#browsingContextProcessor.reload(this.#parser.parseReloadParams(command.params));
            case "browsingContext.setViewport":
              return await this.#browsingContextProcessor.setViewport(this.#parser.parseSetViewportParams(command.params));
            case "browsingContext.traverseHistory":
              return await this.#browsingContextProcessor.traverseHistory(this.#parser.parseTraverseHistoryParams(command.params));
            case "cdp.getSession":
              return this.#cdpProcessor.getSession(this.#parser.parseGetSessionParams(command.params));
            case "cdp.sendCommand":
              return await this.#cdpProcessor.sendCommand(this.#parser.parseSendCommandParams(command.params));
            case "input.performActions":
              return await this.#inputProcessor.performActions(this.#parser.parsePerformActionsParams(command.params));
            case "input.releaseActions":
              return await this.#inputProcessor.releaseActions(this.#parser.parseReleaseActionsParams(command.params));
            case "network.addIntercept":
              return await this.#networkProcessor.addIntercept(this.#parser.parseAddInterceptParams(command.params));
            case "network.continueRequest":
              return await this.#networkProcessor.continueRequest(this.#parser.parseContinueRequestParams(command.params));
            case "network.continueResponse":
              return await this.#networkProcessor.continueResponse(this.#parser.parseContinueResponseParams(command.params));
            case "network.continueWithAuth":
              return await this.#networkProcessor.continueWithAuth(this.#parser.parseContinueWithAuthParams(command.params));
            case "network.failRequest":
              return await this.#networkProcessor.failRequest(this.#parser.parseFailRequestParams(command.params));
            case "network.provideResponse":
              return await this.#networkProcessor.provideResponse(this.#parser.parseProvideResponseParams(command.params));
            case "network.removeIntercept":
              return await this.#networkProcessor.removeIntercept(this.#parser.parseRemoveInterceptParams(command.params));
            case "script.addPreloadScript":
              return await this.#scriptProcessor.addPreloadScript(this.#parser.parseAddPreloadScriptParams(command.params));
            case "script.callFunction":
              return await this.#scriptProcessor.callFunction(this.#parser.parseCallFunctionParams(command.params));
            case "script.disown":
              return await this.#scriptProcessor.disown(this.#parser.parseDisownParams(command.params));
            case "script.evaluate":
              return await this.#scriptProcessor.evaluate(this.#parser.parseEvaluateParams(command.params));
            case "script.getRealms":
              return this.#scriptProcessor.getRealms(this.#parser.parseGetRealmsParams(command.params));
            case "script.removePreloadScript":
              return await this.#scriptProcessor.removePreloadScript(this.#parser.parseRemovePreloadScriptParams(command.params));
            case "session.status":
              return this.#sessionProcessor.status();
            case "session.subscribe":
              return this.#sessionProcessor.subscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
            case "session.unsubscribe":
              return this.#sessionProcessor.unsubscribe(this.#parser.parseSubscribeParams(command.params), command.channel);
          }
          throw new protocol_js_1.UnknownCommandException(`Unknown command '${command.method}'.`);
        }
        async processCommand(command) {
          try {
            const result = await this.#processCommand(command);
            const response = {
              type: "success",
              id: command.id,
              result
            };
            this.emit("response", {
              message: OutgoingMessage_js_1.OutgoingMessage.createResolved(response, command.channel),
              event: command.method
            });
          } catch (e9) {
            if (e9 instanceof protocol_js_1.Exception) {
              this.emit("response", {
                message: OutgoingMessage_js_1.OutgoingMessage.createResolved(e9.toErrorResponse(command.id), command.channel),
                event: command.method
              });
            } else {
              const error = e9;
              this.#logger?.(log_js_1.LogType.bidi, error);
              this.emit("response", {
                message: OutgoingMessage_js_1.OutgoingMessage.createResolved(new protocol_js_1.UnknownErrorException(error.message, error.stack).toErrorResponse(command.id), command.channel),
                event: command.method
              });
            }
          }
        }
      };
      exports8.CommandProcessor = CommandProcessor;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextStorage.js
  var require_BrowsingContextStorage = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/context/BrowsingContextStorage.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.BrowsingContextStorage = void 0;
      var protocol_js_1 = require_protocol();
      var BrowsingContextStorage = class {
        /** Map from context ID to context implementation. */
        #contexts = /* @__PURE__ */ new Map();
        /** Gets all top-level contexts, i.e. those with no parent. */
        getTopLevelContexts() {
          return this.getAllContexts().filter((context) => context.isTopLevelContext());
        }
        /** Gets all contexts. */
        getAllContexts() {
          return Array.from(this.#contexts.values());
        }
        /** Deletes the context with the given ID. */
        deleteContextById(id) {
          this.#contexts.delete(id);
        }
        /** Deletes the given context. */
        deleteContext(context) {
          this.#contexts.delete(context.id);
        }
        /** Tracks the given context. */
        addContext(context) {
          this.#contexts.set(context.id, context);
        }
        /** Returns true whether there is an existing context with the given ID. */
        hasContext(id) {
          return this.#contexts.has(id);
        }
        /** Gets the context with the given ID, if any. */
        findContext(id) {
          return this.#contexts.get(id);
        }
        /** Returns the top-level context ID of the given context, if any. */
        findTopLevelContextId(id) {
          if (id === null) {
            return null;
          }
          const maybeContext = this.findContext(id);
          const parentId = maybeContext?.parentId ?? null;
          if (parentId === null) {
            return id;
          }
          return this.findTopLevelContextId(parentId);
        }
        findContextBySession(sessionId) {
          for (const context of this.#contexts.values()) {
            if (context.cdpTarget.cdpSessionId === sessionId) {
              return context;
            }
          }
          return;
        }
        /** Gets the context with the given ID, if any, otherwise throws. */
        getContext(id) {
          const result = this.findContext(id);
          if (result === void 0) {
            throw new protocol_js_1.NoSuchFrameException(`Context ${id} not found`);
          }
          return result;
        }
      };
      exports8.BrowsingContextStorage = BrowsingContextStorage;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/Buffer.js
  var require_Buffer = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/Buffer.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.Buffer = void 0;
      var Buffer3 = class {
        #capacity;
        #entries = [];
        #onItemRemoved;
        /**
         * @param capacity The buffer capacity.
         * @param onItemRemoved Delegate called for each removed element.
         */
        constructor(capacity, onItemRemoved) {
          this.#capacity = capacity;
          this.#onItemRemoved = onItemRemoved;
        }
        get() {
          return this.#entries;
        }
        add(value) {
          this.#entries.push(value);
          while (this.#entries.length > this.#capacity) {
            const item = this.#entries.shift();
            if (item !== void 0) {
              this.#onItemRemoved?.(item);
            }
          }
        }
      };
      exports8.Buffer = Buffer3;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js
  var require_DefaultMap = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/DefaultMap.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.DefaultMap = void 0;
      var DefaultMap = class extends Map {
        /** The default value to return whenever a key is not present in the map. */
        #getDefaultValue;
        constructor(getDefaultValue, entries) {
          super(entries);
          this.#getDefaultValue = getDefaultValue;
        }
        get(key) {
          if (!this.has(key)) {
            this.set(key, this.#getDefaultValue(key));
          }
          return super.get(key);
        }
      };
      exports8.DefaultMap = DefaultMap;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js
  var require_IdWrapper = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/utils/IdWrapper.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.IdWrapper = void 0;
      var IdWrapper = class _IdWrapper {
        static #counter = 0;
        #id;
        constructor() {
          this.#id = ++_IdWrapper.#counter;
        }
        get id() {
          return this.#id;
        }
      };
      exports8.IdWrapper = IdWrapper;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/events.js
  var require_events = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/events.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.assertSupportedEvent = exports8.isCdpEvent = void 0;
      var protocol_js_1 = require_protocol();
      function isCdpEvent2(name2) {
        return name2.split(".").at(0)?.startsWith(protocol_js_1.ChromiumBidi.BiDiModule.Cdp) ?? false;
      }
      exports8.isCdpEvent = isCdpEvent2;
      function assertSupportedEvent(name2) {
        if (!protocol_js_1.ChromiumBidi.EVENT_NAMES.has(name2) && !isCdpEvent2(name2)) {
          throw new protocol_js_1.InvalidArgumentException(`Unknown event: ${name2}`);
        }
      }
      exports8.assertSupportedEvent = assertSupportedEvent;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/SubscriptionManager.js
  var require_SubscriptionManager = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/SubscriptionManager.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.SubscriptionManager = exports8.unrollEvents = exports8.cartesianProduct = void 0;
      var protocol_js_1 = require_protocol();
      var events_js_1 = require_events();
      function cartesianProduct(...a8) {
        return a8.reduce((a9, b6) => a9.flatMap((d7) => b6.map((e9) => [d7, e9].flat())));
      }
      exports8.cartesianProduct = cartesianProduct;
      function unrollEvents(events) {
        const allEvents = /* @__PURE__ */ new Set();
        function addEvents(events2) {
          for (const event of events2) {
            allEvents.add(event);
          }
        }
        for (const event of events) {
          switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
              addEvents(Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames));
              break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
              addEvents(Object.values(protocol_js_1.ChromiumBidi.Log.EventNames));
              break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
              addEvents(Object.values(protocol_js_1.ChromiumBidi.Network.EventNames));
              break;
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
              addEvents(Object.values(protocol_js_1.ChromiumBidi.Script.EventNames));
              break;
            default:
              allEvents.add(event);
          }
        }
        return [...allEvents.values()];
      }
      exports8.unrollEvents = unrollEvents;
      var SubscriptionManager = class {
        #subscriptionPriority = 0;
        // BrowsingContext `null` means the event has subscription across all the
        // browsing contexts.
        // Channel `null` means no `channel` should be added.
        #channelToContextToEventMap = /* @__PURE__ */ new Map();
        #browsingContextStorage;
        constructor(browsingContextStorage) {
          this.#browsingContextStorage = browsingContextStorage;
        }
        getChannelsSubscribedToEvent(eventMethod, contextId) {
          const prioritiesAndChannels = Array.from(this.#channelToContextToEventMap.keys()).map((channel) => ({
            priority: this.#getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel),
            channel
          })).filter(({ priority }) => priority !== null);
          return prioritiesAndChannels.sort((a8, b6) => a8.priority - b6.priority).map(({ channel }) => channel);
        }
        #getEventSubscriptionPriorityForChannel(eventMethod, contextId, channel) {
          const contextToEventMap = this.#channelToContextToEventMap.get(channel);
          if (contextToEventMap === void 0) {
            return null;
          }
          const maybeTopLevelContextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
          const relevantContexts = [.../* @__PURE__ */ new Set([null, maybeTopLevelContextId])];
          const priorities = relevantContexts.map((context) => {
            const priority = contextToEventMap.get(context)?.get(eventMethod);
            if ((0, events_js_1.isCdpEvent)(eventMethod)) {
              const cdpPriority = contextToEventMap.get(context)?.get(protocol_js_1.ChromiumBidi.BiDiModule.Cdp);
              return priority && cdpPriority ? Math.min(priority, cdpPriority) : (
                // At this point we know that we have subscribed
                // to only one of the two
                priority ?? cdpPriority
              );
            }
            return priority;
          }).filter((p8) => p8 !== void 0);
          if (priorities.length === 0) {
            return null;
          }
          return Math.min(...priorities);
        }
        subscribe(event, contextId, channel) {
          contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
          switch (event) {
            case protocol_js_1.ChromiumBidi.BiDiModule.BrowsingContext:
              Object.values(protocol_js_1.ChromiumBidi.BrowsingContext.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
              return;
            case protocol_js_1.ChromiumBidi.BiDiModule.Log:
              Object.values(protocol_js_1.ChromiumBidi.Log.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
              return;
            case protocol_js_1.ChromiumBidi.BiDiModule.Network:
              Object.values(protocol_js_1.ChromiumBidi.Network.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
              return;
            case protocol_js_1.ChromiumBidi.BiDiModule.Script:
              Object.values(protocol_js_1.ChromiumBidi.Script.EventNames).map((specificEvent) => this.subscribe(specificEvent, contextId, channel));
              return;
            default:
          }
          if (!this.#channelToContextToEventMap.has(channel)) {
            this.#channelToContextToEventMap.set(channel, /* @__PURE__ */ new Map());
          }
          const contextToEventMap = this.#channelToContextToEventMap.get(channel);
          if (!contextToEventMap.has(contextId)) {
            contextToEventMap.set(contextId, /* @__PURE__ */ new Map());
          }
          const eventMap = contextToEventMap.get(contextId);
          if (eventMap.has(event)) {
            return;
          }
          eventMap.set(event, this.#subscriptionPriority++);
        }
        /**
         * Unsubscribes atomically from all events in the given contexts and channel.
         */
        unsubscribeAll(events, contextIds, channel) {
          for (const contextId of contextIds) {
            if (contextId !== null) {
              this.#browsingContextStorage.getContext(contextId);
            }
          }
          const eventContextPairs = cartesianProduct(unrollEvents(events), contextIds);
          eventContextPairs.map(([event, contextId]) => this.#checkUnsubscribe(event, contextId, channel)).forEach((unsubscribe) => unsubscribe());
        }
        /**
         * Unsubscribes from the event in the given context and channel.
         * Syntactic sugar for "unsubscribeAll".
         */
        unsubscribe(eventName, contextId, channel) {
          this.unsubscribeAll([eventName], [contextId], channel);
        }
        #checkUnsubscribe(event, contextId, channel) {
          contextId = this.#browsingContextStorage.findTopLevelContextId(contextId);
          if (!this.#channelToContextToEventMap.has(channel)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
          }
          const contextToEventMap = this.#channelToContextToEventMap.get(channel);
          if (!contextToEventMap.has(contextId)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
          }
          const eventMap = contextToEventMap.get(contextId);
          if (!eventMap.has(event)) {
            throw new protocol_js_1.InvalidArgumentException(`Cannot unsubscribe from ${event}, ${contextId === null ? "null" : contextId}. No subscription found.`);
          }
          return () => {
            eventMap.delete(event);
            if (eventMap.size === 0) {
              contextToEventMap.delete(event);
            }
            if (contextToEventMap.size === 0) {
              this.#channelToContextToEventMap.delete(channel);
            }
          };
        }
      };
      exports8.SubscriptionManager = SubscriptionManager;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/EventManager.js
  var require_EventManager = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/events/EventManager.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.EventManager = void 0;
      var protocol_js_1 = require_protocol();
      var Buffer_js_1 = require_Buffer();
      var DefaultMap_js_1 = require_DefaultMap();
      var EventEmitter_js_1 = require_EventEmitter();
      var IdWrapper_js_1 = require_IdWrapper();
      var OutgoingMessage_js_1 = require_OutgoingMessage();
      var events_js_1 = require_events();
      var SubscriptionManager_js_1 = require_SubscriptionManager();
      var EventWrapper = class {
        #idWrapper = new IdWrapper_js_1.IdWrapper();
        #contextId;
        #event;
        constructor(event, contextId) {
          this.#event = event;
          this.#contextId = contextId;
        }
        get id() {
          return this.#idWrapper.id;
        }
        get contextId() {
          return this.#contextId;
        }
        get event() {
          return this.#event;
        }
      };
      var eventBufferLength = /* @__PURE__ */ new Map([[protocol_js_1.ChromiumBidi.Log.EventNames.LogEntryAdded, 100]]);
      var EventManager = class _EventManager extends EventEmitter_js_1.EventEmitter {
        /**
         * Maps event name to a set of contexts where this event already happened.
         * Needed for getting buffered events from all the contexts in case of
         * subscripting to all contexts.
         */
        #eventToContextsMap = new DefaultMap_js_1.DefaultMap(() => /* @__PURE__ */ new Set());
        /**
         * Maps `eventName` + `browsingContext` to buffer. Used to get buffered events
         * during subscription. Channel-agnostic.
         */
        #eventBuffers = /* @__PURE__ */ new Map();
        /**
         * Maps `eventName` + `browsingContext` + `channel` to last sent event id.
         * Used to avoid sending duplicated events when user
         * subscribes -> unsubscribes -> subscribes.
         */
        #lastMessageSent = /* @__PURE__ */ new Map();
        #subscriptionManager;
        #browsingContextStorage;
        constructor(browsingContextStorage) {
          super();
          this.#browsingContextStorage = browsingContextStorage;
          this.#subscriptionManager = new SubscriptionManager_js_1.SubscriptionManager(browsingContextStorage);
        }
        /**
         * Returns consistent key to be used to access value maps.
         */
        static #getMapKey(eventName, browsingContext, channel) {
          return JSON.stringify({ eventName, browsingContext, channel });
        }
        registerEvent(event, contextId) {
          this.registerPromiseEvent(Promise.resolve({
            kind: "success",
            value: event
          }), contextId, event.method);
        }
        registerPromiseEvent(event, contextId, eventName) {
          const eventWrapper = new EventWrapper(event, contextId);
          const sortedChannels = this.#subscriptionManager.getChannelsSubscribedToEvent(eventName, contextId);
          this.#bufferEvent(eventWrapper, eventName);
          for (const channel of sortedChannels) {
            this.emit("event", {
              message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(event, channel),
              event: eventName
            });
            this.#markEventSent(eventWrapper, channel, eventName);
          }
        }
        subscribe(eventNames, contextIds, channel) {
          for (const name2 of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name2);
          }
          for (const contextId of contextIds) {
            if (contextId !== null) {
              this.#browsingContextStorage.getContext(contextId);
            }
          }
          for (const eventName of eventNames) {
            for (const contextId of contextIds) {
              this.#subscriptionManager.subscribe(eventName, contextId, channel);
              for (const eventWrapper of this.#getBufferedEvents(eventName, contextId, channel)) {
                this.emit("event", {
                  message: OutgoingMessage_js_1.OutgoingMessage.createFromPromise(eventWrapper.event, channel),
                  event: eventName
                });
                this.#markEventSent(eventWrapper, channel, eventName);
              }
            }
          }
        }
        unsubscribe(eventNames, contextIds, channel) {
          for (const name2 of eventNames) {
            (0, events_js_1.assertSupportedEvent)(name2);
          }
          this.#subscriptionManager.unsubscribeAll(eventNames, contextIds, channel);
        }
        /**
         * If the event is buffer-able, put it in the buffer.
         */
        #bufferEvent(eventWrapper, eventName) {
          if (!eventBufferLength.has(eventName)) {
            return;
          }
          const bufferMapKey = _EventManager.#getMapKey(eventName, eventWrapper.contextId);
          if (!this.#eventBuffers.has(bufferMapKey)) {
            this.#eventBuffers.set(bufferMapKey, new Buffer_js_1.Buffer(eventBufferLength.get(eventName)));
          }
          this.#eventBuffers.get(bufferMapKey).add(eventWrapper);
          this.#eventToContextsMap.get(eventName).add(eventWrapper.contextId);
        }
        /**
         * If the event is buffer-able, mark it as sent to the given contextId and channel.
         */
        #markEventSent(eventWrapper, channel, eventName) {
          if (!eventBufferLength.has(eventName)) {
            return;
          }
          const lastSentMapKey = _EventManager.#getMapKey(eventName, eventWrapper.contextId, channel);
          this.#lastMessageSent.set(lastSentMapKey, Math.max(this.#lastMessageSent.get(lastSentMapKey) ?? 0, eventWrapper.id));
        }
        /**
         * Returns events which are buffered and not yet sent to the given channel events.
         */
        #getBufferedEvents(eventName, contextId, channel) {
          const bufferMapKey = _EventManager.#getMapKey(eventName, contextId);
          const lastSentMapKey = _EventManager.#getMapKey(eventName, contextId, channel);
          const lastSentMessageId = this.#lastMessageSent.get(lastSentMapKey) ?? -Infinity;
          const result = this.#eventBuffers.get(bufferMapKey)?.get().filter((wrapper) => wrapper.id > lastSentMessageId) ?? [];
          if (contextId === null) {
            Array.from(this.#eventToContextsMap.get(eventName).keys()).filter((_contextId) => (
              // Events without context are already in the result.
              _contextId !== null && // Events from deleted contexts should not be sent.
              this.#browsingContextStorage.hasContext(_contextId)
            )).map((_contextId) => this.#getBufferedEvents(eventName, _contextId, channel)).forEach((events) => result.push(...events));
          }
          return result.sort((e1, e22) => e1.id - e22.id);
        }
      };
      exports8.EventManager = EventManager;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/RealmStorage.js
  var require_RealmStorage = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/domains/script/RealmStorage.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.RealmStorage = void 0;
      var protocol_js_1 = require_protocol();
      var RealmStorage = class {
        /** Tracks handles and their realms sent to the client. */
        #knownHandlesToRealmMap = /* @__PURE__ */ new Map();
        /** Map from realm ID to Realm. */
        #realmMap = /* @__PURE__ */ new Map();
        get knownHandlesToRealmMap() {
          return this.#knownHandlesToRealmMap;
        }
        addRealm(realm) {
          this.#realmMap.set(realm.realmId, realm);
        }
        /** Finds all realms that match the given filter. */
        findRealms(filter) {
          return Array.from(this.#realmMap.values()).filter((realm) => {
            if (filter.realmId !== void 0 && filter.realmId !== realm.realmId) {
              return false;
            }
            if (filter.browsingContextId !== void 0 && filter.browsingContextId !== realm.browsingContextId) {
              return false;
            }
            if (filter.navigableId !== void 0 && filter.navigableId !== realm.navigableId) {
              return false;
            }
            if (filter.executionContextId !== void 0 && filter.executionContextId !== realm.executionContextId) {
              return false;
            }
            if (filter.origin !== void 0 && filter.origin !== realm.origin) {
              return false;
            }
            if (filter.type !== void 0 && filter.type !== realm.type) {
              return false;
            }
            if (filter.sandbox !== void 0 && filter.sandbox !== realm.sandbox) {
              return false;
            }
            if (filter.cdpSessionId !== void 0 && filter.cdpSessionId !== realm.cdpClient.sessionId) {
              return false;
            }
            return true;
          });
        }
        findRealm(filter) {
          const maybeRealms = this.findRealms(filter);
          if (maybeRealms.length !== 1) {
            return void 0;
          }
          return maybeRealms[0];
        }
        /** Gets the only realm that matches the given filter, if any, otherwise throws. */
        getRealm(filter) {
          const maybeRealm = this.findRealm(filter);
          if (maybeRealm === void 0) {
            throw new protocol_js_1.NoSuchFrameException(`Realm ${JSON.stringify(filter)} not found`);
          }
          return maybeRealm;
        }
        /** Deletes all realms that match the given filter. */
        deleteRealms(filter) {
          this.findRealms(filter).map((realm) => {
            realm.dispose();
            this.#realmMap.delete(realm.realmId);
            Array.from(this.knownHandlesToRealmMap.entries()).filter(([, r9]) => r9 === realm.realmId).map(([handle]) => this.knownHandlesToRealmMap.delete(handle));
          });
        }
      };
      exports8.RealmStorage = RealmStorage;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js
  var require_BidiServer = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiServer.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.BidiServer = void 0;
      var EventEmitter_js_1 = require_EventEmitter();
      var log_js_1 = require_log();
      var ProcessingQueue_js_1 = require_ProcessingQueue();
      var CommandProcessor_js_1 = require_CommandProcessor();
      var BrowsingContextStorage_js_1 = require_BrowsingContextStorage();
      var EventManager_js_1 = require_EventManager();
      var RealmStorage_js_1 = require_RealmStorage();
      var BidiServer2 = class _BidiServer extends EventEmitter_js_1.EventEmitter {
        #messageQueue;
        #transport;
        #commandProcessor;
        #eventManager;
        #browsingContextStorage = new BrowsingContextStorage_js_1.BrowsingContextStorage();
        #logger;
        #handleIncomingMessage = (message) => {
          void this.#commandProcessor.processCommand(message).catch((error) => {
            this.#logger?.(log_js_1.LogType.debugError, error);
          });
        };
        #processOutgoingMessage = async (messageEntry) => {
          const message = messageEntry.message;
          if (messageEntry.channel !== null) {
            message["channel"] = messageEntry.channel;
          }
          await this.#transport.sendMessage(message);
        };
        constructor(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, options, parser, logger) {
          super();
          this.#logger = logger;
          this.#messageQueue = new ProcessingQueue_js_1.ProcessingQueue(this.#processOutgoingMessage, this.#logger);
          this.#transport = bidiTransport;
          this.#transport.setOnMessage(this.#handleIncomingMessage);
          this.#eventManager = new EventManager_js_1.EventManager(this.#browsingContextStorage);
          this.#commandProcessor = new CommandProcessor_js_1.CommandProcessor(cdpConnection, browserCdpClient, this.#eventManager, selfTargetId, this.#browsingContextStorage, new RealmStorage_js_1.RealmStorage(), options?.acceptInsecureCerts ?? false, parser, this.#logger);
          this.#eventManager.on("event", ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
          });
          this.#commandProcessor.on("response", ({ message, event }) => {
            this.emitOutgoingMessage(message, event);
          });
        }
        /**
         * Creates and starts BiDi Mapper instance.
         */
        static async createAndStart(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, options, parser, logger) {
          const server = new _BidiServer(bidiTransport, cdpConnection, browserCdpClient, selfTargetId, options, parser, logger);
          await browserCdpClient.sendCommand("Target.setDiscoverTargets", {
            discover: true
          });
          await browserCdpClient.sendCommand("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          });
          await server.#topLevelContextsLoaded();
          return server;
        }
        /**
         * Sends BiDi message.
         */
        emitOutgoingMessage(messageEntry, event) {
          this.#messageQueue.add(messageEntry, event);
        }
        close() {
          this.#transport.close();
        }
        async #topLevelContextsLoaded() {
          await Promise.all(this.#browsingContextStorage.getTopLevelContexts().map((c7) => c7.lifecycleLoaded()));
        }
      };
      exports8.BidiServer = BidiServer2;
    }
  });

  // node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js
  var require_BidiMapper = __commonJS({
    "node_modules/chromium-bidi/lib/cjs/bidiMapper/BidiMapper.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.OutgoingMessage = exports8.EventEmitter = exports8.BidiServer = void 0;
      var BidiServer_js_1 = require_BidiServer();
      Object.defineProperty(exports8, "BidiServer", { enumerable: true, get: function() {
        return BidiServer_js_1.BidiServer;
      } });
      var EventEmitter_js_1 = require_EventEmitter();
      Object.defineProperty(exports8, "EventEmitter", { enumerable: true, get: function() {
        return EventEmitter_js_1.EventEmitter;
      } });
      var OutgoingMessage_js_1 = require_OutgoingMessage();
      Object.defineProperty(exports8, "OutgoingMessage", { enumerable: true, get: function() {
        return OutgoingMessage_js_1.OutgoingMessage;
      } });
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js
  var source;
  var init_injected = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/generated/injected.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      source = '"use strict";var C=Object.defineProperty;var ne=Object.getOwnPropertyDescriptor;var oe=Object.getOwnPropertyNames;var se=Object.prototype.hasOwnProperty;var u=(t,e)=>{for(var n in e)C(t,n,{get:e[n],enumerable:!0})},ie=(t,e,n,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of oe(e))!se.call(t,o)&&o!==n&&C(t,o,{get:()=>e[o],enumerable:!(r=ne(e,o))||r.enumerable});return t};var le=t=>ie(C({},"__esModule",{value:!0}),t);var Oe={};u(Oe,{default:()=>Re});module.exports=le(Oe);var T=class extends Error{constructor(e){super(e),this.name=this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}},S=class extends T{},I=class extends T{#e;#t="";set code(e){this.#e=e}get code(){return this.#e}set originalMessage(e){this.#t=e}get originalMessage(){return this.#t}};var qe=Object.freeze({TimeoutError:S,ProtocolError:I});var f=class t{#e=!1;#t=!1;#n;#r=()=>{};#o=new Promise(e=>{this.#r=e});#s;#i;constructor(e){e&&e.timeout>0&&(this.#i=new S(e.message),this.#s=setTimeout(()=>{this.reject(this.#i)},e.timeout))}#l(e){clearTimeout(this.#s),this.#n=e,this.#r()}resolve(e){this.#t||this.#e||(this.#e=!0,this.#l(e))}reject(e){this.#t||this.#e||(this.#t=!0,this.#l(e))}resolved(){return this.#e}finished(){return this.#e||this.#t}value(){return this.#n}async valueOrThrow(){if(await this.#o,this.#t)throw this.#n;return this.#n}static create(e){return new t(e)}static async race(e){let n=new Set;try{let r=e.map(o=>o instanceof t?(o.#s&&n.add(o),o.valueOrThrow()):o);return await Promise.race(r)}finally{for(let r of n)r.reject(new Error("Timeout cleared"))}}};var X=new Map,G=t=>{let e=X.get(t);return e||(e=new Function(`return ${t}`)(),X.set(t,e),e)};var R={};u(R,{ariaQuerySelector:()=>ae,ariaQuerySelectorAll:()=>k});var ae=(t,e)=>window.__ariaQuerySelector(t,e),k=async function*(t,e){yield*await window.__ariaQuerySelectorAll(t,e)};var q={};u(q,{customQuerySelectors:()=>M});var O=class{#e=new Map;register(e,n){if(!n.queryOne&&n.queryAll){let r=n.queryAll;n.queryOne=(o,i)=>{for(let s of r(o,i))return s;return null}}else if(n.queryOne&&!n.queryAll){let r=n.queryOne;n.queryAll=(o,i)=>{let s=r(o,i);return s?[s]:[]}}else if(!n.queryOne||!n.queryAll)throw new Error("At least one query method must be defined.");this.#e.set(e,{querySelector:n.queryOne,querySelectorAll:n.queryAll})}unregister(e){this.#e.delete(e)}get(e){return this.#e.get(e)}clear(){this.#e.clear()}},M=new O;var D={};u(D,{pierceQuerySelector:()=>ce,pierceQuerySelectorAll:()=>ue});var ce=(t,e)=>{let n=null,r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&!n&&s.matches(e)&&(n=s)}while(!n&&i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n},ue=(t,e)=>{let n=[],r=o=>{let i=document.createTreeWalker(o,NodeFilter.SHOW_ELEMENT);do{let s=i.currentNode;s.shadowRoot&&r(s.shadowRoot),!(s instanceof ShadowRoot)&&s!==o&&s.matches(e)&&n.push(s)}while(i.nextNode())};return t instanceof Document&&(t=t.documentElement),r(t),n};var m=(t,e)=>{if(!t)throw new Error(e)};var E=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=new MutationObserver(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())}),this.#n.observe(this.#t,{childList:!0,subtree:!0,attributes:!0})}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped")),this.#n&&(this.#n.disconnect(),this.#n=void 0)}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}},P=class{#e;#t;constructor(e){this.#e=e}async start(){let e=this.#t=f.create(),n=await this.#e();if(n){e.resolve(n);return}let r=async()=>{if(e.finished())return;let o=await this.#e();if(!o){window.requestAnimationFrame(r);return}e.resolve(o),await this.stop()};window.requestAnimationFrame(r)}async stop(){m(this.#t,"Polling never started."),this.#t.finished()||this.#t.reject(new Error("Polling stopped"))}result(){return m(this.#t,"Polling never started."),this.#t.valueOrThrow()}},x=class{#e;#t;#n;#r;constructor(e,n){this.#e=e,this.#t=n}async start(){let e=this.#r=f.create(),n=await this.#e();if(n){e.resolve(n);return}this.#n=setInterval(async()=>{let r=await this.#e();r&&(e.resolve(r),await this.stop())},this.#t)}async stop(){m(this.#r,"Polling never started."),this.#r.finished()||this.#r.reject(new Error("Polling stopped")),this.#n&&(clearInterval(this.#n),this.#n=void 0)}result(){return m(this.#r,"Polling never started."),this.#r.valueOrThrow()}};var W={};u(W,{pQuerySelector:()=>Ie,pQuerySelectorAll:()=>re});var c=class{static async*map(e,n){for await(let r of e)yield await n(r)}static async*flatMap(e,n){for await(let r of e)yield*n(r)}static async collect(e){let n=[];for await(let r of e)n.push(r);return n}static async first(e){for await(let n of e)return n}};var p={attribute:/\\[\\s*(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)\\s*(?:(?<operator>\\W?=)\\s*(?<value>.+?)\\s*(\\s(?<caseSensitive>[iIsS]))?\\s*)?\\]/gu,id:/#(?<name>[-\\w\\P{ASCII}]+)/gu,class:/\\.(?<name>[-\\w\\P{ASCII}]+)/gu,comma:/\\s*,\\s*/g,combinator:/\\s*[\\s>+~]\\s*/g,"pseudo-element":/::(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6*)\\))?/gu,"pseudo-class":/:(?<name>[-\\w\\P{ASCII}]+)(?:\\((?<argument>\xB6*)\\))?/gu,universal:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?\\*/gu,type:/(?:(?<namespace>\\*|[-\\w\\P{ASCII}]*)\\|)?(?<name>[-\\w\\P{ASCII}]+)/gu},fe=new Set(["combinator","comma"]);var de=t=>{switch(t){case"pseudo-element":case"pseudo-class":return new RegExp(p[t].source.replace("(?<argument>\\xB6*)","(?<argument>.*)"),"gu");default:return p[t]}};function me(t,e){let n=0,r="";for(;e<t.length;e++){let o=t[e];switch(o){case"(":++n;break;case")":--n;break}if(r+=o,n===0)return r}return r}function he(t,e=p){if(!t)return[];let n=[t];for(let[o,i]of Object.entries(e))for(let s=0;s<n.length;s++){let l=n[s];if(typeof l!="string")continue;i.lastIndex=0;let a=i.exec(l);if(!a)continue;let h=a.index-1,d=[],H=a[0],B=l.slice(0,h+1);B&&d.push(B),d.push({...a.groups,type:o,content:H});let z=l.slice(h+H.length+1);z&&d.push(z),n.splice(s,1,...d)}let r=0;for(let o of n)switch(typeof o){case"string":throw new Error(`Unexpected sequence ${o} found at index ${r}`);case"object":r+=o.content.length,o.pos=[r-o.content.length,r],fe.has(o.type)&&(o.content=o.content.trim()||" ");break}return n}var pe=/([\'"])([^\\\\\\n]+?)\\1/g,ye=/\\\\./g;function K(t,e=p){if(t=t.trim(),t==="")return[];let n=[];t=t.replace(ye,(i,s)=>(n.push({value:i,offset:s}),"\\uE000".repeat(i.length))),t=t.replace(pe,(i,s,l,a)=>(n.push({value:i,offset:a}),`${s}${"\\uE001".repeat(l.length)}${s}`));{let i=0,s;for(;(s=t.indexOf("(",i))>-1;){let l=me(t,s);n.push({value:l,offset:s}),t=`${t.substring(0,s)}(${"\\xB6".repeat(l.length-2)})${t.substring(s+l.length)}`,i=s+l.length}}let r=he(t,e),o=new Set;for(let i of n.reverse())for(let s of r){let{offset:l,value:a}=i;if(!(s.pos[0]<=l&&l+a.length<=s.pos[1]))continue;let{content:h}=s,d=l-s.pos[0];s.content=h.slice(0,d)+a+h.slice(d+a.length),s.content!==h&&o.add(s)}for(let i of o){let s=de(i.type);if(!s)throw new Error(`Unknown token type: ${i.type}`);s.lastIndex=0;let l=s.exec(i.content);if(!l)throw new Error(`Unable to parse content for ${i.type}: ${i.content}`);Object.assign(i,l.groups)}return r}function*N(t,e){switch(t.type){case"list":for(let n of t.list)yield*N(n,t);break;case"complex":yield*N(t.left,t),yield*N(t.right,t);break;case"compound":yield*t.list.map(n=>[n,t]);break;default:yield[t,e]}}function y(t){let e;return Array.isArray(t)?e=t:e=[...N(t)].map(([n])=>n),e.map(n=>n.content).join("")}p.combinator=/\\s*(>>>>?|[\\s>+~])\\s*/g;var ge=/\\\\[\\s\\S]/g,we=t=>t.length<=1?t:((t[0]===\'"\'||t[0]==="\'")&&t.endsWith(t[0])&&(t=t.slice(1,-1)),t.replace(ge,e=>e[1]));function Y(t){let e=!0,n=K(t);if(n.length===0)return[[],e];let r=[],o=[r],i=[o],s=[];for(let l of n){switch(l.type){case"combinator":switch(l.content){case">>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>"),o.push(r);continue;case">>>>":e=!1,s.length&&(r.push(y(s)),s.splice(0)),r=[],o.push(">>>>"),o.push(r);continue}break;case"pseudo-element":if(!l.name.startsWith("-p-"))break;e=!1,s.length&&(r.push(y(s)),s.splice(0)),r.push({name:l.name.slice(3),value:we(l.argument??"")});continue;case"comma":s.length&&(r.push(y(s)),s.splice(0)),r=[],o=[r],i.push(o);continue}s.push(l)}return s.length&&r.push(y(s)),[i,e]}var Q={};u(Q,{textQuerySelectorAll:()=>b});var Se=new Set(["checkbox","image","radio"]),be=t=>t instanceof HTMLSelectElement||t instanceof HTMLTextAreaElement||t instanceof HTMLInputElement&&!Se.has(t.type),Te=new Set(["SCRIPT","STYLE"]),w=t=>!Te.has(t.nodeName)&&!document.head?.contains(t),_=new WeakMap,Z=t=>{for(;t;)_.delete(t),t instanceof ShadowRoot?t=t.host:t=t.parentNode},J=new WeakSet,Ee=new MutationObserver(t=>{for(let e of t)Z(e.target)}),g=t=>{let e=_.get(t);if(e||(e={full:"",immediate:[]},!w(t)))return e;let n="";if(be(t))e.full=t.value,e.immediate.push(t.value),t.addEventListener("input",r=>{Z(r.target)},{once:!0,capture:!0});else{for(let r=t.firstChild;r;r=r.nextSibling){if(r.nodeType===Node.TEXT_NODE){e.full+=r.nodeValue??"",n+=r.nodeValue??"";continue}n&&e.immediate.push(n),n="",r.nodeType===Node.ELEMENT_NODE&&(e.full+=g(r).full)}n&&e.immediate.push(n),t instanceof Element&&t.shadowRoot&&(e.full+=g(t.shadowRoot).full),J.has(t)||(Ee.observe(t,{childList:!0,characterData:!0,subtree:!0}),J.add(t))}return _.set(t,e),e};var b=function*(t,e){let n=!1;for(let r of t.childNodes)if(r instanceof Element&&w(r)){let o;r.shadowRoot?o=b(r.shadowRoot,e):o=b(r,e);for(let i of o)yield i,n=!0}n||t instanceof Element&&w(t)&&g(t).full.includes(e)&&(yield t)};var $={};u($,{checkVisibility:()=>xe,pierce:()=>A,pierceAll:()=>L});var Pe=["hidden","collapse"],xe=(t,e)=>{if(!t)return e===!1;if(e===void 0)return t;let n=t.nodeType===Node.TEXT_NODE?t.parentElement:t,r=window.getComputedStyle(n),o=r&&!Pe.includes(r.visibility)&&!Ne(n);return e===o?t:!1};function Ne(t){let e=t.getBoundingClientRect();return e.width===0||e.height===0}var Ae=t=>"shadowRoot"in t&&t.shadowRoot instanceof ShadowRoot;function*A(t){Ae(t)?yield t.shadowRoot:yield t}function*L(t){t=A(t).next().value,yield t;let e=[document.createTreeWalker(t,NodeFilter.SHOW_ELEMENT)];for(let n of e){let r;for(;r=n.nextNode();)r.shadowRoot&&(yield r.shadowRoot,e.push(document.createTreeWalker(r.shadowRoot,NodeFilter.SHOW_ELEMENT)))}}var U={};u(U,{xpathQuerySelectorAll:()=>j});var j=function*(t,e,n=-1){let o=(t.ownerDocument||document).evaluate(e,t,null,XPathResult.ORDERED_NODE_ITERATOR_TYPE),i=[],s;for(;(s=o.iterateNext())&&(i.push(s),!(n&&i.length===n)););for(let l=0;l<i.length;l++)s=i[l],yield s,delete i[l]};var ve=/[-\\w\\P{ASCII}*]/,ee=t=>"querySelectorAll"in t,v=class extends Error{constructor(e,n){super(`${e} is not a valid selector: ${n}`)}},F=class{#e;#t;#n=[];#r=void 0;elements;constructor(e,n,r){this.elements=[e],this.#e=n,this.#t=r,this.#o()}async run(){if(typeof this.#r=="string")switch(this.#r.trimStart()){case":scope":this.#o();break}for(;this.#r!==void 0;this.#o()){let e=this.#r,n=this.#e;typeof e=="string"?e[0]&&ve.test(e[0])?this.elements=c.flatMap(this.elements,async function*(r){ee(r)&&(yield*r.querySelectorAll(e))}):this.elements=c.flatMap(this.elements,async function*(r){if(!r.parentElement){if(!ee(r))return;yield*r.querySelectorAll(e);return}let o=0;for(let i of r.parentElement.children)if(++o,i===r)break;yield*r.parentElement.querySelectorAll(`:scope>:nth-child(${o})${e}`)}):this.elements=c.flatMap(this.elements,async function*(r){switch(e.name){case"text":yield*b(r,e.value);break;case"xpath":yield*j(r,e.value);break;case"aria":yield*k(r,e.value);break;default:let o=M.get(e.name);if(!o)throw new v(n,`Unknown selector type: ${e.name}`);yield*o.querySelectorAll(r,e.value)}})}}#o(){if(this.#n.length!==0){this.#r=this.#n.shift();return}if(this.#t.length===0){this.#r=void 0;return}let e=this.#t.shift();switch(e){case">>>>":{this.elements=c.flatMap(this.elements,A),this.#o();break}case">>>":{this.elements=c.flatMap(this.elements,L),this.#o();break}default:this.#n=e,this.#o();break}}},V=class{#e=new WeakMap;calculate(e,n=[]){if(e===null)return n;e instanceof ShadowRoot&&(e=e.host);let r=this.#e.get(e);if(r)return[...r,...n];let o=0;for(let s=e.previousSibling;s;s=s.previousSibling)++o;let i=this.calculate(e.parentNode,[o]);return this.#e.set(e,i),[...i,...n]}},te=(t,e)=>{if(t.length+e.length===0)return 0;let[n=-1,...r]=t,[o=-1,...i]=e;return n===o?te(r,i):n<o?-1:1},Ce=async function*(t){let e=new Set;for await(let r of t)e.add(r);let n=new V;yield*[...e.values()].map(r=>[r,n.calculate(r)]).sort(([,r],[,o])=>te(r,o)).map(([r])=>r)},re=function(t,e){let n,r;try{[n,r]=Y(e)}catch{return t.querySelectorAll(e)}if(r)return t.querySelectorAll(e);if(n.some(o=>{let i=0;return o.some(s=>(typeof s=="string"?++i:i=0,i>1))}))throw new v(e,"Multiple deep combinators found in sequence.");return Ce(c.flatMap(n,o=>{let i=new F(t,e,o);return i.run(),i.elements}))},Ie=async function(t,e){for await(let n of re(t,e))return n;return null};var ke=Object.freeze({...R,...q,...D,...W,...Q,...$,...U,Deferred:f,createFunction:G,createTextContent:g,IntervalPoller:x,isSuitableNodeForTextMatching:w,MutationPoller:E,RAFPoller:P}),Re=ke;\n/**\n * @license\n * Copyright 2018 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2023 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2022 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @license\n * Copyright 2020 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n';
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js
  var ScriptInjector, scriptInjector;
  var init_ScriptInjector = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/ScriptInjector.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_injected();
      ScriptInjector = class {
        #updated = false;
        #amendments = /* @__PURE__ */ new Set();
        // Appends a statement of the form `(PuppeteerUtil) => {...}`.
        append(statement) {
          this.#update(() => {
            this.#amendments.add(statement);
          });
        }
        pop(statement) {
          this.#update(() => {
            this.#amendments.delete(statement);
          });
        }
        inject(inject, force = false) {
          if (this.#updated || force) {
            inject(this.#get());
          }
          this.#updated = false;
        }
        #update(callback) {
          callback();
          this.#updated = true;
        }
        #get() {
          return `(() => {
      const module = {};
      ${source}
      ${[...this.#amendments].map((statement) => {
            return `(${statement})(module.exports.default);`;
          }).join("")}
      return module.exports.default;
    })()`;
        }
      };
      scriptInjector = new ScriptInjector();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js
  function stringifyFunction(fn) {
    let value = fn.toString();
    try {
      new Function(`(${value})`);
    } catch {
      let prefix = "function ";
      if (value.startsWith("async ")) {
        prefix = `async ${prefix}`;
        value = value.substring("async ".length);
      }
      value = `${prefix}${value}`;
      try {
        new Function(`(${value})`);
      } catch {
        throw new Error("Passed function cannot be serialized!");
      }
    }
    return value;
  }
  var createdFunctions, createFunction, interpolateFunction;
  var init_Function = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/Function.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      createdFunctions = /* @__PURE__ */ new Map();
      createFunction = (functionValue) => {
        let fn = createdFunctions.get(functionValue);
        if (fn) {
          return fn;
        }
        fn = new Function(`return ${functionValue}`)();
        createdFunctions.set(functionValue, fn);
        return fn;
      };
      interpolateFunction = (fn, replacements) => {
        let value = stringifyFunction(fn);
        for (const [name2, jsValue] of Object.entries(replacements)) {
          value = value.replace(
            new RegExp(`PLACEHOLDER\\(\\s*(?:'${name2}'|"${name2}")\\s*\\)`, "g"),
            // Wrapping this ensures tersers that accidently inline PLACEHOLDER calls
            // are still valid. Without, we may get calls like ()=>{...}() which is
            // not valid.
            `(${jsValue})`
          );
        }
        return createFunction(value);
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js
  var BidiDeserializer;
  var init_Deserializer = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_util2();
      BidiDeserializer = class _BidiDeserializer {
        static deserializeNumber(value) {
          switch (value) {
            case "-0":
              return -0;
            case "NaN":
              return NaN;
            case "Infinity":
              return Infinity;
            case "-Infinity":
              return -Infinity;
            default:
              return value;
          }
        }
        static deserializeLocalValue(result) {
          switch (result.type) {
            case "array":
              return result.value?.map((value) => {
                return _BidiDeserializer.deserializeLocalValue(value);
              });
            case "set":
              return result.value?.reduce((acc, value) => {
                return acc.add(_BidiDeserializer.deserializeLocalValue(value));
              }, /* @__PURE__ */ new Set());
            case "object":
              return result.value?.reduce((acc, tuple) => {
                const { key, value } = _BidiDeserializer.deserializeTuple(tuple);
                acc[key] = value;
                return acc;
              }, {});
            case "map":
              return result.value?.reduce((acc, tuple) => {
                const { key, value } = _BidiDeserializer.deserializeTuple(tuple);
                return acc.set(key, value);
              }, /* @__PURE__ */ new Map());
            case "promise":
              return {};
            case "regexp":
              return new RegExp(result.value.pattern, result.value.flags);
            case "date":
              return new Date(result.value);
            case "undefined":
              return void 0;
            case "null":
              return null;
            case "number":
              return _BidiDeserializer.deserializeNumber(result.value);
            case "bigint":
              return BigInt(result.value);
            case "boolean":
              return Boolean(result.value);
            case "string":
              return result.value;
          }
          debugError(`Deserialization of type ${result.type} not supported.`);
          return void 0;
        }
        static deserializeTuple([serializedKey, serializedValue]) {
          const key = typeof serializedKey === "string" ? serializedKey : _BidiDeserializer.deserializeLocalValue(serializedKey);
          const value = _BidiDeserializer.deserializeLocalValue(serializedValue);
          return { key, value };
        }
        static deserialize(result) {
          if (!result) {
            debugError("Service did not produce a result.");
            return void 0;
          }
          return _BidiDeserializer.deserializeLocalValue(result);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js
  var _isElementHandle;
  var init_ElementHandleSymbol = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      _isElementHandle = Symbol("_isElementHandle");
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js
  async function* fastTransposeIteratorHandle(iterator, size) {
    const env_1 = { stack: [], error: void 0, hasError: false };
    try {
      const array = __addDisposableResource(env_1, await iterator.evaluateHandle(async (iterator2, size2) => {
        const results = [];
        while (results.length < size2) {
          const result = await iterator2.next();
          if (result.done) {
            break;
          }
          results.push(result.value);
        }
        return results;
      }, size), false);
      const properties = await array.getProperties();
      const handles = properties.values();
      const stack = __addDisposableResource(env_1, new DisposableStack(), false);
      stack.defer(() => {
        for (const handle_1 of handles) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource(env_2, handle_1, false);
            handle[disposeSymbol]();
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources(env_2);
          }
        }
      });
      yield* handles;
      return properties.size === 0;
    } catch (e_1) {
      env_1.error = e_1;
      env_1.hasError = true;
    } finally {
      __disposeResources(env_1);
    }
  }
  async function* transposeIteratorHandle(iterator) {
    let size = DEFAULT_BATCH_SIZE;
    while (!(yield* fastTransposeIteratorHandle(iterator, size))) {
      size <<= 1;
    }
  }
  async function* transposeIterableHandle(handle) {
    const env_3 = { stack: [], error: void 0, hasError: false };
    try {
      const generatorHandle = __addDisposableResource(env_3, await handle.evaluateHandle((iterable) => {
        return async function* () {
          yield* iterable;
        }();
      }), false);
      yield* transposeIteratorHandle(generatorHandle);
    } catch (e_3) {
      env_3.error = e_3;
      env_3.hasError = true;
    } finally {
      __disposeResources(env_3);
    }
  }
  var __addDisposableResource, __disposeResources, DEFAULT_BATCH_SIZE;
  var init_HandleIterator = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_disposable();
      __addDisposableResource = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      DEFAULT_BATCH_SIZE = 20;
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js
  var LazyArg;
  var init_LazyArg = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/LazyArg.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      LazyArg = class _LazyArg {
        static create = (get) => {
          return new _LazyArg(get);
        };
        #get;
        constructor(get) {
          this.#get = get;
        }
        async get(context) {
          return await this.#get(context);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js
  var __addDisposableResource2, __disposeResources2, QueryHandler;
  var init_QueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_ElementHandleSymbol();
      init_ErrorLike();
      init_Function();
      init_HandleIterator();
      init_LazyArg();
      __addDisposableResource2 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources2 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      QueryHandler = class {
        // Either one of these may be implemented, but at least one must be.
        static querySelectorAll;
        static querySelector;
        static get _querySelector() {
          if (this.querySelector) {
            return this.querySelector;
          }
          if (!this.querySelectorAll) {
            throw new Error("Cannot create default `querySelector`.");
          }
          return this.querySelector = interpolateFunction(async (node, selector, PuppeteerUtil) => {
            const querySelectorAll = PLACEHOLDER("querySelectorAll");
            const results = querySelectorAll(node, selector, PuppeteerUtil);
            for await (const result of results) {
              return result;
            }
            return null;
          }, {
            querySelectorAll: stringifyFunction(this.querySelectorAll)
          });
        }
        static get _querySelectorAll() {
          if (this.querySelectorAll) {
            return this.querySelectorAll;
          }
          if (!this.querySelector) {
            throw new Error("Cannot create default `querySelectorAll`.");
          }
          return this.querySelectorAll = interpolateFunction(async function* (node, selector, PuppeteerUtil) {
            const querySelector = PLACEHOLDER("querySelector");
            const result = await querySelector(node, selector, PuppeteerUtil);
            if (result) {
              yield result;
            }
          }, {
            querySelector: stringifyFunction(this.querySelector)
          });
        }
        /**
         * Queries for multiple nodes given a selector and {@link ElementHandle}.
         *
         * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll | Document.querySelectorAll()}.
         */
        static async *queryAll(element, selector) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource2(env_1, await element.evaluateHandle(this._querySelectorAll, selector, LazyArg.create((context) => {
              return context.puppeteerUtil;
            })), false);
            yield* transposeIterableHandle(handle);
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources2(env_1);
          }
        }
        /**
         * Queries for a single node given a selector and {@link ElementHandle}.
         *
         * Akin to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector}.
         */
        static async queryOne(element, selector) {
          const env_2 = { stack: [], error: void 0, hasError: false };
          try {
            const result = __addDisposableResource2(env_2, await element.evaluateHandle(this._querySelector, selector, LazyArg.create((context) => {
              return context.puppeteerUtil;
            })), false);
            if (!(_isElementHandle in result)) {
              return null;
            }
            return result.move();
          } catch (e_2) {
            env_2.error = e_2;
            env_2.hasError = true;
          } finally {
            __disposeResources2(env_2);
          }
        }
        /**
         * Waits until a single node appears for a given selector and
         * {@link ElementHandle}.
         *
         * This will always query the handle in the Puppeteer world and migrate the
         * result to the main world.
         */
        static async waitFor(elementOrFrame, selector, options) {
          const env_3 = { stack: [], error: void 0, hasError: false };
          try {
            let frame;
            const element = __addDisposableResource2(env_3, await (async () => {
              if (!(_isElementHandle in elementOrFrame)) {
                frame = elementOrFrame;
                return;
              }
              frame = elementOrFrame.frame;
              return await frame.isolatedRealm().adoptHandle(elementOrFrame);
            })(), false);
            const { visible = false, hidden = false, timeout: timeout2, signal } = options;
            try {
              const env_4 = { stack: [], error: void 0, hasError: false };
              try {
                signal?.throwIfAborted();
                const handle = __addDisposableResource2(env_4, await frame.isolatedRealm().waitForFunction(async (PuppeteerUtil, query, selector2, root, visible2) => {
                  const querySelector = PuppeteerUtil.createFunction(query);
                  const node = await querySelector(root ?? document, selector2, PuppeteerUtil);
                  return PuppeteerUtil.checkVisibility(node, visible2);
                }, {
                  polling: visible || hidden ? "raf" : "mutation",
                  root: element,
                  timeout: timeout2,
                  signal
                }, LazyArg.create((context) => {
                  return context.puppeteerUtil;
                }), stringifyFunction(this._querySelector), selector, element, visible ? true : hidden ? false : void 0), false);
                if (signal?.aborted) {
                  throw signal.reason;
                }
                if (!(_isElementHandle in handle)) {
                  return null;
                }
                return await frame.mainRealm().transferHandle(handle);
              } catch (e_3) {
                env_4.error = e_3;
                env_4.hasError = true;
              } finally {
                __disposeResources2(env_4);
              }
            } catch (error) {
              if (!isErrorLike(error)) {
                throw error;
              }
              if (error.name === "AbortError") {
                throw error;
              }
              error.message = `Waiting for selector \`${selector}\` failed: ${error.message}`;
              throw error;
            }
          } catch (e_4) {
            env_3.error = e_4;
            env_3.hasError = true;
          } finally {
            __disposeResources2(env_3);
          }
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js
  var AsyncIterableUtil;
  var init_AsyncIterableUtil = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/AsyncIterableUtil.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      AsyncIterableUtil = class {
        static async *map(iterable, map) {
          for await (const value of iterable) {
            yield await map(value);
          }
        }
        static async *flatMap(iterable, map) {
          for await (const value of iterable) {
            yield* map(value);
          }
        }
        static async collect(iterable) {
          const result = [];
          for await (const value of iterable) {
            result.push(value);
          }
          return result;
        }
        static async first(iterable) {
          for await (const value of iterable) {
            return value;
          }
          return;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js
  var NON_ELEMENT_NODE_ROLES, queryAXTree, isKnownAttribute, normalizeValue, ATTRIBUTE_REGEXP, parseARIASelector, ARIAQueryHandler;
  var init_AriaQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_QueryHandler();
      init_assert();
      init_AsyncIterableUtil();
      NON_ELEMENT_NODE_ROLES = /* @__PURE__ */ new Set(["StaticText", "InlineTextBox"]);
      queryAXTree = async (client, element, accessibleName, role) => {
        const { nodes } = await client.send("Accessibility.queryAXTree", {
          objectId: element.id,
          accessibleName,
          role
        });
        return nodes.filter((node) => {
          return !node.role || !NON_ELEMENT_NODE_ROLES.has(node.role.value);
        });
      };
      isKnownAttribute = (attribute) => {
        return ["name", "role"].includes(attribute);
      };
      normalizeValue = (value) => {
        return value.replace(/ +/g, " ").trim();
      };
      ATTRIBUTE_REGEXP = /\[\s*(?<attribute>\w+)\s*=\s*(?<quote>"|')(?<value>\\.|.*?(?=\k<quote>))\k<quote>\s*\]/g;
      parseARIASelector = (selector) => {
        const queryOptions = {};
        const defaultName = selector.replace(ATTRIBUTE_REGEXP, (_5, attribute, __, value) => {
          attribute = attribute.trim();
          assert2(isKnownAttribute(attribute), `Unknown aria attribute "${attribute}" in selector`);
          queryOptions[attribute] = normalizeValue(value);
          return "";
        });
        if (defaultName && !queryOptions.name) {
          queryOptions.name = normalizeValue(defaultName);
        }
        return queryOptions;
      };
      ARIAQueryHandler = class extends QueryHandler {
        static querySelector = async (node, selector, { ariaQuerySelector }) => {
          return await ariaQuerySelector(node, selector);
        };
        static async *queryAll(element, selector) {
          const { name: name2, role } = parseARIASelector(selector);
          const results = await queryAXTree(element.realm.environment.client, element, name2, role);
          yield* AsyncIterableUtil.map(results, (node) => {
            return element.realm.adoptBackendNode(node.backendDOMNodeId);
          });
        }
        static queryOne = async (element, selector) => {
          return await AsyncIterableUtil.first(this.queryAll(element, selector)) ?? null;
        };
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js
  var CustomQueryHandlerRegistry, customQueryHandlers;
  var init_CustomQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_assert();
      init_Function();
      init_QueryHandler();
      init_ScriptInjector();
      CustomQueryHandlerRegistry = class {
        #handlers = /* @__PURE__ */ new Map();
        get(name2) {
          const handler = this.#handlers.get(name2);
          return handler ? handler[1] : void 0;
        }
        /**
         * Registers a {@link CustomQueryHandler | custom query handler}.
         *
         * @remarks
         * After registration, the handler can be used everywhere where a selector is
         * expected by prepending the selection string with `<name>/`. The name is
         * only allowed to consist of lower- and upper case latin letters.
         *
         * @example
         *
         * ```ts
         * Puppeteer.customQueryHandlers.register('lit', { … });
         * const aHandle = await page.$('lit/…');
         * ```
         *
         * @param name - Name to register under.
         * @param queryHandler - {@link CustomQueryHandler | Custom query handler} to
         * register.
         */
        register(name2, handler) {
          assert2(!this.#handlers.has(name2), `Cannot register over existing handler: ${name2}`);
          assert2(/^[a-zA-Z]+$/.test(name2), `Custom query handler names may only contain [a-zA-Z]`);
          assert2(handler.queryAll || handler.queryOne, `At least one query method must be implemented.`);
          const Handler = class extends QueryHandler {
            static querySelectorAll = interpolateFunction((node, selector, PuppeteerUtil) => {
              return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelectorAll(node, selector);
            }, { name: JSON.stringify(name2) });
            static querySelector = interpolateFunction((node, selector, PuppeteerUtil) => {
              return PuppeteerUtil.customQuerySelectors.get(PLACEHOLDER("name")).querySelector(node, selector);
            }, { name: JSON.stringify(name2) });
          };
          const registerScript = interpolateFunction((PuppeteerUtil) => {
            PuppeteerUtil.customQuerySelectors.register(PLACEHOLDER("name"), {
              queryAll: PLACEHOLDER("queryAll"),
              queryOne: PLACEHOLDER("queryOne")
            });
          }, {
            name: JSON.stringify(name2),
            queryAll: handler.queryAll ? stringifyFunction(handler.queryAll) : String(void 0),
            queryOne: handler.queryOne ? stringifyFunction(handler.queryOne) : String(void 0)
          }).toString();
          this.#handlers.set(name2, [registerScript, Handler]);
          scriptInjector.append(registerScript);
        }
        /**
         * Unregisters the {@link CustomQueryHandler | custom query handler} for the
         * given name.
         *
         * @throws `Error` if there is no handler under the given name.
         */
        unregister(name2) {
          const handler = this.#handlers.get(name2);
          if (!handler) {
            throw new Error(`Cannot unregister unknown handler: ${name2}`);
          }
          scriptInjector.pop(handler[0]);
          this.#handlers.delete(name2);
        }
        /**
         * Gets the names of all {@link CustomQueryHandler | custom query handlers}.
         */
        names() {
          return [...this.#handlers.keys()];
        }
        /**
         * Unregisters all custom query handlers.
         */
        clear() {
          for (const [registerScript] of this.#handlers) {
            scriptInjector.pop(registerScript);
          }
          this.#handlers.clear();
        }
      };
      customQueryHandlers = new CustomQueryHandlerRegistry();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js
  var PierceQueryHandler;
  var init_PierceQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_QueryHandler();
      PierceQueryHandler = class extends QueryHandler {
        static querySelector = (element, selector, { pierceQuerySelector }) => {
          return pierceQuerySelector(element, selector);
        };
        static querySelectorAll = (element, selector, { pierceQuerySelectorAll }) => {
          return pierceQuerySelectorAll(element, selector);
        };
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js
  var PQueryHandler;
  var init_PQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_QueryHandler();
      PQueryHandler = class extends QueryHandler {
        static querySelectorAll = (element, selector, { pQuerySelectorAll }) => {
          return pQuerySelectorAll(element, selector);
        };
        static querySelector = (element, selector, { pQuerySelector }) => {
          return pQuerySelector(element, selector);
        };
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js
  var TextQueryHandler;
  var init_TextQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_QueryHandler();
      TextQueryHandler = class extends QueryHandler {
        static querySelectorAll = (element, selector, { textQuerySelectorAll }) => {
          return textQuerySelectorAll(element, selector);
        };
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js
  var XPathQueryHandler;
  var init_XPathQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_QueryHandler();
      XPathQueryHandler = class extends QueryHandler {
        static querySelectorAll = (element, selector, { xpathQuerySelectorAll }) => {
          return xpathQuerySelectorAll(element, selector);
        };
        static querySelector = (element, selector, { xpathQuerySelectorAll }) => {
          for (const result of xpathQuerySelectorAll(element, selector, 1)) {
            return result;
          }
          return null;
        };
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js
  function getQueryHandlerAndSelector(selector) {
    for (const handlerMap of [
      customQueryHandlers.names().map((name2) => {
        return [name2, customQueryHandlers.get(name2)];
      }),
      Object.entries(BUILTIN_QUERY_HANDLERS)
    ]) {
      for (const [name2, QueryHandler2] of handlerMap) {
        for (const separator of QUERY_SEPARATORS) {
          const prefix = `${name2}${separator}`;
          if (selector.startsWith(prefix)) {
            selector = selector.slice(prefix.length);
            return { updatedSelector: selector, QueryHandler: QueryHandler2 };
          }
        }
      }
    }
    return { updatedSelector: selector, QueryHandler: PQueryHandler };
  }
  var BUILTIN_QUERY_HANDLERS, QUERY_SEPARATORS;
  var init_GetQueryHandler = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_AriaQueryHandler();
      init_CustomQueryHandler();
      init_PierceQueryHandler();
      init_PQueryHandler();
      init_TextQueryHandler();
      init_XPathQueryHandler();
      BUILTIN_QUERY_HANDLERS = {
        aria: ARIAQueryHandler,
        pierce: PierceQueryHandler,
        xpath: XPathQueryHandler,
        text: TextQueryHandler
      };
      QUERY_SEPARATORS = ["=", "/"];
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js
  var Mutex;
  var init_Mutex = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/Mutex.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Deferred();
      init_disposable();
      Mutex = class _Mutex {
        static Guard = class Guard {
          #mutex;
          constructor(mutex) {
            this.#mutex = mutex;
          }
          [disposeSymbol]() {
            return this.#mutex.release();
          }
        };
        #locked = false;
        #acquirers = [];
        // This is FIFO.
        async acquire() {
          if (!this.#locked) {
            this.#locked = true;
            return new _Mutex.Guard(this);
          }
          const deferred = Deferred.create();
          this.#acquirers.push(deferred.resolve.bind(deferred));
          await deferred.valueOrThrow();
          return new _Mutex.Guard(this);
        }
        release() {
          const resolve3 = this.#acquirers.shift();
          if (!resolve3) {
            this.#locked = false;
            return;
          }
          resolve3();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js
  function moveable(Class, _5) {
    let hasDispose = false;
    if (Class.prototype[disposeSymbol]) {
      const dispose = Class.prototype[disposeSymbol];
      Class.prototype[disposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return dispose.call(this);
      };
      hasDispose = true;
    }
    if (Class.prototype[asyncDisposeSymbol]) {
      const asyncDispose = Class.prototype[asyncDisposeSymbol];
      Class.prototype[asyncDisposeSymbol] = function() {
        if (instances.has(this)) {
          instances.delete(this);
          return;
        }
        return asyncDispose.call(this);
      };
      hasDispose = true;
    }
    if (hasDispose) {
      Class.prototype.move = function() {
        instances.add(this);
        return this;
      };
    }
    return Class;
  }
  function throwIfDisposed(message = (value) => {
    return `Attempted to use disposed ${value.constructor.name}.`;
  }) {
    return (target, _5) => {
      return function(...args) {
        if (this.disposed) {
          throw new Error(message(this));
        }
        return target.call(this, ...args);
      };
    };
  }
  function invokeAtMostOnceForArguments(target, _5) {
    const cache = /* @__PURE__ */ new WeakMap();
    let cacheDepth = -1;
    return function(...args) {
      if (cacheDepth === -1) {
        cacheDepth = args.length;
      }
      if (cacheDepth !== args.length) {
        throw new Error("Memoized method was called with the wrong number of arguments");
      }
      let freshArguments = false;
      let cacheIterator = cache;
      for (const arg of args) {
        if (cacheIterator.has(arg)) {
          cacheIterator = cacheIterator.get(arg);
        } else {
          freshArguments = true;
          cacheIterator.set(arg, /* @__PURE__ */ new WeakMap());
          cacheIterator = cacheIterator.get(arg);
        }
      }
      if (!freshArguments) {
        return;
      }
      return target.call(this, ...args);
    };
  }
  function guarded(getKey = function() {
    return this;
  }) {
    return (target, _5) => {
      const mutexes = /* @__PURE__ */ new WeakMap();
      return async function(...args) {
        const env_1 = { stack: [], error: void 0, hasError: false };
        try {
          const key = getKey.call(this);
          let mutex = mutexes.get(key);
          if (!mutex) {
            mutex = new Mutex();
            mutexes.set(key, mutex);
          }
          const _6 = __addDisposableResource3(env_1, await mutex.acquire(), true);
          return await target.call(this, ...args);
        } catch (e_1) {
          env_1.error = e_1;
          env_1.hasError = true;
        } finally {
          const result_1 = __disposeResources3(env_1);
          if (result_1)
            await result_1;
        }
      };
    };
  }
  var __addDisposableResource3, __disposeResources3, instances;
  var init_decorators = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/util/decorators.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_disposable();
      init_Mutex();
      __addDisposableResource3 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources3 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      instances = /* @__PURE__ */ new WeakSet();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js
  var __runInitializers, __esDecorate, __addDisposableResource4, __disposeResources4, JSHandle;
  var init_JSHandle = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/JSHandle.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_util2();
      init_decorators();
      init_disposable();
      __runInitializers = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __addDisposableResource4 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources4 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      JSHandle = (() => {
        let _classDecorators = [moveable];
        let _classDescriptor;
        let _classExtraInitializers = [];
        let _classThis;
        let _instanceExtraInitializers = [];
        let _getProperty_decorators;
        let _getProperties_decorators;
        var JSHandle2 = class {
          static {
            _classThis = this;
          }
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
            __esDecorate(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(null, _classDescriptor = { value: _classThis }, _classDecorators, { kind: "class", name: _classThis.name, metadata: _metadata }, null, _classExtraInitializers);
            JSHandle2 = _classThis = _classDescriptor.value;
            if (_metadata)
              Object.defineProperty(_classThis, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
            __runInitializers(_classThis, _classExtraInitializers);
          }
          /**
           * @internal
           */
          constructor() {
            __runInitializers(this, _instanceExtraInitializers);
          }
          /**
           * Evaluates the given function with the current handle as its first argument.
           */
          async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.realm.evaluate(pageFunction, this, ...args);
          }
          /**
           * Evaluates the given function with the current handle as its first argument.
           *
           */
          async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.realm.evaluateHandle(pageFunction, this, ...args);
          }
          /**
           * @internal
           */
          async getProperty(propertyName) {
            return await this.evaluateHandle((object, propertyName2) => {
              return object[propertyName2];
            }, propertyName);
          }
          /**
           * Gets a map of handles representing the properties of the current handle.
           *
           * @example
           *
           * ```ts
           * const listHandle = await page.evaluateHandle(() => document.body.children);
           * const properties = await listHandle.getProperties();
           * const children = [];
           * for (const property of properties.values()) {
           *   const element = property.asElement();
           *   if (element) {
           *     children.push(element);
           *   }
           * }
           * children; // holds elementHandles to all children of document.body
           * ```
           */
          async getProperties() {
            const propertyNames = await this.evaluate((object) => {
              const enumerableProperties = [];
              const descriptors = Object.getOwnPropertyDescriptors(object);
              for (const propertyName in descriptors) {
                if (descriptors[propertyName]?.enumerable) {
                  enumerableProperties.push(propertyName);
                }
              }
              return enumerableProperties;
            });
            const map = /* @__PURE__ */ new Map();
            const results = await Promise.all(propertyNames.map((key) => {
              return this.getProperty(key);
            }));
            for (const [key, value] of Object.entries(propertyNames)) {
              const env_1 = { stack: [], error: void 0, hasError: false };
              try {
                const handle = __addDisposableResource4(env_1, results[key], false);
                if (handle) {
                  map.set(value, handle.move());
                }
              } catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
              } finally {
                __disposeResources4(env_1);
              }
            }
            return map;
          }
          /** @internal */
          [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {
            return void this.dispose().catch(debugError);
          }
          /** @internal */
          [asyncDisposeSymbol]() {
            return this.dispose();
          }
        };
        return JSHandle2 = _classThis;
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js
  function intersectBoundingBox(box, width, height) {
    box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);
    box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);
  }
  var __runInitializers2, __esDecorate2, __addDisposableResource5, __disposeResources5, ElementHandle;
  var init_ElementHandle = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_GetQueryHandler();
      init_LazyArg();
      init_util2();
      init_assert();
      init_AsyncIterableUtil();
      init_decorators();
      init_ElementHandleSymbol();
      init_JSHandle();
      __runInitializers2 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __addDisposableResource5 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources5 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      ElementHandle = (() => {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r2, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _22, _32, _42, _5, _6, _7;
        let _classSuper = JSHandle;
        let _instanceExtraInitializers = [];
        let _getProperty_decorators;
        let _getProperties_decorators;
        let _jsonValue_decorators;
        let _$_decorators;
        let _$$_decorators;
        let _$x_decorators;
        let _waitForSelector_decorators;
        let _isVisible_decorators;
        let _isHidden_decorators;
        let _waitForXPath_decorators;
        let _toElement_decorators;
        let _clickablePoint_decorators;
        let _hover_decorators;
        let _click_decorators;
        let _drag_decorators;
        let _dragEnter_decorators;
        let _dragOver_decorators;
        let _drop_decorators;
        let _dragAndDrop_decorators;
        let _select_decorators;
        let _tap_decorators;
        let _touchStart_decorators;
        let _touchMove_decorators;
        let _touchEnd_decorators;
        let _focus_decorators;
        let _type_decorators;
        let _press_decorators;
        let _boundingBox_decorators;
        let _boxModel_decorators;
        let _screenshot_decorators;
        let _isIntersectingViewport_decorators;
        let _scrollIntoView_decorators;
        return class ElementHandle2 extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _getProperty_decorators = [throwIfDisposed(), (_a = ElementHandle2).bindIsolatedHandle.bind(_a)];
            _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle2).bindIsolatedHandle.bind(_b)];
            _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle2).bindIsolatedHandle.bind(_c)];
            _$_decorators = [throwIfDisposed(), (_d = ElementHandle2).bindIsolatedHandle.bind(_d)];
            _$$_decorators = [throwIfDisposed(), (_e2 = ElementHandle2).bindIsolatedHandle.bind(_e2)];
            _$x_decorators = [throwIfDisposed(), (_f = ElementHandle2).bindIsolatedHandle.bind(_f)];
            _waitForSelector_decorators = [throwIfDisposed(), (_g = ElementHandle2).bindIsolatedHandle.bind(_g)];
            _isVisible_decorators = [throwIfDisposed(), (_h = ElementHandle2).bindIsolatedHandle.bind(_h)];
            _isHidden_decorators = [throwIfDisposed(), (_j = ElementHandle2).bindIsolatedHandle.bind(_j)];
            _waitForXPath_decorators = [throwIfDisposed(), (_k = ElementHandle2).bindIsolatedHandle.bind(_k)];
            _toElement_decorators = [throwIfDisposed(), (_l = ElementHandle2).bindIsolatedHandle.bind(_l)];
            _clickablePoint_decorators = [throwIfDisposed(), (_m = ElementHandle2).bindIsolatedHandle.bind(_m)];
            _hover_decorators = [throwIfDisposed(), (_o = ElementHandle2).bindIsolatedHandle.bind(_o)];
            _click_decorators = [throwIfDisposed(), (_p = ElementHandle2).bindIsolatedHandle.bind(_p)];
            _drag_decorators = [throwIfDisposed(), (_q = ElementHandle2).bindIsolatedHandle.bind(_q)];
            _dragEnter_decorators = [throwIfDisposed(), (_r2 = ElementHandle2).bindIsolatedHandle.bind(_r2)];
            _dragOver_decorators = [throwIfDisposed(), (_s = ElementHandle2).bindIsolatedHandle.bind(_s)];
            _drop_decorators = [throwIfDisposed(), (_t = ElementHandle2).bindIsolatedHandle.bind(_t)];
            _dragAndDrop_decorators = [throwIfDisposed(), (_u = ElementHandle2).bindIsolatedHandle.bind(_u)];
            _select_decorators = [throwIfDisposed(), (_v = ElementHandle2).bindIsolatedHandle.bind(_v)];
            _tap_decorators = [throwIfDisposed(), (_w = ElementHandle2).bindIsolatedHandle.bind(_w)];
            _touchStart_decorators = [throwIfDisposed(), (_x = ElementHandle2).bindIsolatedHandle.bind(_x)];
            _touchMove_decorators = [throwIfDisposed(), (_y = ElementHandle2).bindIsolatedHandle.bind(_y)];
            _touchEnd_decorators = [throwIfDisposed(), (_z = ElementHandle2).bindIsolatedHandle.bind(_z)];
            _focus_decorators = [throwIfDisposed(), (_0 = ElementHandle2).bindIsolatedHandle.bind(_0)];
            _type_decorators = [throwIfDisposed(), (_1 = ElementHandle2).bindIsolatedHandle.bind(_1)];
            _press_decorators = [throwIfDisposed(), (_22 = ElementHandle2).bindIsolatedHandle.bind(_22)];
            _boundingBox_decorators = [throwIfDisposed(), (_32 = ElementHandle2).bindIsolatedHandle.bind(_32)];
            _boxModel_decorators = [throwIfDisposed(), (_42 = ElementHandle2).bindIsolatedHandle.bind(_42)];
            _screenshot_decorators = [throwIfDisposed(), (_5 = ElementHandle2).bindIsolatedHandle.bind(_5)];
            _isIntersectingViewport_decorators = [throwIfDisposed(), (_6 = ElementHandle2).bindIsolatedHandle.bind(_6)];
            _scrollIntoView_decorators = [throwIfDisposed(), (_7 = ElementHandle2).bindIsolatedHandle.bind(_7)];
            __esDecorate2(this, null, _getProperty_decorators, { kind: "method", name: "getProperty", static: false, private: false, access: { has: (obj) => "getProperty" in obj, get: (obj) => obj.getProperty }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _getProperties_decorators, { kind: "method", name: "getProperties", static: false, private: false, access: { has: (obj) => "getProperties" in obj, get: (obj) => obj.getProperties }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _jsonValue_decorators, { kind: "method", name: "jsonValue", static: false, private: false, access: { has: (obj) => "jsonValue" in obj, get: (obj) => obj.jsonValue }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _$x_decorators, { kind: "method", name: "$x", static: false, private: false, access: { has: (obj) => "$x" in obj, get: (obj) => obj.$x }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _isVisible_decorators, { kind: "method", name: "isVisible", static: false, private: false, access: { has: (obj) => "isVisible" in obj, get: (obj) => obj.isVisible }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _isHidden_decorators, { kind: "method", name: "isHidden", static: false, private: false, access: { has: (obj) => "isHidden" in obj, get: (obj) => obj.isHidden }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _waitForXPath_decorators, { kind: "method", name: "waitForXPath", static: false, private: false, access: { has: (obj) => "waitForXPath" in obj, get: (obj) => obj.waitForXPath }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _toElement_decorators, { kind: "method", name: "toElement", static: false, private: false, access: { has: (obj) => "toElement" in obj, get: (obj) => obj.toElement }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _clickablePoint_decorators, { kind: "method", name: "clickablePoint", static: false, private: false, access: { has: (obj) => "clickablePoint" in obj, get: (obj) => obj.clickablePoint }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _drag_decorators, { kind: "method", name: "drag", static: false, private: false, access: { has: (obj) => "drag" in obj, get: (obj) => obj.drag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _dragEnter_decorators, { kind: "method", name: "dragEnter", static: false, private: false, access: { has: (obj) => "dragEnter" in obj, get: (obj) => obj.dragEnter }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _dragOver_decorators, { kind: "method", name: "dragOver", static: false, private: false, access: { has: (obj) => "dragOver" in obj, get: (obj) => obj.dragOver }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _drop_decorators, { kind: "method", name: "drop", static: false, private: false, access: { has: (obj) => "drop" in obj, get: (obj) => obj.drop }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _dragAndDrop_decorators, { kind: "method", name: "dragAndDrop", static: false, private: false, access: { has: (obj) => "dragAndDrop" in obj, get: (obj) => obj.dragAndDrop }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _touchStart_decorators, { kind: "method", name: "touchStart", static: false, private: false, access: { has: (obj) => "touchStart" in obj, get: (obj) => obj.touchStart }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _touchMove_decorators, { kind: "method", name: "touchMove", static: false, private: false, access: { has: (obj) => "touchMove" in obj, get: (obj) => obj.touchMove }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _touchEnd_decorators, { kind: "method", name: "touchEnd", static: false, private: false, access: { has: (obj) => "touchEnd" in obj, get: (obj) => obj.touchEnd }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _press_decorators, { kind: "method", name: "press", static: false, private: false, access: { has: (obj) => "press" in obj, get: (obj) => obj.press }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _boundingBox_decorators, { kind: "method", name: "boundingBox", static: false, private: false, access: { has: (obj) => "boundingBox" in obj, get: (obj) => obj.boundingBox }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _boxModel_decorators, { kind: "method", name: "boxModel", static: false, private: false, access: { has: (obj) => "boxModel" in obj, get: (obj) => obj.boxModel }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _isIntersectingViewport_decorators, { kind: "method", name: "isIntersectingViewport", static: false, private: false, access: { has: (obj) => "isIntersectingViewport" in obj, get: (obj) => obj.isIntersectingViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate2(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          /**
           * A given method will have it's `this` replaced with an isolated version of
           * `this` when decorated with this decorator.
           *
           * All changes of isolated `this` are reflected on the actual `this`.
           *
           * @internal
           */
          static bindIsolatedHandle(target, _8) {
            return async function(...args) {
              const env_1 = { stack: [], error: void 0, hasError: false };
              try {
                if (this.realm === this.frame.isolatedRealm()) {
                  return await target.call(this, ...args);
                }
                const adoptedThis = __addDisposableResource5(env_1, await this.frame.isolatedRealm().adoptHandle(this), false);
                const result = await target.call(adoptedThis, ...args);
                if (result === adoptedThis) {
                  return this;
                }
                if (result instanceof JSHandle) {
                  return await this.realm.transferHandle(result);
                }
                if (Array.isArray(result)) {
                  await Promise.all(result.map(async (item, index, result2) => {
                    if (item instanceof JSHandle) {
                      result2[index] = await this.realm.transferHandle(item);
                    }
                  }));
                }
                if (result instanceof Map) {
                  await Promise.all([...result.entries()].map(async ([key, value]) => {
                    if (value instanceof JSHandle) {
                      result.set(key, await this.realm.transferHandle(value));
                    }
                  }));
                }
                return result;
              } catch (e_1) {
                env_1.error = e_1;
                env_1.hasError = true;
              } finally {
                __disposeResources5(env_1);
              }
            };
          }
          /**
           * @internal
           */
          handle = (__runInitializers2(this, _instanceExtraInitializers), void 0);
          /**
           * @internal
           */
          constructor(handle) {
            super();
            this.handle = handle;
            this[_isElementHandle] = true;
          }
          /**
           * @internal
           */
          get id() {
            return this.handle.id;
          }
          /**
           * @internal
           */
          get disposed() {
            return this.handle.disposed;
          }
          /**
           * @internal
           */
          async getProperty(propertyName) {
            return await this.handle.getProperty(propertyName);
          }
          /**
           * @internal
           */
          async getProperties() {
            return await this.handle.getProperties();
          }
          /**
           * @internal
           */
          async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.handle.evaluate(pageFunction, ...args);
          }
          /**
           * @internal
           */
          async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.handle.evaluateHandle(pageFunction, ...args);
          }
          /**
           * @internal
           */
          async jsonValue() {
            return await this.handle.jsonValue();
          }
          /**
           * @internal
           */
          toString() {
            return this.handle.toString();
          }
          /**
           * @internal
           */
          remoteObject() {
            return this.handle.remoteObject();
          }
          /**
           * @internal
           */
          dispose() {
            return this.handle.dispose();
          }
          /**
           * @internal
           */
          asElement() {
            return this;
          }
          /**
           * Queries the current element for an element matching the given selector.
           *
           * @param selector - The selector to query for.
           * @returns A {@link ElementHandle | element handle} to the first element
           * matching the given selector. Otherwise, `null`.
           */
          async $(selector) {
            const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
            return await QueryHandler2.queryOne(this, updatedSelector);
          }
          /**
           * Queries the current element for all elements matching the given selector.
           *
           * @param selector - The selector to query for.
           * @returns An array of {@link ElementHandle | element handles} that point to
           * elements matching the given selector.
           */
          async $$(selector) {
            const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
            return await AsyncIterableUtil.collect(QueryHandler2.queryAll(this, updatedSelector));
          }
          /**
           * Runs the given function on the first element matching the given selector in
           * the current element.
           *
           * If the given function returns a promise, then this method will wait till
           * the promise resolves.
           *
           * @example
           *
           * ```ts
           * const tweetHandle = await page.$('.tweet');
           * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(
           *   '100'
           * );
           * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(
           *   '10'
           * );
           * ```
           *
           * @param selector - The selector to query for.
           * @param pageFunction - The function to be evaluated in this element's page's
           * context. The first element matching the selector will be passed in as the
           * first argument.
           * @param args - Additional arguments to pass to `pageFunction`.
           * @returns A promise to the result of the function.
           */
          async $eval(selector, pageFunction, ...args) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
              pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
              const elementHandle = __addDisposableResource5(env_2, await this.$(selector), false);
              if (!elementHandle) {
                throw new Error(`Error: failed to find element matching selector "${selector}"`);
              }
              return await elementHandle.evaluate(pageFunction, ...args);
            } catch (e_2) {
              env_2.error = e_2;
              env_2.hasError = true;
            } finally {
              __disposeResources5(env_2);
            }
          }
          /**
           * Runs the given function on an array of elements matching the given selector
           * in the current element.
           *
           * If the given function returns a promise, then this method will wait till
           * the promise resolves.
           *
           * @example
           * HTML:
           *
           * ```html
           * <div class="feed">
           *   <div class="tweet">Hello!</div>
           *   <div class="tweet">Hi!</div>
           * </div>
           * ```
           *
           * JavaScript:
           *
           * ```ts
           * const feedHandle = await page.$('.feed');
           * expect(
           *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))
           * ).toEqual(['Hello!', 'Hi!']);
           * ```
           *
           * @param selector - The selector to query for.
           * @param pageFunction - The function to be evaluated in the element's page's
           * context. An array of elements matching the given selector will be passed to
           * the function as its first argument.
           * @param args - Additional arguments to pass to `pageFunction`.
           * @returns A promise to the result of the function.
           */
          async $$eval(selector, pageFunction, ...args) {
            const env_3 = { stack: [], error: void 0, hasError: false };
            try {
              pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
              const results = await this.$$(selector);
              const elements = __addDisposableResource5(env_3, await this.evaluateHandle((_8, ...elements2) => {
                return elements2;
              }, ...results), false);
              const [result] = await Promise.all([
                elements.evaluate(pageFunction, ...args),
                ...results.map((results2) => {
                  return results2.dispose();
                })
              ]);
              return result;
            } catch (e_3) {
              env_3.error = e_3;
              env_3.hasError = true;
            } finally {
              __disposeResources5(env_3);
            }
          }
          /**
           * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.
           *
           * Example: `await elementHandle.$$('xpath/' + xpathExpression)`
           *
           * The method evaluates the XPath expression relative to the elementHandle.
           * If `xpath` starts with `//` instead of `.//`, the dot will be appended
           * automatically.
           *
           * If there are no such elements, the method will resolve to an empty array.
           * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}
           */
          async $x(expression) {
            if (expression.startsWith("//")) {
              expression = `.${expression}`;
            }
            return await this.$$(`xpath/${expression}`);
          }
          /**
           * Wait for an element matching the given selector to appear in the current
           * element.
           *
           * Unlike {@link Frame.waitForSelector}, this method does not work across
           * navigations or if the element is detached from DOM.
           *
           * @example
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           *
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   let currentURL;
           *   page
           *     .mainFrame()
           *     .waitForSelector('img')
           *     .then(() => console.log('First URL with image: ' + currentURL));
           *
           *   for (currentURL of [
           *     'https://example.com',
           *     'https://google.com',
           *     'https://bbc.com',
           *   ]) {
           *     await page.goto(currentURL);
           *   }
           *   await browser.close();
           * })();
           * ```
           *
           * @param selector - The selector to query and wait for.
           * @param options - Options for customizing waiting behavior.
           * @returns An element matching the given selector.
           * @throws Throws if an element matching the given selector doesn't appear.
           */
          async waitForSelector(selector, options = {}) {
            const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
            return await QueryHandler2.waitFor(this, updatedSelector, options);
          }
          async #checkVisibility(visibility) {
            return await this.evaluate(async (element, PuppeteerUtil, visibility2) => {
              return Boolean(PuppeteerUtil.checkVisibility(element, visibility2));
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), visibility);
          }
          /**
           * Checks if an element is visible using the same mechanism as
           * {@link ElementHandle.waitForSelector}.
           */
          async isVisible() {
            return await this.#checkVisibility(true);
          }
          /**
           * Checks if an element is hidden using the same mechanism as
           * {@link ElementHandle.waitForSelector}.
           */
          async isHidden() {
            return await this.#checkVisibility(false);
          }
          /**
           * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`
           * prefix.
           *
           * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`
           *
           * The method evaluates the XPath expression relative to the elementHandle.
           *
           * Wait for the `xpath` within the element. If at the moment of calling the
           * method the `xpath` already exists, the method will return immediately. If
           * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the
           * function will throw.
           *
           * If `xpath` starts with `//` instead of `.//`, the dot will be appended
           * automatically.
           *
           * @example
           * This method works across navigation.
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   let currentURL;
           *   page
           *     .waitForXPath('//img')
           *     .then(() => console.log('First URL with image: ' + currentURL));
           *   for (currentURL of [
           *     'https://example.com',
           *     'https://google.com',
           *     'https://bbc.com',
           *   ]) {
           *     await page.goto(currentURL);
           *   }
           *   await browser.close();
           * })();
           * ```
           *
           * @param xpath - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an
           * element to wait for
           * @param options - Optional waiting parameters
           * @returns Promise which resolves when element specified by xpath string is
           * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is
           * not found in DOM, otherwise resolves to `ElementHandle`.
           * @remarks
           * The optional Argument `options` have properties:
           *
           * - `visible`: A boolean to wait for element to be present in DOM and to be
           *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
           *   properties. Defaults to `false`.
           *
           * - `hidden`: A boolean wait for element to not be found in the DOM or to be
           *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
           *   Defaults to `false`.
           *
           * - `timeout`: A number which is maximum time to wait for in milliseconds.
           *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The
           *   default value can be changed by using the {@link Page.setDefaultTimeout}
           *   method.
           */
          async waitForXPath(xpath, options = {}) {
            if (xpath.startsWith("//")) {
              xpath = `.${xpath}`;
            }
            return await this.waitForSelector(`xpath/${xpath}`, options);
          }
          /**
           * Converts the current handle to the given element type.
           *
           * @example
           *
           * ```ts
           * const element: ElementHandle<Element> = await page.$(
           *   '.class-name-of-anchor'
           * );
           * // DO NOT DISPOSE `element`, this will be always be the same handle.
           * const anchor: ElementHandle<HTMLAnchorElement> =
           *   await element.toElement('a');
           * ```
           *
           * @param tagName - The tag name of the desired element type.
           * @throws An error if the handle does not match. **The handle will not be
           * automatically disposed.**
           */
          async toElement(tagName) {
            const isMatchingTagName = await this.evaluate((node, tagName2) => {
              return node.nodeName === tagName2.toUpperCase();
            }, tagName);
            if (!isMatchingTagName) {
              throw new Error(`Element is not a(n) \`${tagName}\` element`);
            }
            return this;
          }
          /**
           * Returns the middle point within an element unless a specific offset is provided.
           */
          async clickablePoint(offset) {
            const box = await this.#clickableBox();
            if (!box) {
              throw new Error("Node is either not clickable or not an Element");
            }
            if (offset !== void 0) {
              return {
                x: box.x + offset.x,
                y: box.y + offset.y
              };
            }
            return {
              x: box.x + box.width / 2,
              y: box.y + box.height / 2
            };
          }
          /**
           * This method scrolls element into view if needed, and then
           * uses {@link Page} to hover over the center of the element.
           * If the element is detached from DOM, the method throws an error.
           */
          async hover() {
            await this.scrollIntoViewIfNeeded();
            const { x: x4, y: y6 } = await this.clickablePoint();
            await this.frame.page().mouse.move(x4, y6);
          }
          /**
           * This method scrolls element into view if needed, and then
           * uses {@link Page | Page.mouse} to click in the center of the element.
           * If the element is detached from DOM, the method throws an error.
           */
          async click(options = {}) {
            await this.scrollIntoViewIfNeeded();
            const { x: x4, y: y6 } = await this.clickablePoint(options.offset);
            await this.frame.page().mouse.click(x4, y6, options);
          }
          /**
           * Drags an element over the given element or point.
           *
           * @returns DEPRECATED. When drag interception is enabled, the drag payload is
           * returned.
           */
          async drag(target) {
            await this.scrollIntoViewIfNeeded();
            const page = this.frame.page();
            if (page.isDragInterceptionEnabled()) {
              const source2 = await this.clickablePoint();
              if (target instanceof ElementHandle2) {
                target = await target.clickablePoint();
              }
              return await page.mouse.drag(source2, target);
            }
            try {
              if (!page._isDragging) {
                page._isDragging = true;
                await this.hover();
                await page.mouse.down();
              }
              if (target instanceof ElementHandle2) {
                await target.hover();
              } else {
                await page.mouse.move(target.x, target.y);
              }
            } catch (error) {
              page._isDragging = false;
              throw error;
            }
          }
          /**
           * @deprecated Do not use. `dragenter` will automatically be performed during dragging.
           */
          async dragEnter(data = { items: [], dragOperationsMask: 1 }) {
            const page = this.frame.page();
            await this.scrollIntoViewIfNeeded();
            const target = await this.clickablePoint();
            await page.mouse.dragEnter(target, data);
          }
          /**
           * @deprecated Do not use. `dragover` will automatically be performed during dragging.
           */
          async dragOver(data = { items: [], dragOperationsMask: 1 }) {
            const page = this.frame.page();
            await this.scrollIntoViewIfNeeded();
            const target = await this.clickablePoint();
            await page.mouse.dragOver(target, data);
          }
          /**
           * @internal
           */
          async drop(dataOrElement = {
            items: [],
            dragOperationsMask: 1
          }) {
            const page = this.frame.page();
            if ("items" in dataOrElement) {
              await this.scrollIntoViewIfNeeded();
              const destination = await this.clickablePoint();
              await page.mouse.drop(destination, dataOrElement);
            } else {
              await dataOrElement.drag(this);
              page._isDragging = false;
              await page.mouse.up();
            }
          }
          /**
           * @deprecated Use `ElementHandle.drop` instead.
           */
          async dragAndDrop(target, options) {
            const page = this.frame.page();
            assert2(page.isDragInterceptionEnabled(), "Drag Interception is not enabled!");
            await this.scrollIntoViewIfNeeded();
            const startPoint = await this.clickablePoint();
            const targetPoint = await target.clickablePoint();
            await page.mouse.dragAndDrop(startPoint, targetPoint, options);
          }
          /**
           * Triggers a `change` and `input` event once all the provided options have been
           * selected. If there's no `<select>` element matching `selector`, the method
           * throws an error.
           *
           * @example
           *
           * ```ts
           * handle.select('blue'); // single selection
           * handle.select('red', 'green', 'blue'); // multiple selections
           * ```
           *
           * @param values - Values of options to select. If the `<select>` has the
           * `multiple` attribute, all values are considered, otherwise only the first
           * one is taken into account.
           */
          async select(...values) {
            for (const value of values) {
              assert2(isString3(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
            }
            return await this.evaluate((element, vals) => {
              const values2 = new Set(vals);
              if (!(element instanceof HTMLSelectElement)) {
                throw new Error("Element is not a <select> element.");
              }
              const selectedValues = /* @__PURE__ */ new Set();
              if (!element.multiple) {
                for (const option of element.options) {
                  option.selected = false;
                }
                for (const option of element.options) {
                  if (values2.has(option.value)) {
                    option.selected = true;
                    selectedValues.add(option.value);
                    break;
                  }
                }
              } else {
                for (const option of element.options) {
                  option.selected = values2.has(option.value);
                  if (option.selected) {
                    selectedValues.add(option.value);
                  }
                }
              }
              element.dispatchEvent(new Event("input", { bubbles: true }));
              element.dispatchEvent(new Event("change", { bubbles: true }));
              return [...selectedValues.values()];
            }, values);
          }
          /**
           * This method scrolls element into view if needed, and then uses
           * {@link Touchscreen.tap} to tap in the center of the element.
           * If the element is detached from DOM, the method throws an error.
           */
          async tap() {
            await this.scrollIntoViewIfNeeded();
            const { x: x4, y: y6 } = await this.clickablePoint();
            await this.frame.page().touchscreen.tap(x4, y6);
          }
          async touchStart() {
            await this.scrollIntoViewIfNeeded();
            const { x: x4, y: y6 } = await this.clickablePoint();
            await this.frame.page().touchscreen.touchStart(x4, y6);
          }
          async touchMove() {
            await this.scrollIntoViewIfNeeded();
            const { x: x4, y: y6 } = await this.clickablePoint();
            await this.frame.page().touchscreen.touchMove(x4, y6);
          }
          async touchEnd() {
            await this.scrollIntoViewIfNeeded();
            await this.frame.page().touchscreen.touchEnd();
          }
          /**
           * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.
           */
          async focus() {
            await this.evaluate((element) => {
              if (!(element instanceof HTMLElement)) {
                throw new Error("Cannot focus non-HTMLElement");
              }
              return element.focus();
            });
          }
          /**
           * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and
           * `keyup` event for each character in the text.
           *
           * To press a special key, like `Control` or `ArrowDown`,
           * use {@link ElementHandle.press}.
           *
           * @example
           *
           * ```ts
           * await elementHandle.type('Hello'); // Types instantly
           * await elementHandle.type('World', {delay: 100}); // Types slower, like a user
           * ```
           *
           * @example
           * An example of typing into a text field and then submitting the form:
           *
           * ```ts
           * const elementHandle = await page.$('input');
           * await elementHandle.type('some text');
           * await elementHandle.press('Enter');
           * ```
           *
           * @param options - Delay in milliseconds. Defaults to 0.
           */
          async type(text, options) {
            await this.focus();
            await this.frame.page().keyboard.type(text, options);
          }
          /**
           * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.
           *
           * @remarks
           * If `key` is a single character and no modifier keys besides `Shift`
           * are being held down, a `keypress`/`input` event will also be generated.
           * The `text` option can be specified to force an input event to be generated.
           *
           * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`
           * will type the text in upper case.
           *
           * @param key - Name of key to press, such as `ArrowLeft`.
           * See {@link KeyInput} for a list of all key names.
           */
          async press(key, options) {
            await this.focus();
            await this.frame.page().keyboard.press(key, options);
          }
          async #clickableBox() {
            const boxes = await this.evaluate((element) => {
              if (!(element instanceof Element)) {
                return null;
              }
              return [...element.getClientRects()].map((rect) => {
                return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
              });
            });
            if (!boxes?.length) {
              return null;
            }
            await this.#intersectBoundingBoxesWithFrame(boxes);
            let frame = this.frame;
            let parentFrame;
            while (parentFrame = frame?.parentFrame()) {
              const env_4 = { stack: [], error: void 0, hasError: false };
              try {
                const handle = __addDisposableResource5(env_4, await frame.frameElement(), false);
                if (!handle) {
                  throw new Error("Unsupported frame type");
                }
                const parentBox = await handle.evaluate((element) => {
                  if (element.getClientRects().length === 0) {
                    return null;
                  }
                  const rect = element.getBoundingClientRect();
                  const style = window.getComputedStyle(element);
                  return {
                    left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                    top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
                  };
                });
                if (!parentBox) {
                  return null;
                }
                for (const box2 of boxes) {
                  box2.x += parentBox.left;
                  box2.y += parentBox.top;
                }
                await handle.#intersectBoundingBoxesWithFrame(boxes);
                frame = parentFrame;
              } catch (e_4) {
                env_4.error = e_4;
                env_4.hasError = true;
              } finally {
                __disposeResources5(env_4);
              }
            }
            const box = boxes.find((box2) => {
              return box2.width >= 1 && box2.height >= 1;
            });
            if (!box) {
              return null;
            }
            return {
              x: box.x,
              y: box.y,
              height: box.height,
              width: box.width
            };
          }
          async #intersectBoundingBoxesWithFrame(boxes) {
            const { documentWidth, documentHeight } = await this.frame.isolatedRealm().evaluate(() => {
              return {
                documentWidth: document.documentElement.clientWidth,
                documentHeight: document.documentElement.clientHeight
              };
            });
            for (const box of boxes) {
              intersectBoundingBox(box, documentWidth, documentHeight);
            }
          }
          /**
           * This method returns the bounding box of the element (relative to the main frame),
           * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
           * (example: `display: none`).
           */
          async boundingBox() {
            const box = await this.evaluate((element) => {
              if (!(element instanceof Element)) {
                return null;
              }
              if (element.getClientRects().length === 0) {
                return null;
              }
              const rect = element.getBoundingClientRect();
              return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
            });
            if (!box) {
              return null;
            }
            const offset = await this.#getTopLeftCornerOfFrame();
            if (!offset) {
              return null;
            }
            return {
              x: box.x + offset.x,
              y: box.y + offset.y,
              height: box.height,
              width: box.width
            };
          }
          /**
           * This method returns boxes of the element,
           * or `null` if the element is {@link https://drafts.csswg.org/css-display-4/#box-generation | not part of the layout}
           * (example: `display: none`).
           *
           * @remarks
           *
           * Boxes are represented as an array of points;
           * Each Point is an object `{x, y}`. Box points are sorted clock-wise.
           */
          async boxModel() {
            const model = await this.evaluate((element) => {
              if (!(element instanceof Element)) {
                return null;
              }
              if (element.getClientRects().length === 0) {
                return null;
              }
              const rect = element.getBoundingClientRect();
              const style = window.getComputedStyle(element);
              const offsets = {
                padding: {
                  left: parseInt(style.paddingLeft, 10),
                  top: parseInt(style.paddingTop, 10),
                  right: parseInt(style.paddingRight, 10),
                  bottom: parseInt(style.paddingBottom, 10)
                },
                margin: {
                  left: -parseInt(style.marginLeft, 10),
                  top: -parseInt(style.marginTop, 10),
                  right: -parseInt(style.marginRight, 10),
                  bottom: -parseInt(style.marginBottom, 10)
                },
                border: {
                  left: parseInt(style.borderLeft, 10),
                  top: parseInt(style.borderTop, 10),
                  right: parseInt(style.borderRight, 10),
                  bottom: parseInt(style.borderBottom, 10)
                }
              };
              const border = [
                { x: rect.left, y: rect.top },
                { x: rect.left + rect.width, y: rect.top },
                { x: rect.left + rect.width, y: rect.top + rect.bottom },
                { x: rect.left, y: rect.top + rect.bottom }
              ];
              const padding = transformQuadWithOffsets(border, offsets.border);
              const content = transformQuadWithOffsets(padding, offsets.padding);
              const margin = transformQuadWithOffsets(border, offsets.margin);
              return {
                content,
                padding,
                border,
                margin,
                width: rect.width,
                height: rect.height
              };
              function transformQuadWithOffsets(quad, offsets2) {
                return [
                  {
                    x: quad[0].x + offsets2.left,
                    y: quad[0].y + offsets2.top
                  },
                  {
                    x: quad[1].x - offsets2.right,
                    y: quad[1].y + offsets2.top
                  },
                  {
                    x: quad[2].x - offsets2.right,
                    y: quad[2].y - offsets2.bottom
                  },
                  {
                    x: quad[3].x + offsets2.left,
                    y: quad[3].y - offsets2.bottom
                  }
                ];
              }
            });
            if (!model) {
              return null;
            }
            const offset = await this.#getTopLeftCornerOfFrame();
            if (!offset) {
              return null;
            }
            for (const attribute of [
              "content",
              "padding",
              "border",
              "margin"
            ]) {
              for (const point of model[attribute]) {
                point.x += offset.x;
                point.y += offset.y;
              }
            }
            return model;
          }
          async #getTopLeftCornerOfFrame() {
            const point = { x: 0, y: 0 };
            let frame = this.frame;
            let parentFrame;
            while (parentFrame = frame?.parentFrame()) {
              const env_5 = { stack: [], error: void 0, hasError: false };
              try {
                const handle = __addDisposableResource5(env_5, await frame.frameElement(), false);
                if (!handle) {
                  throw new Error("Unsupported frame type");
                }
                const parentBox = await handle.evaluate((element) => {
                  if (element.getClientRects().length === 0) {
                    return null;
                  }
                  const rect = element.getBoundingClientRect();
                  const style = window.getComputedStyle(element);
                  return {
                    left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),
                    top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)
                  };
                });
                if (!parentBox) {
                  return null;
                }
                point.x += parentBox.left;
                point.y += parentBox.top;
                frame = parentFrame;
              } catch (e_5) {
                env_5.error = e_5;
                env_5.hasError = true;
              } finally {
                __disposeResources5(env_5);
              }
            }
            return point;
          }
          async screenshot(options = {}) {
            const { scrollIntoView = true } = options;
            let clip = await this.#nonEmptyVisibleBoundingBox();
            const page = this.frame.page();
            if (scrollIntoView) {
              await this.scrollIntoViewIfNeeded();
              clip = await this.#nonEmptyVisibleBoundingBox();
            }
            const [pageLeft, pageTop] = await this.evaluate(() => {
              if (!window.visualViewport) {
                throw new Error("window.visualViewport is not supported.");
              }
              return [
                window.visualViewport.pageLeft,
                window.visualViewport.pageTop
              ];
            });
            clip.x += pageLeft;
            clip.y += pageTop;
            return await page.screenshot({ ...options, clip });
          }
          async #nonEmptyVisibleBoundingBox() {
            const box = await this.boundingBox();
            assert2(box, "Node is either not visible or not an HTMLElement");
            assert2(box.width !== 0, "Node has 0 width.");
            assert2(box.height !== 0, "Node has 0 height.");
            return box;
          }
          /**
           * @internal
           */
          async assertConnectedElement() {
            const error = await this.evaluate(async (element) => {
              if (!element.isConnected) {
                return "Node is detached from document";
              }
              if (element.nodeType !== Node.ELEMENT_NODE) {
                return "Node is not of type HTMLElement";
              }
              return;
            });
            if (error) {
              throw new Error(error);
            }
          }
          /**
           * @internal
           */
          async scrollIntoViewIfNeeded() {
            if (await this.isIntersectingViewport({
              threshold: 1
            })) {
              return;
            }
            await this.scrollIntoView();
          }
          /**
           * Resolves to true if the element is visible in the current viewport. If an
           * element is an SVG, we check if the svg owner element is in the viewport
           * instead. See https://crbug.com/963246.
           *
           * @param options - Threshold for the intersection between 0 (no intersection) and 1
           * (full intersection). Defaults to 1.
           */
          async isIntersectingViewport(options = {}) {
            const env_6 = { stack: [], error: void 0, hasError: false };
            try {
              await this.assertConnectedElement();
              const handle = await this.#asSVGElementHandle();
              const target = __addDisposableResource5(env_6, handle && await handle.#getOwnerSVGElement(), false);
              return await (target ?? this).evaluate(async (element, threshold) => {
                const visibleRatio = await new Promise((resolve3) => {
                  const observer = new IntersectionObserver((entries) => {
                    resolve3(entries[0].intersectionRatio);
                    observer.disconnect();
                  });
                  observer.observe(element);
                });
                return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;
              }, options.threshold ?? 0);
            } catch (e_6) {
              env_6.error = e_6;
              env_6.hasError = true;
            } finally {
              __disposeResources5(env_6);
            }
          }
          /**
           * Scrolls the element into view using either the automation protocol client
           * or by calling element.scrollIntoView.
           */
          async scrollIntoView() {
            await this.assertConnectedElement();
            await this.evaluate(async (element) => {
              element.scrollIntoView({
                block: "center",
                inline: "center",
                behavior: "instant"
              });
            });
          }
          /**
           * Returns true if an element is an SVGElement (included svg, path, rect
           * etc.).
           */
          async #asSVGElementHandle() {
            if (await this.evaluate((element) => {
              return element instanceof SVGElement;
            })) {
              return this;
            } else {
              return null;
            }
          }
          async #getOwnerSVGElement() {
            return await this.evaluateHandle((element) => {
              if (element instanceof SVGSVGElement) {
                return element;
              }
              return element.ownerSVGElement;
            });
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js
  async function releaseReference(client, remoteReference) {
    if (!remoteReference.handle) {
      return;
    }
    await client.connection.send("script.disown", {
      target: client.target,
      handles: [remoteReference.handle]
    }).catch((error) => {
      debugError(error);
    });
  }
  function createEvaluationError2(details) {
    if (details.exception.type !== "error") {
      return BidiDeserializer.deserialize(details.exception);
    }
    const [name2 = "", ...parts] = details.text.split(": ");
    const message = parts.join(": ");
    const error = new Error(message);
    error.name = name2;
    const stackLines = [];
    if (details.stackTrace && stackLines.length < Error.stackTraceLimit) {
      for (const frame of details.stackTrace.callFrames.reverse()) {
        if (PuppeteerURL.isPuppeteerURL(frame.url) && frame.url !== PuppeteerURL.INTERNAL_URL) {
          const url = PuppeteerURL.parse(frame.url);
          stackLines.unshift(`    at ${frame.functionName || url.functionName} (${url.functionName} at ${url.siteString}, <anonymous>:${frame.lineNumber}:${frame.columnNumber})`);
        } else {
          stackLines.push(`    at ${frame.functionName || "<anonymous>"} (${frame.url}:${frame.lineNumber}:${frame.columnNumber})`);
        }
        if (stackLines.length >= Error.stackTraceLimit) {
          break;
        }
      }
    }
    error.stack = [details.text, ...stackLines].join("\n");
    return error;
  }
  var init_util3 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/util.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_util2();
      init_Deserializer();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js
  var BidiJSHandle;
  var init_JSHandle2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_JSHandle();
      init_Errors();
      init_Deserializer();
      init_util3();
      BidiJSHandle = class extends JSHandle {
        #disposed = false;
        #sandbox;
        #remoteValue;
        constructor(sandbox, remoteValue) {
          super();
          this.#sandbox = sandbox;
          this.#remoteValue = remoteValue;
        }
        context() {
          return this.realm.environment.context();
        }
        get realm() {
          return this.#sandbox;
        }
        get disposed() {
          return this.#disposed;
        }
        async jsonValue() {
          return await this.evaluate((value) => {
            return value;
          });
        }
        asElement() {
          return null;
        }
        async dispose() {
          if (this.#disposed) {
            return;
          }
          this.#disposed = true;
          if ("handle" in this.#remoteValue) {
            await releaseReference(this.context(), this.#remoteValue);
          }
        }
        get isPrimitiveValue() {
          switch (this.#remoteValue.type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean":
            case "undefined":
            case "null":
              return true;
            default:
              return false;
          }
        }
        toString() {
          if (this.isPrimitiveValue) {
            return "JSHandle:" + BidiDeserializer.deserialize(this.#remoteValue);
          }
          return "JSHandle@" + this.#remoteValue.type;
        }
        get id() {
          return "handle" in this.#remoteValue ? this.#remoteValue.handle : void 0;
        }
        remoteValue() {
          return this.#remoteValue;
        }
        remoteObject() {
          throw new UnsupportedOperation("Not available in WebDriver BiDi");
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js
  var __runInitializers3, __esDecorate3, __addDisposableResource6, __disposeResources6, BidiElementHandle;
  var init_ElementHandle2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_ElementHandle();
      init_Errors();
      init_decorators();
      init_JSHandle2();
      __runInitializers3 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate3 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __addDisposableResource6 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources6 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      BidiElementHandle = (() => {
        var _a;
        let _classSuper = ElementHandle;
        let _instanceExtraInitializers = [];
        let _autofill_decorators;
        let _contentFrame_decorators;
        return class BidiElementHandle extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _autofill_decorators = [throwIfDisposed()];
            _contentFrame_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];
            __esDecorate3(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate3(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          constructor(sandbox, remoteValue) {
            super(new BidiJSHandle(sandbox, remoteValue));
            __runInitializers3(this, _instanceExtraInitializers);
          }
          get realm() {
            return this.handle.realm;
          }
          get frame() {
            return this.realm.environment;
          }
          context() {
            return this.handle.context();
          }
          get isPrimitiveValue() {
            return this.handle.isPrimitiveValue;
          }
          remoteValue() {
            return this.handle.remoteValue();
          }
          async autofill(data) {
            const client = this.frame.client;
            const nodeInfo = await client.send("DOM.describeNode", {
              objectId: this.handle.id
            });
            const fieldId = nodeInfo.node.backendNodeId;
            const frameId = this.frame._id;
            await client.send("Autofill.trigger", {
              fieldId,
              frameId,
              card: data.creditCard
            });
          }
          async contentFrame() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource6(env_1, await this.evaluateHandle((element) => {
                if (element instanceof HTMLIFrameElement) {
                  return element.contentWindow;
                }
                return;
              }), false);
              const value = handle.remoteValue();
              if (value.type === "window") {
                return this.frame.page().frame(value.value.context);
              }
              return null;
            } catch (e_1) {
              env_1.error = e_1;
              env_1.hasError = true;
            } finally {
              __disposeResources6(env_1);
            }
          }
          uploadFile() {
            throw new UnsupportedOperation();
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js
  var UnserializableError, BidiSerializer;
  var init_Serializer = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_LazyArg();
      init_util2();
      init_ElementHandle2();
      init_JSHandle2();
      UnserializableError = class extends Error {
      };
      BidiSerializer = class _BidiSerializer {
        static serializeNumber(arg) {
          let value;
          if (Object.is(arg, -0)) {
            value = "-0";
          } else if (Object.is(arg, Infinity)) {
            value = "Infinity";
          } else if (Object.is(arg, -Infinity)) {
            value = "-Infinity";
          } else if (Object.is(arg, NaN)) {
            value = "NaN";
          } else {
            value = arg;
          }
          return {
            type: "number",
            value
          };
        }
        static serializeObject(arg) {
          if (arg === null) {
            return {
              type: "null"
            };
          } else if (Array.isArray(arg)) {
            const parsedArray = arg.map((subArg) => {
              return _BidiSerializer.serializeRemoteValue(subArg);
            });
            return {
              type: "array",
              value: parsedArray
            };
          } else if (isPlainObject(arg)) {
            try {
              JSON.stringify(arg);
            } catch (error) {
              if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
                error.message += " Recursive objects are not allowed.";
              }
              throw error;
            }
            const parsedObject = [];
            for (const key in arg) {
              parsedObject.push([
                _BidiSerializer.serializeRemoteValue(key),
                _BidiSerializer.serializeRemoteValue(arg[key])
              ]);
            }
            return {
              type: "object",
              value: parsedObject
            };
          } else if (isRegExp3(arg)) {
            return {
              type: "regexp",
              value: {
                pattern: arg.source,
                flags: arg.flags
              }
            };
          } else if (isDate3(arg)) {
            return {
              type: "date",
              value: arg.toISOString()
            };
          }
          throw new UnserializableError("Custom object sterilization not possible. Use plain objects instead.");
        }
        static serializeRemoteValue(arg) {
          switch (typeof arg) {
            case "symbol":
            case "function":
              throw new UnserializableError(`Unable to serializable ${typeof arg}`);
            case "object":
              return _BidiSerializer.serializeObject(arg);
            case "undefined":
              return {
                type: "undefined"
              };
            case "number":
              return _BidiSerializer.serializeNumber(arg);
            case "bigint":
              return {
                type: "bigint",
                value: arg.toString()
              };
            case "string":
              return {
                type: "string",
                value: arg
              };
            case "boolean":
              return {
                type: "boolean",
                value: arg
              };
          }
        }
        static async serialize(sandbox, arg) {
          if (arg instanceof LazyArg) {
            arg = await arg.get(sandbox.realm);
          }
          const objectHandle = arg && (arg instanceof BidiJSHandle || arg instanceof BidiElementHandle) ? arg : null;
          if (objectHandle) {
            if (objectHandle.realm.environment.context() !== sandbox.environment.context()) {
              throw new Error("JSHandles can be evaluated only in the context they were created!");
            }
            if (objectHandle.disposed) {
              throw new Error("JSHandle is disposed!");
            }
            return objectHandle.remoteValue();
          }
          return _BidiSerializer.serializeRemoteValue(arg);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js
  function createBidiHandle(sandbox, result) {
    if (result.type === "node" || result.type === "window") {
      return new BidiElementHandle(sandbox, result);
    }
    return new BidiJSHandle(sandbox, result);
  }
  var Bidi, BidiRealm;
  var init_Realm = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Realm.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Bidi = __toESM(require_protocol(), 1);
      init_EventEmitter();
      init_ScriptInjector();
      init_util2();
      init_disposable();
      init_Function();
      init_Deserializer();
      init_ElementHandle2();
      init_JSHandle2();
      init_Serializer();
      init_util3();
      BidiRealm = class extends EventEmitter {
        connection;
        #id;
        #sandbox;
        constructor(connection) {
          super();
          this.connection = connection;
        }
        get target() {
          return {
            context: this.#sandbox.environment._id,
            sandbox: this.#sandbox.name
          };
        }
        handleRealmDestroyed = async (params) => {
          if (params.realm === this.#id) {
            this.internalPuppeteerUtil = void 0;
            this.#sandbox.environment.clearDocumentHandle();
          }
        };
        handleRealmCreated = (params) => {
          if (params.type === "window" && params.context === this.#sandbox.environment._id && params.sandbox === this.#sandbox.name) {
            this.#id = params.realm;
            void this.#sandbox.taskManager.rerunAll();
          }
        };
        setSandbox(sandbox) {
          this.#sandbox = sandbox;
          this.connection.on(Bidi.ChromiumBidi.Script.EventNames.RealmCreated, this.handleRealmCreated);
          this.connection.on(Bidi.ChromiumBidi.Script.EventNames.RealmDestroyed, this.handleRealmDestroyed);
        }
        internalPuppeteerUtil;
        get puppeteerUtil() {
          const promise = Promise.resolve();
          scriptInjector.inject((script) => {
            if (this.internalPuppeteerUtil) {
              void this.internalPuppeteerUtil.then((handle) => {
                void handle.dispose();
              });
            }
            this.internalPuppeteerUtil = promise.then(() => {
              return this.evaluateHandle(script);
            });
          }, !this.internalPuppeteerUtil);
          return this.internalPuppeteerUtil;
        }
        async evaluateHandle(pageFunction, ...args) {
          return await this.#evaluate(false, pageFunction, ...args);
        }
        async evaluate(pageFunction, ...args) {
          return await this.#evaluate(true, pageFunction, ...args);
        }
        async #evaluate(returnByValue, pageFunction, ...args) {
          const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
          const sandbox = this.#sandbox;
          let responsePromise;
          const resultOwnership = returnByValue ? "none" : "root";
          const serializationOptions = returnByValue ? {} : {
            maxObjectDepth: 0,
            maxDomDepth: 0
          };
          if (isString3(pageFunction)) {
            const expression = SOURCE_URL_REGEX.test(pageFunction) ? pageFunction : `${pageFunction}
${sourceUrlComment}
`;
            responsePromise = this.connection.send("script.evaluate", {
              expression,
              target: this.target,
              resultOwnership,
              awaitPromise: true,
              userActivation: true,
              serializationOptions
            });
          } else {
            let functionDeclaration = stringifyFunction(pageFunction);
            functionDeclaration = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
            responsePromise = this.connection.send("script.callFunction", {
              functionDeclaration,
              arguments: args.length ? await Promise.all(args.map((arg) => {
                return BidiSerializer.serialize(sandbox, arg);
              })) : [],
              target: this.target,
              resultOwnership,
              awaitPromise: true,
              userActivation: true,
              serializationOptions
            });
          }
          const { result } = await responsePromise;
          if ("type" in result && result.type === "exception") {
            throw createEvaluationError2(result.exceptionDetails);
          }
          return returnByValue ? BidiDeserializer.deserialize(result.result) : createBidiHandle(sandbox, result.result);
        }
        [disposeSymbol]() {
          this.connection.off(Bidi.ChromiumBidi.Script.EventNames.RealmCreated, this.handleRealmCreated);
          this.connection.off(Bidi.ChromiumBidi.Script.EventNames.RealmDestroyed, this.handleRealmDestroyed);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowsingContext.js
  var cdpSessions, CdpSessionWrapper, BrowsingContextEvent, BrowsingContext;
  var init_BrowsingContext = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowsingContext.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_CDPSession();
      init_Errors();
      init_util2();
      init_Deferred();
      init_Realm();
      cdpSessions = /* @__PURE__ */ new Map();
      CdpSessionWrapper = class extends CDPSession {
        #context;
        #sessionId = Deferred.create();
        #detached = false;
        constructor(context, sessionId) {
          super();
          this.#context = context;
          if (!this.#context.supportsCdp()) {
            return;
          }
          if (sessionId) {
            this.#sessionId.resolve(sessionId);
            cdpSessions.set(sessionId, this);
          } else {
            context.connection.send("cdp.getSession", {
              context: context.id
            }).then((session) => {
              this.#sessionId.resolve(session.result.session);
              cdpSessions.set(session.result.session, this);
            }).catch((err) => {
              this.#sessionId.reject(err);
            });
          }
        }
        connection() {
          return void 0;
        }
        async send(method, ...paramArgs) {
          if (!this.#context.supportsCdp()) {
            throw new UnsupportedOperation("CDP support is required for this feature. The current browser does not support CDP.");
          }
          if (this.#detached) {
            throw new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the page has been closed.`);
          }
          const session = await this.#sessionId.valueOrThrow();
          const { result } = await this.#context.connection.send("cdp.sendCommand", {
            method,
            params: paramArgs[0],
            session
          });
          return result.result;
        }
        async detach() {
          cdpSessions.delete(this.id());
          if (!this.#detached && this.#context.supportsCdp()) {
            await this.#context.cdpSession.send("Target.detachFromTarget", {
              sessionId: this.id()
            });
          }
          this.#detached = true;
        }
        id() {
          const val = this.#sessionId.value();
          return val instanceof Error || val === void 0 ? "" : val;
        }
      };
      (function(BrowsingContextEvent2) {
        BrowsingContextEvent2.Created = Symbol("BrowsingContext.created");
        BrowsingContextEvent2.Destroyed = Symbol("BrowsingContext.destroyed");
      })(BrowsingContextEvent || (BrowsingContextEvent = {}));
      BrowsingContext = class extends BidiRealm {
        #id;
        #url;
        #cdpSession;
        #parent;
        #browserName = "";
        constructor(connection, info, browserName) {
          super(connection);
          this.#id = info.context;
          this.#url = info.url;
          this.#parent = info.parent;
          this.#browserName = browserName;
          this.#cdpSession = new CdpSessionWrapper(this, void 0);
          this.on("browsingContext.domContentLoaded", this.#updateUrl.bind(this));
          this.on("browsingContext.fragmentNavigated", this.#updateUrl.bind(this));
          this.on("browsingContext.load", this.#updateUrl.bind(this));
        }
        supportsCdp() {
          return !this.#browserName.toLowerCase().includes("firefox");
        }
        #updateUrl(info) {
          this.#url = info.url;
        }
        createRealmForSandbox() {
          return new BidiRealm(this.connection);
        }
        get url() {
          return this.#url;
        }
        get id() {
          return this.#id;
        }
        get parent() {
          return this.#parent;
        }
        get cdpSession() {
          return this.#cdpSession;
        }
        async sendCdpCommand(method, ...paramArgs) {
          return await this.#cdpSession.send(method, ...paramArgs);
        }
        dispose() {
          this.removeAllListeners();
          this.connection.unregisterBrowsingContexts(this.#id);
          void this.#cdpSession.detach().catch(debugError);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js
  function createProtocolError(object) {
    let message = `${object.error} ${object.message}`;
    if (object.stacktrace) {
      message += ` ${object.stacktrace}`;
    }
    return message;
  }
  function isCdpEvent(event) {
    return event.method.startsWith("cdp.");
  }
  var debugProtocolSend2, debugProtocolReceive2, BidiConnection;
  var init_Connection = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Connection.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_CallbackRegistry();
      init_Debug();
      init_EventEmitter();
      init_util2();
      init_assert();
      init_BrowsingContext();
      debugProtocolSend2 = debug("puppeteer:webDriverBiDi:SEND \u25BA");
      debugProtocolReceive2 = debug("puppeteer:webDriverBiDi:RECV \u25C0");
      BidiConnection = class extends EventEmitter {
        #url;
        #transport;
        #delay;
        #timeout = 0;
        #closed = false;
        #callbacks = new CallbackRegistry();
        #browsingContexts = /* @__PURE__ */ new Map();
        constructor(url, transport, delay = 0, timeout2) {
          super();
          this.#url = url;
          this.#delay = delay;
          this.#timeout = timeout2 ?? 18e4;
          this.#transport = transport;
          this.#transport.onmessage = this.onMessage.bind(this);
          this.#transport.onclose = this.unbind.bind(this);
        }
        get closed() {
          return this.#closed;
        }
        get url() {
          return this.#url;
        }
        send(method, params) {
          assert2(!this.#closed, "Protocol error: Connection closed.");
          return this.#callbacks.create(method, this.#timeout, (id) => {
            const stringifiedMessage = JSON.stringify({
              id,
              method,
              params
            });
            debugProtocolSend2(stringifiedMessage);
            this.#transport.send(stringifiedMessage);
          });
        }
        /**
         * @internal
         */
        async onMessage(message) {
          if (this.#delay) {
            await new Promise((f7) => {
              return setTimeout(f7, this.#delay);
            });
          }
          debugProtocolReceive2(message);
          const object = JSON.parse(message);
          if ("type" in object) {
            switch (object.type) {
              case "success":
                this.#callbacks.resolve(object.id, object);
                return;
              case "error":
                if (object.id === null) {
                  break;
                }
                this.#callbacks.reject(object.id, createProtocolError(object), object.message);
                return;
              case "event":
                if (isCdpEvent(object)) {
                  cdpSessions.get(object.params.session)?.emit(object.params.event, object.params.params);
                  return;
                }
                this.#maybeEmitOnContext(object);
                this.emit(object.method, object.params);
                return;
            }
          }
          if ("id" in object) {
            this.#callbacks.reject(object.id, `Protocol Error. Message is not in BiDi protocol format: '${message}'`, object.message);
          }
          debugError(object);
        }
        #maybeEmitOnContext(event) {
          let context;
          if ("context" in event.params && event.params.context !== null) {
            context = this.#browsingContexts.get(event.params.context);
          } else if ("source" in event.params && event.params.source.context !== void 0) {
            context = this.#browsingContexts.get(event.params.source.context);
          }
          context?.emit(event.method, event.params);
        }
        registerBrowsingContexts(context) {
          this.#browsingContexts.set(context.id, context);
        }
        getBrowsingContext(contextId) {
          const currentContext = this.#browsingContexts.get(contextId);
          if (!currentContext) {
            throw new Error(`BrowsingContext ${contextId} does not exist.`);
          }
          return currentContext;
        }
        getTopLevelContext(contextId) {
          let currentContext = this.#browsingContexts.get(contextId);
          if (!currentContext) {
            throw new Error(`BrowsingContext ${contextId} does not exist.`);
          }
          while (currentContext.parent) {
            contextId = currentContext.parent;
            currentContext = this.#browsingContexts.get(contextId);
            if (!currentContext) {
              throw new Error(`BrowsingContext ${contextId} does not exist.`);
            }
          }
          return currentContext;
        }
        unregisterBrowsingContexts(id) {
          this.#browsingContexts.delete(id);
        }
        /**
         * Unbinds the connection, but keeps the transport open. Useful when the transport will
         * be reused by other connection e.g. with different protocol.
         * @internal
         */
        unbind() {
          if (this.#closed) {
            return;
          }
          this.#closed = true;
          this.#transport.onmessage = () => {
          };
          this.#transport.onclose = () => {
          };
          this.#browsingContexts.clear();
          this.#callbacks.clear();
        }
        /**
         * Unbinds the connection and closes the transport.
         */
        dispose() {
          this.unbind();
          this.#transport.close();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js
  async function connectBidiOverCdp(cdp, options) {
    const transportBiDi = new NoOpTransport();
    const cdpConnectionAdapter = new CdpConnectionAdapter(cdp);
    const pptrTransport = {
      send(message) {
        transportBiDi.emitMessage(JSON.parse(message));
      },
      close() {
        bidiServer.close();
        cdpConnectionAdapter.close();
        cdp.dispose();
      },
      onmessage(_message) {
      }
    };
    transportBiDi.on("bidiResponse", (message) => {
      pptrTransport.onmessage(JSON.stringify(message));
    });
    const pptrBiDiConnection = new BidiConnection(cdp.url(), pptrTransport);
    const bidiServer = await BidiMapper.BidiServer.createAndStart(
      transportBiDi,
      cdpConnectionAdapter,
      // TODO: most likely need a little bit of refactoring
      cdpConnectionAdapter.browserClient(),
      "",
      options,
      void 0,
      bidiServerLogger
    );
    return pptrBiDiConnection;
  }
  var BidiMapper, bidiServerLogger, CdpConnectionAdapter, CDPClientAdapter, NoOpTransport;
  var init_BidiOverCdp = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      BidiMapper = __toESM(require_BidiMapper(), 1);
      init_Debug();
      init_Errors();
      init_Connection();
      bidiServerLogger = (prefix, ...args) => {
        debug(`bidi:${prefix}`)(args);
      };
      CdpConnectionAdapter = class {
        #cdp;
        #adapters = /* @__PURE__ */ new Map();
        #browserCdpConnection;
        constructor(cdp) {
          this.#cdp = cdp;
          this.#browserCdpConnection = new CDPClientAdapter(cdp);
        }
        browserClient() {
          return this.#browserCdpConnection;
        }
        getCdpClient(id) {
          const session = this.#cdp.session(id);
          if (!session) {
            throw new Error(`Unknown CDP session with id ${id}`);
          }
          if (!this.#adapters.has(session)) {
            const adapter = new CDPClientAdapter(session, id, this.#browserCdpConnection);
            this.#adapters.set(session, adapter);
            return adapter;
          }
          return this.#adapters.get(session);
        }
        close() {
          this.#browserCdpConnection.close();
          for (const adapter of this.#adapters.values()) {
            adapter.close();
          }
        }
      };
      CDPClientAdapter = class extends BidiMapper.EventEmitter {
        #closed = false;
        #client;
        sessionId = void 0;
        #browserClient;
        constructor(client, sessionId, browserClient) {
          super();
          this.#client = client;
          this.sessionId = sessionId;
          this.#browserClient = browserClient;
          this.#client.on("*", this.#forwardMessage);
        }
        browserClient() {
          return this.#browserClient;
        }
        #forwardMessage = (method, event) => {
          this.emit(method, event);
        };
        async sendCommand(method, ...params) {
          if (this.#closed) {
            return;
          }
          try {
            return await this.#client.send(method, ...params);
          } catch (err) {
            if (this.#closed) {
              return;
            }
            throw err;
          }
        }
        close() {
          this.#client.off("*", this.#forwardMessage);
          this.#closed = true;
        }
        isCloseError(error) {
          return error instanceof TargetCloseError;
        }
      };
      NoOpTransport = class extends BidiMapper.EventEmitter {
        #onMessage = async (_m) => {
          return;
        };
        emitMessage(message) {
          void this.#onMessage(message);
        }
        setOnMessage(onMessage) {
          this.#onMessage = onMessage;
        }
        async sendMessage(message) {
          this.emit("bidiResponse", message);
        }
        close() {
          this.#onMessage = async (_m) => {
            return;
          };
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js
  var WEB_PERMISSION_TO_PROTOCOL_PERMISSION, Browser;
  var init_Browser = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Browser.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_EventEmitter();
      init_util2();
      init_util2();
      init_disposable();
      WEB_PERMISSION_TO_PROTOCOL_PERMISSION = /* @__PURE__ */ new Map([
        ["geolocation", "geolocation"],
        ["midi", "midi"],
        ["notifications", "notifications"],
        // TODO: push isn't a valid type?
        // ['push', 'push'],
        ["camera", "videoCapture"],
        ["microphone", "audioCapture"],
        ["background-sync", "backgroundSync"],
        ["ambient-light-sensor", "sensors"],
        ["accelerometer", "sensors"],
        ["gyroscope", "sensors"],
        ["magnetometer", "sensors"],
        ["accessibility-events", "accessibilityEvents"],
        ["clipboard-read", "clipboardReadWrite"],
        ["clipboard-write", "clipboardReadWrite"],
        ["clipboard-sanitized-write", "clipboardSanitizedWrite"],
        ["payment-handler", "paymentHandler"],
        ["persistent-storage", "durableStorage"],
        ["idle-detection", "idleDetection"],
        // chrome-specific permissions we have.
        ["midi-sysex", "midiSysex"]
      ]);
      Browser = class extends EventEmitter {
        /**
         * @internal
         */
        constructor() {
          super();
        }
        /**
         * Waits until a {@link Target | target} matching the given `predicate`
         * appears and returns it.
         *
         * This will look all open {@link BrowserContext | browser contexts}.
         *
         * @example Finding a target for a page opened via `window.open`:
         *
         * ```ts
         * await page.evaluate(() => window.open('https://www.example.com/'));
         * const newWindowTarget = await browser.waitForTarget(
         *   target => target.url() === 'https://www.example.com/'
         * );
         * ```
         */
        async waitForTarget(predicate, options = {}) {
          const { timeout: ms = 3e4 } = options;
          return await fe(he(xr(
            this,
            "targetcreated"
            /* BrowserEvent.TargetCreated */
          ), xr(
            this,
            "targetchanged"
            /* BrowserEvent.TargetChanged */
          ), j(this.targets())).pipe(Au(predicate), Oe(timeout(ms))));
        }
        /**
         * Gets a list of all open {@link Page | pages} inside this {@link Browser}.
         *
         * If there ar multiple {@link BrowserContext | browser contexts}, this
         * returns all {@link Page | pages} in all
         * {@link BrowserContext | browser contexts}.
         *
         * @remarks Non-visible {@link Page | pages}, such as `"background_page"`,
         * will not be listed here. You can find them using {@link Target.page}.
         */
        async pages() {
          const contextPages = await Promise.all(this.browserContexts().map((context) => {
            return context.pages();
          }));
          return contextPages.reduce((acc, x4) => {
            return acc.concat(x4);
          }, []);
        }
        /**
         * Whether Puppeteer is connected to this {@link Browser | browser}.
         *
         * @deprecated Use {@link Browser.connected}.
         */
        isConnected() {
          return this.connected;
        }
        /** @internal */
        [disposeSymbol]() {
          return void this.close().catch(debugError);
        }
        /** @internal */
        [asyncDisposeSymbol]() {
          return this.close();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js
  var BrowserContext;
  var init_BrowserContext = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_EventEmitter();
      init_util2();
      init_disposable();
      BrowserContext = class extends EventEmitter {
        /**
         * @internal
         */
        constructor() {
          super();
        }
        /**
         * Whether this {@link BrowserContext | browser context} is closed.
         */
        get closed() {
          return !this.browser().browserContexts().includes(this);
        }
        /**
         * Identifier for this {@link BrowserContext | browser context}.
         */
        get id() {
          return void 0;
        }
        /** @internal */
        [disposeSymbol]() {
          return void this.close().catch(debugError);
        }
        /** @internal */
        [asyncDisposeSymbol]() {
          return this.close();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js
  var BidiBrowserContext;
  var init_BrowserContext2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_BrowserContext();
      init_Errors();
      BidiBrowserContext = class extends BrowserContext {
        #browser;
        #connection;
        #defaultViewport;
        #isDefault = false;
        constructor(browser, options) {
          super();
          this.#browser = browser;
          this.#connection = this.#browser.connection;
          this.#defaultViewport = options.defaultViewport;
          this.#isDefault = options.isDefault;
        }
        targets() {
          return this.#browser.targets().filter((target) => {
            return target.browserContext() === this;
          });
        }
        waitForTarget(predicate, options = {}) {
          return this.#browser.waitForTarget((target) => {
            return target.browserContext() === this && predicate(target);
          }, options);
        }
        get connection() {
          return this.#connection;
        }
        async newPage() {
          const { result } = await this.#connection.send("browsingContext.create", {
            type: "tab"
          });
          const target = this.#browser._getTargetById(result.context);
          target._setBrowserContext(this);
          const page = await target.page();
          if (!page) {
            throw new Error("Page is not found");
          }
          if (this.#defaultViewport) {
            try {
              await page.setViewport(this.#defaultViewport);
            } catch {
            }
          }
          return page;
        }
        async close() {
          if (this.#isDefault) {
            throw new Error("Default context cannot be closed!");
          }
          await this.#browser._closeContext(this);
        }
        browser() {
          return this.#browser;
        }
        async pages() {
          const results = await Promise.all([...this.targets()].map((t8) => {
            return t8.page();
          }));
          return results.filter((p8) => {
            return p8 !== null;
          });
        }
        isIncognito() {
          return !this.#isDefault;
        }
        overridePermissions() {
          throw new UnsupportedOperation();
        }
        clearPermissionOverrides() {
          throw new UnsupportedOperation();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js
  var TargetType, Target;
  var init_Target = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Target.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      (function(TargetType2) {
        TargetType2["PAGE"] = "page";
        TargetType2["BACKGROUND_PAGE"] = "background_page";
        TargetType2["SERVICE_WORKER"] = "service_worker";
        TargetType2["SHARED_WORKER"] = "shared_worker";
        TargetType2["BROWSER"] = "browser";
        TargetType2["WEBVIEW"] = "webview";
        TargetType2["OTHER"] = "other";
        TargetType2["TAB"] = "tab";
      })(TargetType || (TargetType = {}));
      Target = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * If the target is not of type `"service_worker"` or `"shared_worker"`, returns `null`.
         */
        async worker() {
          return null;
        }
        /**
         * If the target is not of type `"page"`, `"webview"` or `"background_page"`,
         * returns `null`.
         */
        async page() {
          return null;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js
  var NetworkManagerEvent;
  var init_NetworkManagerEvents = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      (function(NetworkManagerEvent2) {
        NetworkManagerEvent2.Request = Symbol("NetworkManager.Request");
        NetworkManagerEvent2.RequestServedFromCache = Symbol("NetworkManager.RequestServedFromCache");
        NetworkManagerEvent2.Response = Symbol("NetworkManager.Response");
        NetworkManagerEvent2.RequestFailed = Symbol("NetworkManager.RequestFailed");
        NetworkManagerEvent2.RequestFinished = Symbol("NetworkManager.RequestFinished");
      })(NetworkManagerEvent || (NetworkManagerEvent = {}));
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js
  var paperFormats;
  var init_PDFOptions = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      paperFormats = {
        letter: { width: 8.5, height: 11 },
        legal: { width: 8.5, height: 14 },
        tabloid: { width: 11, height: 17 },
        ledger: { width: 17, height: 11 },
        a0: { width: 33.1, height: 46.8 },
        a1: { width: 23.4, height: 33.1 },
        a2: { width: 16.54, height: 23.4 },
        a3: { width: 11.7, height: 16.54 },
        a4: { width: 8.27, height: 11.7 },
        a5: { width: 5.83, height: 8.27 },
        a6: { width: 4.13, height: 5.83 }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js
  var DEFAULT_TIMEOUT, TimeoutSettings;
  var init_TimeoutSettings = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      DEFAULT_TIMEOUT = 3e4;
      TimeoutSettings = class {
        #defaultTimeout;
        #defaultNavigationTimeout;
        constructor() {
          this.#defaultTimeout = null;
          this.#defaultNavigationTimeout = null;
        }
        setDefaultTimeout(timeout2) {
          this.#defaultTimeout = timeout2;
        }
        setDefaultNavigationTimeout(timeout2) {
          this.#defaultNavigationTimeout = timeout2;
        }
        navigationTimeout() {
          if (this.#defaultNavigationTimeout !== null) {
            return this.#defaultNavigationTimeout;
          }
          if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
          }
          return DEFAULT_TIMEOUT;
        }
        timeout() {
          if (this.#defaultTimeout !== null) {
            return this.#defaultTimeout;
          }
          return DEFAULT_TIMEOUT;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js
  function checkLocatorArray(locators) {
    for (const locator of locators) {
      if (!(locator instanceof Locator)) {
        throw new Error("Unknown locator for race candidate");
      }
    }
    return locators;
  }
  var __addDisposableResource7, __disposeResources7, LocatorEvent, Locator, FunctionLocator, DelegatedLocator, FilteredLocator, MappedLocator, NodeLocator, RaceLocator, RETRY_DELAY;
  var init_locators = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/locators/locators.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_EventEmitter();
      init_util2();
      __addDisposableResource7 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources7 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      (function(LocatorEvent2) {
        LocatorEvent2["Action"] = "action";
      })(LocatorEvent || (LocatorEvent = {}));
      Locator = class extends EventEmitter {
        /**
         * Creates a race between multiple locators but ensures that only a single one
         * acts.
         *
         * @public
         */
        static race(locators) {
          return RaceLocator.create(locators);
        }
        /**
         * @internal
         */
        visibility = null;
        /**
         * @internal
         */
        _timeout = 3e4;
        #ensureElementIsInTheViewport = true;
        #waitForEnabled = true;
        #waitForStableBoundingBox = true;
        /**
         * @internal
         */
        operators = {
          conditions: (conditions, signal) => {
            return E((handle) => {
              return he(...conditions.map((condition) => {
                return condition(handle, signal);
              })).pipe(br(handle));
            });
          },
          retryAndRaceWithSignalAndTimer: (signal) => {
            const candidates = [];
            if (signal) {
              candidates.push(xr(signal, "abort").pipe(k(() => {
                throw signal.reason;
              })));
            }
            candidates.push(timeout(this._timeout));
            return Nr(Ae({ delay: RETRY_DELAY }), Oe(...candidates));
          }
        };
        // Determines when the locator will timeout for actions.
        get timeout() {
          return this._timeout;
        }
        setTimeout(timeout2) {
          const locator = this._clone();
          locator._timeout = timeout2;
          return locator;
        }
        setVisibility(visibility) {
          const locator = this._clone();
          locator.visibility = visibility;
          return locator;
        }
        setWaitForEnabled(value) {
          const locator = this._clone();
          locator.#waitForEnabled = value;
          return locator;
        }
        setEnsureElementIsInTheViewport(value) {
          const locator = this._clone();
          locator.#ensureElementIsInTheViewport = value;
          return locator;
        }
        setWaitForStableBoundingBox(value) {
          const locator = this._clone();
          locator.#waitForStableBoundingBox = value;
          return locator;
        }
        /**
         * @internal
         */
        copyOptions(locator) {
          this._timeout = locator._timeout;
          this.visibility = locator.visibility;
          this.#waitForEnabled = locator.#waitForEnabled;
          this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;
          this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;
          return this;
        }
        /**
         * If the element has a "disabled" property, wait for the element to be
         * enabled.
         */
        #waitForEnabledIfNeeded = (handle, signal) => {
          if (!this.#waitForEnabled) {
            return N;
          }
          return j(handle.frame.waitForFunction((element) => {
            if (!(element instanceof HTMLElement)) {
              return true;
            }
            const isNativeFormControl = [
              "BUTTON",
              "INPUT",
              "SELECT",
              "TEXTAREA",
              "OPTION",
              "OPTGROUP"
            ].includes(element.nodeName);
            return !isNativeFormControl || !element.hasAttribute("disabled");
          }, {
            timeout: this._timeout,
            signal
          }, handle)).pipe(gr());
        };
        /**
         * Compares the bounding box of the element for two consecutive animation
         * frames and waits till they are the same.
         */
        #waitForStableBoundingBoxIfNeeded = (handle) => {
          if (!this.#waitForStableBoundingBox) {
            return N;
          }
          return se(() => {
            return j(handle.evaluate((element) => {
              return new Promise((resolve3) => {
                window.requestAnimationFrame(() => {
                  const rect1 = element.getBoundingClientRect();
                  window.requestAnimationFrame(() => {
                    const rect2 = element.getBoundingClientRect();
                    resolve3([
                      {
                        x: rect1.x,
                        y: rect1.y,
                        width: rect1.width,
                        height: rect1.height
                      },
                      {
                        x: rect2.x,
                        y: rect2.y,
                        width: rect2.width,
                        height: rect2.height
                      }
                    ]);
                  });
                });
              });
            }));
          }).pipe(Ee(([rect1, rect2]) => {
            return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;
          }), Ae({ delay: RETRY_DELAY }), gr());
        };
        /**
         * Checks if the element is in the viewport and auto-scrolls it if it is not.
         */
        #ensureElementIsInTheViewportIfNeeded = (handle) => {
          if (!this.#ensureElementIsInTheViewport) {
            return N;
          }
          return j(handle.isIntersectingViewport({ threshold: 0 })).pipe(J((isIntersectingViewport) => {
            return !isIntersectingViewport;
          }), E(() => {
            return j(handle.scrollIntoView());
          }), E(() => {
            return se(() => {
              return j(handle.isIntersectingViewport({ threshold: 0 }));
            }).pipe(Ee(S), Ae({ delay: RETRY_DELAY }), gr());
          }));
        };
        #click(options) {
          const signal = options?.signal;
          return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
            this.#waitForEnabledIfNeeded
          ], signal), Pe(() => {
            return this.emit(LocatorEvent.Action, void 0);
          }), E((handle) => {
            return j(handle.click(options)).pipe(kr((err) => {
              void handle.dispose().catch(debugError);
              throw err;
            }));
          }), this.operators.retryAndRaceWithSignalAndTimer(signal));
        }
        #fill(value, options) {
          const signal = options?.signal;
          return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded,
            this.#waitForEnabledIfNeeded
          ], signal), Pe(() => {
            return this.emit(LocatorEvent.Action, void 0);
          }), E((handle) => {
            return j(handle.evaluate((el) => {
              if (el instanceof HTMLSelectElement) {
                return "select";
              }
              if (el instanceof HTMLTextAreaElement) {
                return "typeable-input";
              }
              if (el instanceof HTMLInputElement) {
                if ((/* @__PURE__ */ new Set([
                  "textarea",
                  "text",
                  "url",
                  "tel",
                  "search",
                  "password",
                  "number",
                  "email"
                ])).has(el.type)) {
                  return "typeable-input";
                } else {
                  return "other-input";
                }
              }
              if (el.isContentEditable) {
                return "contenteditable";
              }
              return "unknown";
            })).pipe(E((inputType) => {
              switch (inputType) {
                case "select":
                  return j(handle.select(value).then(F));
                case "contenteditable":
                case "typeable-input":
                  return j(handle.evaluate((input, newValue) => {
                    const currentValue = input.isContentEditable ? input.innerText : input.value;
                    if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {
                      if (input.isContentEditable) {
                        input.innerText = "";
                      } else {
                        input.value = "";
                      }
                      return newValue;
                    }
                    const originalValue = input.isContentEditable ? input.innerText : input.value;
                    if (input.isContentEditable) {
                      input.innerText = "";
                      input.innerText = originalValue;
                    } else {
                      input.value = "";
                      input.value = originalValue;
                    }
                    return newValue.substring(originalValue.length);
                  }, value)).pipe(E((textToType) => {
                    return j(handle.type(textToType));
                  }));
                case "other-input":
                  return j(handle.focus()).pipe(E(() => {
                    return j(handle.evaluate((input, value2) => {
                      input.value = value2;
                      input.dispatchEvent(new Event("input", { bubbles: true }));
                      input.dispatchEvent(new Event("change", { bubbles: true }));
                    }, value));
                  }));
                case "unknown":
                  throw new Error(`Element cannot be filled out.`);
              }
            })).pipe(kr((err) => {
              void handle.dispose().catch(debugError);
              throw err;
            }));
          }), this.operators.retryAndRaceWithSignalAndTimer(signal));
        }
        #hover(options) {
          const signal = options?.signal;
          return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded
          ], signal), Pe(() => {
            return this.emit(LocatorEvent.Action, void 0);
          }), E((handle) => {
            return j(handle.hover()).pipe(kr((err) => {
              void handle.dispose().catch(debugError);
              throw err;
            }));
          }), this.operators.retryAndRaceWithSignalAndTimer(signal));
        }
        #scroll(options) {
          const signal = options?.signal;
          return this._wait(options).pipe(this.operators.conditions([
            this.#ensureElementIsInTheViewportIfNeeded,
            this.#waitForStableBoundingBoxIfNeeded
          ], signal), Pe(() => {
            return this.emit(LocatorEvent.Action, void 0);
          }), E((handle) => {
            return j(handle.evaluate((el, scrollTop, scrollLeft) => {
              if (scrollTop !== void 0) {
                el.scrollTop = scrollTop;
              }
              if (scrollLeft !== void 0) {
                el.scrollLeft = scrollLeft;
              }
            }, options?.scrollTop, options?.scrollLeft)).pipe(kr((err) => {
              void handle.dispose().catch(debugError);
              throw err;
            }));
          }), this.operators.retryAndRaceWithSignalAndTimer(signal));
        }
        /**
         * Clones the locator.
         */
        clone() {
          return this._clone();
        }
        /**
         * Waits for the locator to get a handle from the page.
         *
         * @public
         */
        async waitHandle(options) {
          return await fe(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal)));
        }
        /**
         * Waits for the locator to get the serialized value from the page.
         *
         * Note this requires the value to be JSON-serializable.
         *
         * @public
         */
        async wait(options) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handle = __addDisposableResource7(env_1, await this.waitHandle(options), false);
            return await handle.jsonValue();
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources7(env_1);
          }
        }
        /**
         * Maps the locator using the provided mapper.
         *
         * @public
         */
        map(mapper) {
          return new MappedLocator(this._clone(), (handle) => {
            return handle.evaluateHandle(mapper);
          });
        }
        /**
         * Creates an expectation that is evaluated against located values.
         *
         * If the expectations do not match, then the locator will retry.
         *
         * @public
         */
        filter(predicate) {
          return new FilteredLocator(this._clone(), async (handle, signal) => {
            await handle.frame.waitForFunction(predicate, { signal, timeout: this._timeout }, handle);
            return true;
          });
        }
        /**
         * Creates an expectation that is evaluated against located handles.
         *
         * If the expectations do not match, then the locator will retry.
         *
         * @internal
         */
        filterHandle(predicate) {
          return new FilteredLocator(this._clone(), predicate);
        }
        /**
         * Maps the locator using the provided mapper.
         *
         * @internal
         */
        mapHandle(mapper) {
          return new MappedLocator(this._clone(), mapper);
        }
        click(options) {
          return fe(this.#click(options));
        }
        /**
         * Fills out the input identified by the locator using the provided value. The
         * type of the input is determined at runtime and the appropriate fill-out
         * method is chosen based on the type. contenteditable, selector, inputs are
         * supported.
         */
        fill(value, options) {
          return fe(this.#fill(value, options));
        }
        hover(options) {
          return fe(this.#hover(options));
        }
        scroll(options) {
          return fe(this.#scroll(options));
        }
      };
      FunctionLocator = class _FunctionLocator extends Locator {
        static create(pageOrFrame, func) {
          return new _FunctionLocator(pageOrFrame, func).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
        }
        #pageOrFrame;
        #func;
        constructor(pageOrFrame, func) {
          super();
          this.#pageOrFrame = pageOrFrame;
          this.#func = func;
        }
        _clone() {
          return new _FunctionLocator(this.#pageOrFrame, this.#func);
        }
        _wait(options) {
          const signal = options?.signal;
          return se(() => {
            return j(this.#pageOrFrame.waitForFunction(this.#func, {
              timeout: this.timeout,
              signal
            }));
          }).pipe(wr());
        }
      };
      DelegatedLocator = class extends Locator {
        #delegate;
        constructor(delegate) {
          super();
          this.#delegate = delegate;
          this.copyOptions(this.#delegate);
        }
        get delegate() {
          return this.#delegate;
        }
        setTimeout(timeout2) {
          const locator = super.setTimeout(timeout2);
          locator.#delegate = this.#delegate.setTimeout(timeout2);
          return locator;
        }
        setVisibility(visibility) {
          const locator = super.setVisibility(visibility);
          locator.#delegate = locator.#delegate.setVisibility(visibility);
          return locator;
        }
        setWaitForEnabled(value) {
          const locator = super.setWaitForEnabled(value);
          locator.#delegate = this.#delegate.setWaitForEnabled(value);
          return locator;
        }
        setEnsureElementIsInTheViewport(value) {
          const locator = super.setEnsureElementIsInTheViewport(value);
          locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);
          return locator;
        }
        setWaitForStableBoundingBox(value) {
          const locator = super.setWaitForStableBoundingBox(value);
          locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);
          return locator;
        }
      };
      FilteredLocator = class _FilteredLocator extends DelegatedLocator {
        #predicate;
        constructor(base, predicate) {
          super(base);
          this.#predicate = predicate;
        }
        _clone() {
          return new _FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);
        }
        _wait(options) {
          return this.delegate._wait(options).pipe(E((handle) => {
            return j(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(J((value) => {
              return value;
            }), k(() => {
              return handle;
            }));
          }), wr());
        }
      };
      MappedLocator = class _MappedLocator extends DelegatedLocator {
        #mapper;
        constructor(base, mapper) {
          super(base);
          this.#mapper = mapper;
        }
        _clone() {
          return new _MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);
        }
        _wait(options) {
          return this.delegate._wait(options).pipe(E((handle) => {
            return j(Promise.resolve(this.#mapper(handle, options?.signal)));
          }));
        }
      };
      NodeLocator = class _NodeLocator extends Locator {
        static create(pageOrFrame, selector) {
          return new _NodeLocator(pageOrFrame, selector).setTimeout("getDefaultTimeout" in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());
        }
        #pageOrFrame;
        #selector;
        constructor(pageOrFrame, selector) {
          super();
          this.#pageOrFrame = pageOrFrame;
          this.#selector = selector;
        }
        /**
         * Waits for the element to become visible or hidden. visibility === 'visible'
         * means that the element has a computed style, the visibility property other
         * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===
         * 'hidden' means the opposite of that.
         */
        #waitForVisibilityIfNeeded = (handle) => {
          if (!this.visibility) {
            return N;
          }
          return (() => {
            switch (this.visibility) {
              case "hidden":
                return se(() => {
                  return j(handle.isHidden());
                });
              case "visible":
                return se(() => {
                  return j(handle.isVisible());
                });
            }
          })().pipe(Ee(S), Ae({ delay: RETRY_DELAY }), gr());
        };
        _clone() {
          return new _NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);
        }
        _wait(options) {
          const signal = options?.signal;
          return se(() => {
            return j(this.#pageOrFrame.waitForSelector(this.#selector, {
              visible: false,
              timeout: this._timeout,
              signal
            }));
          }).pipe(J((value) => {
            return value !== null;
          }), wr(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));
        }
      };
      RaceLocator = class _RaceLocator extends Locator {
        static create(locators) {
          const array = checkLocatorArray(locators);
          return new _RaceLocator(array);
        }
        #locators;
        constructor(locators) {
          super();
          this.#locators = locators;
        }
        _clone() {
          return new _RaceLocator(this.#locators.map((locator) => {
            return locator.clone();
          })).copyOptions(this);
        }
        _wait(options) {
          return xe(...this.#locators.map((locator) => {
            return locator._wait(options);
          }));
        }
      };
      RETRY_DELAY = 100;
    }
  });

  // node_modules/@jspm/core/nodelibs/browser/child_process.js
  function unimplemented3() {
    throw new Error("Node.js child_process is not supported by JSPM core in the browser");
  }
  var init_child_process = __esm({
    "node_modules/@jspm/core/nodelibs/browser/child_process.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js
  var ScreenRecorder_exports = {};
  __export(ScreenRecorder_exports, {
    ScreenRecorder: () => ScreenRecorder
  });
  var import_debug, __runInitializers4, __esDecorate4, __setFunctionName, CRF_VALUE, DEFAULT_FPS, debugFfmpeg, ScreenRecorder;
  var init_ScreenRecorder = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_child_process();
      init_stream();
      import_debug = __toESM(require_browser(), 1);
      init_rxjs();
      init_CDPSession();
      init_util2();
      init_decorators();
      init_disposable();
      __runInitializers4 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate4 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __setFunctionName = function(f7, name2, prefix) {
        if (typeof name2 === "symbol")
          name2 = name2.description ? "[".concat(name2.description, "]") : "";
        return Object.defineProperty(f7, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
      };
      CRF_VALUE = 30;
      DEFAULT_FPS = 30;
      debugFfmpeg = (0, import_debug.default)("puppeteer:ffmpeg");
      ScreenRecorder = (() => {
        let _classSuper = PassThrough;
        let _instanceExtraInitializers = [];
        let _private_writeFrame_decorators;
        let _private_writeFrame_descriptor;
        let _stop_decorators;
        return class ScreenRecorder extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate4(this, _private_writeFrame_descriptor = { value: __setFunctionName(async function(buffer2) {
              const error = await new Promise((resolve3) => {
                this.#process.stdin.write(buffer2, resolve3);
              });
              if (error) {
                console.log(`ffmpeg failed to write: ${error.message}.`);
              }
            }, "#writeFrame") }, _private_writeFrame_decorators, { kind: "method", name: "#writeFrame", static: false, private: true, access: { has: (obj) => #writeFrame in obj, get: (obj) => obj.#writeFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate4(this, null, _stop_decorators, { kind: "method", name: "stop", static: false, private: false, access: { has: (obj) => "stop" in obj, get: (obj) => obj.stop }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          #page = (__runInitializers4(this, _instanceExtraInitializers), void 0);
          #process;
          #controller = new AbortController();
          #lastFrame;
          /**
           * @internal
           */
          constructor(page, width, height, { speed, scale, crop, format: format5, path: path2 } = {}) {
            super({ allowHalfOpen: false });
            path2 ??= "ffmpeg";
            const { error } = unimplemented3(path2);
            if (error) {
              throw error;
            }
            this.#process = unimplemented3(
              path2,
              // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.
              [
                ["-loglevel", "error"],
                // Reduces general buffering.
                ["-avioflags", "direct"],
                // Reduces initial buffering while analyzing input fps and other stats.
                [
                  "-fpsprobesize",
                  "0",
                  "-probesize",
                  "32",
                  "-analyzeduration",
                  "0",
                  "-fflags",
                  "nobuffer"
                ],
                // Forces input to be read from standard input, and forces png input
                // image format.
                ["-f", "image2pipe", "-c:v", "png", "-i", "pipe:0"],
                // Overwrite output and no audio.
                ["-y", "-an"],
                // This drastically reduces stalling when cpu is overbooked. By default
                // VP9 tries to use all available threads?
                ["-threads", "1"],
                // Specifies the frame rate we are giving ffmpeg.
                ["-framerate", `${DEFAULT_FPS}`],
                // Specifies the encoding and format we are using.
                this.#getFormatArgs(format5 ?? "webm"),
                // Disable bitrate.
                ["-b:v", "0"],
                // Filters to ensure the images are piped correctly.
                [
                  "-vf",
                  `${speed ? `setpts=${1 / speed}*PTS,` : ""}crop='min(${width},iw):min(${height},ih):0:0',pad=${width}:${height}:0:0${crop ? `,crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}` : ""}${scale ? `,scale=iw*${scale}:-1` : ""}`
                ],
                "pipe:1"
              ].flat(),
              { stdio: ["pipe", "pipe", "pipe"] }
            );
            this.#process.stdout.pipe(this);
            this.#process.stderr.on("data", (data) => {
              debugFfmpeg(data.toString("utf8"));
            });
            this.#page = page;
            const { client } = this.#page.mainFrame();
            client.once(CDPSessionEvent.Disconnected, () => {
              void this.stop().catch(debugError);
            });
            this.#lastFrame = ie(xr(client, "Page.screencastFrame").pipe(Pe((event) => {
              void client.send("Page.screencastFrameAck", {
                sessionId: event.sessionId
              });
            }), J((event) => {
              return event.metadata.timestamp !== void 0;
            }), k((event) => {
              return {
                buffer: Buffer2.from(event.data, "base64"),
                timestamp: event.metadata.timestamp
              };
            }), be(2, 1), ge(([{ timestamp: previousTimestamp, buffer: buffer2 }, { timestamp }]) => {
              return j(Array(Math.round(DEFAULT_FPS * Math.max(timestamp - previousTimestamp, 0))).fill(buffer2));
            }), k((buffer2) => {
              void this.#writeFrame(buffer2);
              return [buffer2, performance.now()];
            }), Te(xr(this.#controller.signal, "abort"))), { defaultValue: [Buffer2.from([]), performance.now()] });
          }
          #getFormatArgs(format5) {
            switch (format5) {
              case "webm":
                return [
                  // Sets the codec to use.
                  ["-c:v", "vp9"],
                  // Sets the format
                  ["-f", "webm"],
                  // Sets the quality. Lower the better.
                  ["-crf", `${CRF_VALUE}`],
                  // Sets the quality and how efficient the compression will be.
                  ["-deadline", "realtime", "-cpu-used", "8"]
                ].flat();
              case "gif":
                return [
                  // Sets the frame rate and uses a custom palette generated from the
                  // input.
                  [
                    "-vf",
                    "fps=5,split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse"
                  ],
                  // Sets the format
                  ["-f", "gif"]
                ].flat();
            }
          }
          get #writeFrame() {
            return _private_writeFrame_descriptor.value;
          }
          /**
           * Stops the recorder.
           *
           * @public
           */
          async stop() {
            if (this.#controller.signal.aborted) {
              return;
            }
            await this.#page._stopScreencast().catch(debugError);
            this.#controller.abort();
            const [buffer2, timestamp] = await this.#lastFrame;
            await Promise.all(Array(Math.max(1, Math.round(DEFAULT_FPS * (performance.now() - timestamp) / 1e3))).fill(buffer2).map(this.#writeFrame.bind(this)));
            this.#process.stdin.end();
            await new Promise((resolve3) => {
              this.#process.once("close", resolve3);
            });
          }
          /**
           * @internal
           */
          async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {
            await this.stop();
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js
  function setDefaultScreenshotOptions(options) {
    options.optimizeForSpeed ??= false;
    options.type ??= "png";
    options.fromSurface ??= true;
    options.fullPage ??= false;
    options.omitBackground ??= false;
    options.encoding ??= "binary";
    options.captureBeyondViewport ??= true;
  }
  function convertPrintParameterToInches(parameter, lengthUnit = "in") {
    if (typeof parameter === "undefined") {
      return void 0;
    }
    let pixels;
    if (isNumber3(parameter)) {
      pixels = parameter;
    } else if (isString3(parameter)) {
      const text = parameter;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unit in unitToPixels) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      assert2(!isNaN(value), "Failed to parse parameter value: " + text);
      pixels = value * unitToPixels[unit];
    } else {
      throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
    }
    return pixels / unitToPixels[lengthUnit];
  }
  function normalizeRectangle(clip) {
    return {
      ...clip,
      ...clip.width < 0 ? {
        x: clip.x + clip.width,
        width: -clip.width
      } : {
        x: clip.x,
        width: clip.width
      },
      ...clip.height < 0 ? {
        y: clip.y + clip.height,
        height: -clip.height
      } : {
        y: clip.y,
        height: clip.height
      }
    };
  }
  function roundRectangle(clip) {
    const x4 = Math.round(clip.x);
    const y6 = Math.round(clip.y);
    const width = Math.round(clip.width + clip.x - x4);
    const height = Math.round(clip.height + clip.y - y6);
    return { ...clip, x: x4, y: y6, width, height };
  }
  var __runInitializers5, __esDecorate5, __addDisposableResource8, __disposeResources8, Page, unitToPixels;
  var init_Page = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Page.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_Errors();
      init_EventEmitter();
      init_NetworkManagerEvents();
      init_PDFOptions();
      init_TimeoutSettings();
      init_util2();
      init_assert();
      init_decorators();
      init_disposable();
      init_locators();
      __runInitializers5 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate5 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __addDisposableResource8 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources8 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      Page = (() => {
        let _classSuper = EventEmitter;
        let _instanceExtraInitializers = [];
        let _screenshot_decorators;
        return class Page extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate5(this, null, _screenshot_decorators, { kind: "method", name: "screenshot", static: false, private: false, access: { has: (obj) => "screenshot" in obj, get: (obj) => obj.screenshot }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          /**
           * @internal
           */
          _isDragging = (__runInitializers5(this, _instanceExtraInitializers), false);
          /**
           * @internal
           */
          _timeoutSettings = new TimeoutSettings();
          #requestHandlers = /* @__PURE__ */ new WeakMap();
          /**
           * @internal
           */
          constructor() {
            super();
          }
          /**
           * Listen to page events.
           *
           * @remarks
           * This method exists to define event typings and handle proper wireup of
           * cooperative request interception. Actual event listening and dispatching is
           * delegated to {@link EventEmitter}.
           *
           * @internal
           */
          on(type, handler) {
            if (type !== "request") {
              return super.on(type, handler);
            }
            let wrapper = this.#requestHandlers.get(handler);
            if (wrapper === void 0) {
              wrapper = (event) => {
                event.enqueueInterceptAction(() => {
                  return handler(event);
                });
              };
              this.#requestHandlers.set(handler, wrapper);
            }
            return super.on(type, wrapper);
          }
          /**
           * @internal
           */
          off(type, handler) {
            if (type === "request") {
              handler = this.#requestHandlers.get(handler) || handler;
            }
            return super.off(type, handler);
          }
          locator(selectorOrFunc) {
            if (typeof selectorOrFunc === "string") {
              return NodeLocator.create(this, selectorOrFunc);
            } else {
              return FunctionLocator.create(this, selectorOrFunc);
            }
          }
          /**
           * A shortcut for {@link Locator.race} that does not require static imports.
           *
           * @internal
           */
          locatorRace(locators) {
            return Locator.race(locators);
          }
          /**
           * Runs `document.querySelector` within the page. If no element matches the
           * selector, the return value resolves to `null`.
           *
           * @param selector - A `selector` to query page for
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * to query page for.
           */
          async $(selector) {
            return await this.mainFrame().$(selector);
          }
          /**
           * The method runs `document.querySelectorAll` within the page. If no elements
           * match the selector, the return value resolves to `[]`.
           *
           * @param selector - A `selector` to query page for
           *
           * @remarks
           *
           * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.
           */
          async $$(selector) {
            return await this.mainFrame().$$(selector);
          }
          /**
           * @remarks
           *
           * The only difference between {@link Page.evaluate | page.evaluate} and
           * `page.evaluateHandle` is that `evaluateHandle` will return the value
           * wrapped in an in-page object.
           *
           * If the function passed to `page.evaluateHandle` returns a Promise, the
           * function will wait for the promise to resolve and return its value.
           *
           * You can pass a string instead of a function (although functions are
           * recommended as they are easier to debug and use with TypeScript):
           *
           * @example
           *
           * ```ts
           * const aHandle = await page.evaluateHandle('document');
           * ```
           *
           * @example
           * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:
           *
           * ```ts
           * const aHandle = await page.evaluateHandle(() => document.body);
           * const resultHandle = await page.evaluateHandle(
           *   body => body.innerHTML,
           *   aHandle
           * );
           * console.log(await resultHandle.jsonValue());
           * await resultHandle.dispose();
           * ```
           *
           * Most of the time this function returns a {@link JSHandle},
           * but if `pageFunction` returns a reference to an element,
           * you instead get an {@link ElementHandle} back:
           *
           * @example
           *
           * ```ts
           * const button = await page.evaluateHandle(() =>
           *   document.querySelector('button')
           * );
           * // can call `click` because `button` is an `ElementHandle`
           * await button.click();
           * ```
           *
           * The TypeScript definitions assume that `evaluateHandle` returns
           * a `JSHandle`, but if you know it's going to return an
           * `ElementHandle`, pass it as the generic argument:
           *
           * ```ts
           * const button = await page.evaluateHandle<ElementHandle>(...);
           * ```
           *
           * @param pageFunction - a function that is run within the page
           * @param args - arguments to be passed to the pageFunction
           */
          async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.mainFrame().evaluateHandle(pageFunction, ...args);
          }
          /**
           * This method runs `document.querySelector` within the page and passes the
           * result as the first argument to the `pageFunction`.
           *
           * @remarks
           *
           * If no element is found matching `selector`, the method will throw an error.
           *
           * If `pageFunction` returns a promise `$eval` will wait for the promise to
           * resolve and then return its value.
           *
           * @example
           *
           * ```ts
           * const searchValue = await page.$eval('#search', el => el.value);
           * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);
           * const html = await page.$eval('.main-container', el => el.outerHTML);
           * ```
           *
           * If you are using TypeScript, you may have to provide an explicit type to the
           * first argument of the `pageFunction`.
           * By default it is typed as `Element`, but you may need to provide a more
           * specific sub-type:
           *
           * @example
           *
           * ```ts
           * // if you don't provide HTMLInputElement here, TS will error
           * // as `value` is not on `Element`
           * const searchValue = await page.$eval(
           *   '#search',
           *   (el: HTMLInputElement) => el.value
           * );
           * ```
           *
           * The compiler should be able to infer the return type
           * from the `pageFunction` you provide. If it is unable to, you can use the generic
           * type to tell the compiler what return type you expect from `$eval`:
           *
           * @example
           *
           * ```ts
           * // The compiler can infer the return type in this case, but if it can't
           * // or if you want to be more explicit, provide it as the generic type.
           * const searchValue = await page.$eval<string>(
           *   '#search',
           *   (el: HTMLInputElement) => el.value
           * );
           * ```
           *
           * @param selector - the
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * to query for
           * @param pageFunction - the function to be evaluated in the page context.
           * Will be passed the result of `document.querySelector(selector)` as its
           * first argument.
           * @param args - any additional arguments to pass through to `pageFunction`.
           *
           * @returns The result of calling `pageFunction`. If it returns an element it
           * is wrapped in an {@link ElementHandle}, else the raw value itself is
           * returned.
           */
          async $eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
            return await this.mainFrame().$eval(selector, pageFunction, ...args);
          }
          /**
           * This method runs `Array.from(document.querySelectorAll(selector))` within
           * the page and passes the result as the first argument to the `pageFunction`.
           *
           * @remarks
           * If `pageFunction` returns a promise `$$eval` will wait for the promise to
           * resolve and then return its value.
           *
           * @example
           *
           * ```ts
           * // get the amount of divs on the page
           * const divCount = await page.$$eval('div', divs => divs.length);
           *
           * // get the text content of all the `.options` elements:
           * const options = await page.$$eval('div > span.options', options => {
           *   return options.map(option => option.textContent);
           * });
           * ```
           *
           * If you are using TypeScript, you may have to provide an explicit type to the
           * first argument of the `pageFunction`.
           * By default it is typed as `Element[]`, but you may need to provide a more
           * specific sub-type:
           *
           * @example
           *
           * ```ts
           * // if you don't provide HTMLInputElement here, TS will error
           * // as `value` is not on `Element`
           * await page.$$eval('input', (elements: HTMLInputElement[]) => {
           *   return elements.map(e => e.value);
           * });
           * ```
           *
           * The compiler should be able to infer the return type
           * from the `pageFunction` you provide. If it is unable to, you can use the generic
           * type to tell the compiler what return type you expect from `$$eval`:
           *
           * @example
           *
           * ```ts
           * // The compiler can infer the return type in this case, but if it can't
           * // or if you want to be more explicit, provide it as the generic type.
           * const allInputValues = await page.$$eval<string[]>(
           *   'input',
           *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)
           * );
           * ```
           *
           * @param selector - the
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * to query for
           * @param pageFunction - the function to be evaluated in the page context.
           * Will be passed the result of
           * `Array.from(document.querySelectorAll(selector))` as its first argument.
           * @param args - any additional arguments to pass through to `pageFunction`.
           *
           * @returns The result of calling `pageFunction`. If it returns an element it
           * is wrapped in an {@link ElementHandle}, else the raw value itself is
           * returned.
           */
          async $$eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
            return await this.mainFrame().$$eval(selector, pageFunction, ...args);
          }
          /**
           * The method evaluates the XPath expression relative to the page document as
           * its context node. If there are no such elements, the method resolves to an
           * empty array.
           *
           * @remarks
           * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.
           *
           * @param expression - Expression to evaluate
           */
          async $x(expression) {
            return await this.mainFrame().$x(expression);
          }
          /**
           * Adds a `<script>` tag into the page with the desired URL or content.
           *
           * @remarks
           * Shortcut for
           * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.
           *
           * @param options - Options for the script.
           * @returns An {@link ElementHandle | element handle} to the injected
           * `<script>` element.
           */
          async addScriptTag(options) {
            return await this.mainFrame().addScriptTag(options);
          }
          async addStyleTag(options) {
            return await this.mainFrame().addStyleTag(options);
          }
          /**
           * The page's URL.
           *
           * @remarks
           *
           * Shortcut for {@link Frame.url | page.mainFrame().url()}.
           */
          url() {
            return this.mainFrame().url();
          }
          /**
           * The full HTML contents of the page, including the DOCTYPE.
           */
          async content() {
            return await this.mainFrame().content();
          }
          /**
           * Set the content of the page.
           *
           * @param html - HTML markup to assign to the page.
           * @param options - Parameters that has some properties.
           *
           * @remarks
           *
           * The parameter `options` might have the following options.
           *
           * - `timeout` : Maximum time in milliseconds for resources to load, defaults
           *   to 30 seconds, pass `0` to disable timeout. The default value can be
           *   changed by using the {@link Page.setDefaultNavigationTimeout} or
           *   {@link Page.setDefaultTimeout} methods.
           *
           * - `waitUntil`: When to consider setting markup succeeded, defaults to
           *   `load`. Given an array of event strings, setting content is considered
           *   to be successful after all events have been fired. Events can be
           *   either:<br/>
           * - `load` : consider setting content to be finished when the `load` event
           *   is fired.<br/>
           * - `domcontentloaded` : consider setting content to be finished when the
           *   `DOMContentLoaded` event is fired.<br/>
           * - `networkidle0` : consider setting content to be finished when there are
           *   no more than 0 network connections for at least `500` ms.<br/>
           * - `networkidle2` : consider setting content to be finished when there are
           *   no more than 2 network connections for at least `500` ms.
           */
          async setContent(html, options) {
            await this.mainFrame().setContent(html, options);
          }
          /**
           * Navigates the page to the given `url`.
           *
           * @remarks
           *
           * Navigation to `about:blank` or navigation to the same URL with a different
           * hash will succeed and return `null`.
           *
           * :::warning
           *
           * Headless mode doesn't support navigation to a PDF document. See the {@link
           * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream
           * issue}.
           *
           * :::
           *
           * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.
           *
           * @param url - URL to navigate page to. The URL should include scheme, e.g.
           * `https://`
           * @param options - Options to configure waiting behavior.
           * @returns A promise which resolves to the main resource response. In case of
           * multiple redirects, the navigation will resolve with the response of the
           * last redirect.
           * @throws If:
           *
           * - there's an SSL error (e.g. in case of self-signed certificates).
           * - target URL is invalid.
           * - the timeout is exceeded during navigation.
           * - the remote server does not respond or is unreachable.
           * - the main resource failed to load.
           *
           * This method will not throw an error when any valid HTTP status code is
           * returned by the remote server, including 404 "Not Found" and 500 "Internal
           * Server Error". The status code for such responses can be retrieved by
           * calling {@link HTTPResponse.status}.
           */
          async goto(url, options) {
            return await this.mainFrame().goto(url, options);
          }
          /**
           * Waits for the page to navigate to a new URL or to reload. It is useful when
           * you run code that will indirectly cause the page to navigate.
           *
           * @example
           *
           * ```ts
           * const [response] = await Promise.all([
           *   page.waitForNavigation(), // The promise resolves after navigation has finished
           *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation
           * ]);
           * ```
           *
           * @remarks
           *
           * Usage of the
           * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}
           * to change the URL is considered a navigation.
           *
           * @param options - Navigation parameters which might have the following
           * properties:
           * @returns A `Promise` which resolves to the main resource response.
           *
           * - In case of multiple redirects, the navigation will resolve with the
           *   response of the last redirect.
           * - In case of navigation to a different anchor or navigation due to History
           *   API usage, the navigation will resolve with `null`.
           */
          async waitForNavigation(options = {}) {
            return await this.mainFrame().waitForNavigation(options);
          }
          /**
           * @internal
           */
          _waitForNetworkIdle(networkManager, idleTime, requestsInFlight = 0) {
            return he(xr(networkManager, NetworkManagerEvent.Request), xr(networkManager, NetworkManagerEvent.Response), xr(networkManager, NetworkManagerEvent.RequestFailed)).pipe(_e(void 0), J(() => {
              return networkManager.inFlightRequestsCount() <= requestsInFlight;
            }), Ie((v7) => {
              return ne(v7).pipe(Se(idleTime));
            }));
          }
          /**
           * Waits for a frame matching the given conditions to appear.
           *
           * @example
           *
           * ```ts
           * const frame = await page.waitForFrame(async frame => {
           *   return frame.name() === 'Test';
           * });
           * ```
           */
          async waitForFrame(urlOrPredicate, options = {}) {
            const { timeout: ms = this.getDefaultTimeout() } = options;
            if (isString3(urlOrPredicate)) {
              urlOrPredicate = (frame) => {
                return urlOrPredicate === frame.url();
              };
            }
            return await fe(he(xr(
              this,
              "frameattached"
              /* PageEvent.FrameAttached */
            ), xr(
              this,
              "framenavigated"
              /* PageEvent.FrameNavigated */
            ), j(this.frames())).pipe(Au(urlOrPredicate), Ee(), Oe(timeout(ms), xr(
              this,
              "close"
              /* PageEvent.Close */
            ).pipe(k(() => {
              throw new TargetCloseError("Page closed.");
            })))));
          }
          /**
           * Emulates a given device's metrics and user agent.
           *
           * To aid emulation, Puppeteer provides a list of known devices that can be
           * via {@link KnownDevices}.
           *
           * @remarks
           * This method is a shortcut for calling two methods:
           * {@link Page.setUserAgent} and {@link Page.setViewport}.
           *
           * This method will resize the page. A lot of websites don't expect phones to
           * change size, so you should emulate before navigating to the page.
           *
           * @example
           *
           * ```ts
           * import {KnownDevices} from 'puppeteer';
           * const iPhone = KnownDevices['iPhone 6'];
           *
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   await page.emulate(iPhone);
           *   await page.goto('https://www.google.com');
           *   // other actions...
           *   await browser.close();
           * })();
           * ```
           */
          async emulate(device) {
            await Promise.all([
              this.setUserAgent(device.userAgent),
              this.setViewport(device.viewport)
            ]);
          }
          /**
           * Evaluates a function in the page's context and returns the result.
           *
           * If the function passed to `page.evaluate` returns a Promise, the
           * function will wait for the promise to resolve and return its value.
           *
           * @example
           *
           * ```ts
           * const result = await frame.evaluate(() => {
           *   return Promise.resolve(8 * 7);
           * });
           * console.log(result); // prints "56"
           * ```
           *
           * You can pass a string instead of a function (although functions are
           * recommended as they are easier to debug and use with TypeScript):
           *
           * @example
           *
           * ```ts
           * const aHandle = await page.evaluate('1 + 2');
           * ```
           *
           * To get the best TypeScript experience, you should pass in as the
           * generic the type of `pageFunction`:
           *
           * ```ts
           * const aHandle = await page.evaluate(() => 2);
           * ```
           *
           * @example
           *
           * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed
           * as arguments to the `pageFunction`:
           *
           * ```ts
           * const bodyHandle = await page.$('body');
           * const html = await page.evaluate(body => body.innerHTML, bodyHandle);
           * await bodyHandle.dispose();
           * ```
           *
           * @param pageFunction - a function that is run within the page
           * @param args - arguments to be passed to the pageFunction
           *
           * @returns the return value of `pageFunction`.
           */
          async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.mainFrame().evaluate(pageFunction, ...args);
          }
          /**
           * @internal
           */
          async _maybeWriteBufferToFile(path2, buffer2) {
            if (!path2) {
              return;
            }
            const fs3 = await importFSPromises();
            await fs3.writeFile(path2, buffer2);
          }
          /**
           * Captures a screencast of this {@link Page | page}.
           *
           * @example
           * Recording a {@link Page | page}:
           *
           * ```
           * import puppeteer from 'puppeteer';
           *
           * // Launch a browser
           * const browser = await puppeteer.launch();
           *
           * // Create a new page
           * const page = await browser.newPage();
           *
           * // Go to your site.
           * await page.goto("https://www.example.com");
           *
           * // Start recording.
           * const recorder = await page.screencast({path: 'recording.webm'});
           *
           * // Do something.
           *
           * // Stop recording.
           * await recorder.stop();
           *
           * browser.close();
           * ```
           *
           * @param options - Configures screencast behavior.
           *
           * @experimental
           *
           * @remarks
           *
           * All recordings will be {@link https://www.webmproject.org/ | WebM} format using
           * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.
           *
           * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.
           */
          async screencast(options = {}) {
            const [{ ScreenRecorder: ScreenRecorder2 }, [width, height, devicePixelRatio]] = await Promise.all([
              Promise.resolve().then(() => (init_ScreenRecorder(), ScreenRecorder_exports)),
              this.#getNativePixelDimensions()
            ]);
            let crop;
            if (options.crop) {
              const { x: x4, y: y6, width: cropWidth, height: cropHeight } = roundRectangle(normalizeRectangle(options.crop));
              if (x4 < 0 || y6 < 0) {
                throw new Error(`\`crop.x\` and \`crop.y\` must be greater than or equal to 0.`);
              }
              if (cropWidth <= 0 || cropHeight <= 0) {
                throw new Error(`\`crop.height\` and \`crop.width\` must be greater than or equal to 0.`);
              }
              const viewportWidth = width / devicePixelRatio;
              const viewportHeight = height / devicePixelRatio;
              if (x4 + cropWidth > viewportWidth) {
                throw new Error(`\`crop.width\` cannot be larger than the viewport width (${viewportWidth}).`);
              }
              if (y6 + cropHeight > viewportHeight) {
                throw new Error(`\`crop.height\` cannot be larger than the viewport height (${viewportHeight}).`);
              }
              crop = {
                x: x4 * devicePixelRatio,
                y: y6 * devicePixelRatio,
                width: cropWidth * devicePixelRatio,
                height: cropHeight * devicePixelRatio
              };
            }
            if (options.speed !== void 0 && options.speed <= 0) {
              throw new Error(`\`speed\` must be greater than 0.`);
            }
            if (options.scale !== void 0 && options.scale <= 0) {
              throw new Error(`\`scale\` must be greater than 0.`);
            }
            const recorder = new ScreenRecorder2(this, width, height, {
              ...options,
              path: options.ffmpegPath,
              crop
            });
            try {
              await this._startScreencast();
            } catch (error) {
              void recorder.stop();
              throw error;
            }
            if (options.path) {
              const { createWriteStream: createWriteStream2 } = await Promise.resolve().then(() => (init_fs(), fs_exports));
              const stream = createWriteStream2(options.path, "binary");
              recorder.pipe(stream);
            }
            return recorder;
          }
          #screencastSessionCount = 0;
          #startScreencastPromise;
          /**
           * @internal
           */
          async _startScreencast() {
            ++this.#screencastSessionCount;
            if (!this.#startScreencastPromise) {
              this.#startScreencastPromise = this.mainFrame().client.send("Page.startScreencast", { format: "png" }).then(() => {
                return new Promise((resolve3) => {
                  return this.mainFrame().client.once("Page.screencastFrame", () => {
                    return resolve3();
                  });
                });
              });
            }
            await this.#startScreencastPromise;
          }
          /**
           * @internal
           */
          async _stopScreencast() {
            --this.#screencastSessionCount;
            if (!this.#startScreencastPromise) {
              return;
            }
            this.#startScreencastPromise = void 0;
            if (this.#screencastSessionCount === 0) {
              await this.mainFrame().client.send("Page.stopScreencast");
            }
          }
          /**
           * Gets the native, non-emulated dimensions of the viewport.
           */
          async #getNativePixelDimensions() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              const viewport = this.viewport();
              const stack = __addDisposableResource8(env_1, new DisposableStack(), false);
              if (viewport && viewport.deviceScaleFactor !== 0) {
                await this.setViewport({ ...viewport, deviceScaleFactor: 0 });
                stack.defer(() => {
                  void this.setViewport(viewport).catch(debugError);
                });
              }
              return await this.mainFrame().isolatedRealm().evaluate(() => {
                return [
                  window.visualViewport.width * window.devicePixelRatio,
                  window.visualViewport.height * window.devicePixelRatio,
                  window.devicePixelRatio
                ];
              });
            } catch (e_1) {
              env_1.error = e_1;
              env_1.hasError = true;
            } finally {
              __disposeResources8(env_1);
            }
          }
          async screenshot(userOptions = {}) {
            const env_2 = { stack: [], error: void 0, hasError: false };
            try {
              await this.bringToFront();
              const options = {
                ...userOptions,
                clip: userOptions.clip ? {
                  ...userOptions.clip
                } : void 0
              };
              if (options.type === void 0 && options.path !== void 0) {
                const filePath = options.path;
                const extension = filePath.slice(filePath.lastIndexOf(".") + 1).toLowerCase();
                switch (extension) {
                  case "png":
                    options.type = "png";
                    break;
                  case "jpeg":
                  case "jpg":
                    options.type = "jpeg";
                    break;
                  case "webp":
                    options.type = "webp";
                    break;
                }
              }
              if (options.quality !== void 0) {
                if (options.quality < 0 && options.quality > 100) {
                  throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);
                }
                if (options.type === void 0 || !["jpeg", "webp"].includes(options.type)) {
                  throw new Error(`${options.type ?? "png"} screenshots do not support 'quality'.`);
                }
              }
              if (options.clip) {
                if (options.clip.width <= 0) {
                  throw new Error("'width' in 'clip' must be positive.");
                }
                if (options.clip.height <= 0) {
                  throw new Error("'height' in 'clip' must be positive.");
                }
              }
              setDefaultScreenshotOptions(options);
              const stack = __addDisposableResource8(env_2, new AsyncDisposableStack(), true);
              if (options.clip) {
                if (options.fullPage) {
                  throw new Error("'clip' and 'fullPage' are mutually exclusive");
                }
                options.clip = roundRectangle(normalizeRectangle(options.clip));
              } else {
                if (options.fullPage) {
                  if (!options.captureBeyondViewport) {
                    const scrollDimensions = await this.mainFrame().isolatedRealm().evaluate(() => {
                      const element = document.documentElement;
                      return {
                        width: element.scrollWidth,
                        height: element.scrollHeight
                      };
                    });
                    const viewport = this.viewport();
                    await this.setViewport({
                      ...viewport,
                      ...scrollDimensions
                    });
                    stack.defer(async () => {
                      if (viewport) {
                        await this.setViewport(viewport).catch(debugError);
                      } else {
                        await this.setViewport({
                          width: 0,
                          height: 0
                        }).catch(debugError);
                      }
                    });
                  }
                } else {
                  options.captureBeyondViewport = false;
                }
              }
              const data = await this._screenshot(options);
              if (options.encoding === "base64") {
                return data;
              }
              const buffer2 = Buffer2.from(data, "base64");
              await this._maybeWriteBufferToFile(options.path, buffer2);
              return buffer2;
            } catch (e_2) {
              env_2.error = e_2;
              env_2.hasError = true;
            } finally {
              const result_1 = __disposeResources8(env_2);
              if (result_1)
                await result_1;
            }
          }
          /**
           * @internal
           */
          _getPDFOptions(options = {}, lengthUnit = "in") {
            const defaults = {
              scale: 1,
              displayHeaderFooter: false,
              headerTemplate: "",
              footerTemplate: "",
              printBackground: false,
              landscape: false,
              pageRanges: "",
              preferCSSPageSize: false,
              omitBackground: false,
              timeout: 3e4,
              tagged: false
            };
            let width = 8.5;
            let height = 11;
            if (options.format) {
              const format5 = paperFormats[options.format.toLowerCase()];
              assert2(format5, "Unknown paper format: " + options.format);
              width = format5.width;
              height = format5.height;
            } else {
              width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;
              height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;
            }
            const margin = {
              top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,
              left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,
              bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,
              right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0
            };
            return {
              ...defaults,
              ...options,
              width,
              height,
              margin
            };
          }
          /**
           * The page's title
           *
           * @remarks
           *
           * Shortcut for {@link Frame.title | page.mainFrame().title()}.
           */
          async title() {
            return await this.mainFrame().title();
          }
          /**
           * This method fetches an element with `selector`, scrolls it into view if
           * needed, and then uses {@link Page | Page.mouse} to click in the center of the
           * element. If there's no element matching `selector`, the method throws an
           * error.
           *
           * @remarks
           *
           * Bear in mind that if `click()` triggers a navigation event and
           * there's a separate `page.waitForNavigation()` promise to be resolved, you
           * may end up with a race condition that yields unexpected results. The
           * correct pattern for click and wait for navigation is the following:
           *
           * ```ts
           * const [response] = await Promise.all([
           *   page.waitForNavigation(waitOptions),
           *   page.click(selector, clickOptions),
           * ]);
           * ```
           *
           * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.
           * @param selector - A `selector` to search for element to click. If there are
           * multiple elements satisfying the `selector`, the first will be clicked
           * @param options - `Object`
           * @returns Promise which resolves when the element matching `selector` is
           * successfully clicked. The Promise will be rejected if there is no element
           * matching `selector`.
           */
          click(selector, options) {
            return this.mainFrame().click(selector, options);
          }
          /**
           * This method fetches an element with `selector` and focuses it. If there's no
           * element matching `selector`, the method throws an error.
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }
           * of an element to focus. If there are multiple elements satisfying the
           * selector, the first will be focused.
           * @returns Promise which resolves when the element matching selector is
           * successfully focused. The promise will be rejected if there is no element
           * matching selector.
           *
           * @remarks
           *
           * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.
           */
          focus(selector) {
            return this.mainFrame().focus(selector);
          }
          /**
           * This method fetches an element with `selector`, scrolls it into view if
           * needed, and then uses {@link Page | Page.mouse}
           * to hover over the center of the element.
           * If there's no element matching `selector`, the method throws an error.
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * to search for element to hover. If there are multiple elements satisfying
           * the selector, the first will be hovered.
           * @returns Promise which resolves when the element matching `selector` is
           * successfully hovered. Promise gets rejected if there's no element matching
           * `selector`.
           *
           * @remarks
           *
           * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.
           */
          hover(selector) {
            return this.mainFrame().hover(selector);
          }
          /**
           * Triggers a `change` and `input` event once all the provided options have been
           * selected. If there's no `<select>` element matching `selector`, the method
           * throws an error.
           *
           * @example
           *
           * ```ts
           * page.select('select#colors', 'blue'); // single selection
           * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections
           * ```
           *
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
           * to query the page for
           * @param values - Values of options to select. If the `<select>` has the
           * `multiple` attribute, all values are considered, otherwise only the first one
           * is taken into account.
           * @returns
           *
           * @remarks
           *
           * Shortcut for {@link Frame.select | page.mainFrame().select()}
           */
          select(selector, ...values) {
            return this.mainFrame().select(selector, ...values);
          }
          /**
           * This method fetches an element with `selector`, scrolls it into view if
           * needed, and then uses {@link Page | Page.touchscreen}
           * to tap in the center of the element.
           * If there's no element matching `selector`, the method throws an error.
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}
           * to search for element to tap. If there are multiple elements satisfying the
           * selector, the first will be tapped.
           *
           * @remarks
           *
           * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.
           */
          tap(selector) {
            return this.mainFrame().tap(selector);
          }
          /**
           * Sends a `keydown`, `keypress/input`, and `keyup` event for each character
           * in the text.
           *
           * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.
           * @example
           *
           * ```ts
           * await page.type('#mytextarea', 'Hello');
           * // Types instantly
           * await page.type('#mytextarea', 'World', {delay: 100});
           * // Types slower, like a user
           * ```
           *
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * of an element to type into. If there are multiple elements satisfying the
           * selector, the first will be used.
           * @param text - A text to type into a focused element.
           * @param options - have property `delay` which is the Time to wait between
           * key presses in milliseconds. Defaults to `0`.
           * @returns
           */
          type(selector, text, options) {
            return this.mainFrame().type(selector, text, options);
          }
          /**
           * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.
           *
           * Causes your script to wait for the given number of milliseconds.
           *
           * @remarks
           *
           * It's generally recommended to not wait for a number of seconds, but instead
           * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
           * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
           *
           * @example
           *
           * Wait for 1 second:
           *
           * ```ts
           * await page.waitForTimeout(1000);
           * ```
           *
           * @param milliseconds - the number of milliseconds to wait.
           */
          waitForTimeout(milliseconds) {
            return this.mainFrame().waitForTimeout(milliseconds);
          }
          /**
           * Wait for the `selector` to appear in page. If at the moment of calling the
           * method the `selector` already exists, the method will return immediately. If
           * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the
           * function will throw.
           *
           * @example
           * This method works across navigations:
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   let currentURL;
           *   page
           *     .waitForSelector('img')
           *     .then(() => console.log('First URL with image: ' + currentURL));
           *   for (currentURL of [
           *     'https://example.com',
           *     'https://google.com',
           *     'https://bbc.com',
           *   ]) {
           *     await page.goto(currentURL);
           *   }
           *   await browser.close();
           * })();
           * ```
           *
           * @param selector - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}
           * of an element to wait for
           * @param options - Optional waiting parameters
           * @returns Promise which resolves when element specified by selector string
           * is added to DOM. Resolves to `null` if waiting for hidden: `true` and
           * selector is not found in DOM.
           *
           * @remarks
           * The optional Parameter in Arguments `options` are:
           *
           * - `visible`: A boolean wait for element to be present in DOM and to be
           *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
           *   properties. Defaults to `false`.
           *
           * - `hidden`: Wait for element to not be found in the DOM or to be hidden,
           *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to
           *   `false`.
           *
           * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`
           *   (30 seconds). Pass `0` to disable timeout. The default value can be changed
           *   by using the {@link Page.setDefaultTimeout} method.
           */
          async waitForSelector(selector, options = {}) {
            return await this.mainFrame().waitForSelector(selector, options);
          }
          /**
           * Wait for the `xpath` to appear in page. If at the moment of calling the
           * method the `xpath` already exists, the method will return immediately. If
           * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the
           * function will throw.
           *
           * @example
           * This method works across navigation
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   let currentURL;
           *   page
           *     .waitForXPath('//img')
           *     .then(() => console.log('First URL with image: ' + currentURL));
           *   for (currentURL of [
           *     'https://example.com',
           *     'https://google.com',
           *     'https://bbc.com',
           *   ]) {
           *     await page.goto(currentURL);
           *   }
           *   await browser.close();
           * })();
           * ```
           *
           * @param xpath - A
           * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an
           * element to wait for
           * @param options - Optional waiting parameters
           * @returns Promise which resolves when element specified by xpath string is
           * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is
           * not found in DOM, otherwise resolves to `ElementHandle`.
           * @remarks
           * The optional Argument `options` have properties:
           *
           * - `visible`: A boolean to wait for element to be present in DOM and to be
           *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS
           *   properties. Defaults to `false`.
           *
           * - `hidden`: A boolean wait for element to not be found in the DOM or to be
           *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.
           *   Defaults to `false`.
           *
           * - `timeout`: A number which is maximum time to wait for in milliseconds.
           *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default
           *   value can be changed by using the {@link Page.setDefaultTimeout} method.
           */
          waitForXPath(xpath, options) {
            return this.mainFrame().waitForXPath(xpath, options);
          }
          /**
           * Waits for the provided function, `pageFunction`, to return a truthy value when
           * evaluated in the page's context.
           *
           * @example
           * {@link Page.waitForFunction} can be used to observe a viewport size change:
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   const watchDog = page.waitForFunction('window.innerWidth < 100');
           *   await page.setViewport({width: 50, height: 50});
           *   await watchDog;
           *   await browser.close();
           * })();
           * ```
           *
           * @example
           * Arguments can be passed from Node.js to `pageFunction`:
           *
           * ```ts
           * const selector = '.foo';
           * await page.waitForFunction(
           *   selector => !!document.querySelector(selector),
           *   {},
           *   selector
           * );
           * ```
           *
           * @example
           * The provided `pageFunction` can be asynchronous:
           *
           * ```ts
           * const username = 'github-username';
           * await page.waitForFunction(
           *   async username => {
           *     const githubResponse = await fetch(
           *       `https://api.github.com/users/${username}`
           *     );
           *     const githubUser = await githubResponse.json();
           *     // show the avatar
           *     const img = document.createElement('img');
           *     img.src = githubUser.avatar_url;
           *     // wait 3 seconds
           *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));
           *     img.remove();
           *   },
           *   {},
           *   username
           * );
           * ```
           *
           * @param pageFunction - Function to be evaluated in browser context until it returns a
           * truthy value.
           * @param options - Options for configuring waiting behavior.
           */
          waitForFunction(pageFunction, options, ...args) {
            return this.mainFrame().waitForFunction(pageFunction, options, ...args);
          }
          /** @internal */
          [(_screenshot_decorators = [guarded(function() {
            return this.browser();
          })], disposeSymbol)]() {
            return void this.close().catch(debugError);
          }
          /** @internal */
          [asyncDisposeSymbol]() {
            return this.close();
          }
        };
      })();
      unitToPixels = {
        px: 1,
        in: 96,
        cm: 37.8,
        mm: 3.78
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js
  var Accessibility, AXNode;
  var init_Accessibility = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Accessibility = class {
        #client;
        /**
         * @internal
         */
        constructor(client) {
          this.#client = client;
        }
        /**
         * @internal
         */
        updateClient(client) {
          this.#client = client;
        }
        /**
         * Captures the current state of the accessibility tree.
         * The returned object represents the root accessible node of the page.
         *
         * @remarks
         *
         * **NOTE** The Chrome accessibility tree contains nodes that go unused on
         * most platforms and by most screen readers. Puppeteer will discard them as
         * well for an easier to process tree, unless `interestingOnly` is set to
         * `false`.
         *
         * @example
         * An example of dumping the entire accessibility tree:
         *
         * ```ts
         * const snapshot = await page.accessibility.snapshot();
         * console.log(snapshot);
         * ```
         *
         * @example
         * An example of logging the focused node's name:
         *
         * ```ts
         * const snapshot = await page.accessibility.snapshot();
         * const node = findFocusedNode(snapshot);
         * console.log(node && node.name);
         *
         * function findFocusedNode(node) {
         *   if (node.focused) return node;
         *   for (const child of node.children || []) {
         *     const foundNode = findFocusedNode(child);
         *     return foundNode;
         *   }
         *   return null;
         * }
         * ```
         *
         * @returns An AXNode object representing the snapshot.
         */
        async snapshot(options = {}) {
          const { interestingOnly = true, root = null } = options;
          const { nodes } = await this.#client.send("Accessibility.getFullAXTree");
          let backendNodeId;
          if (root) {
            const { node } = await this.#client.send("DOM.describeNode", {
              objectId: root.id
            });
            backendNodeId = node.backendNodeId;
          }
          const defaultRoot = AXNode.createTree(nodes);
          let needle = defaultRoot;
          if (backendNodeId) {
            needle = defaultRoot.find((node) => {
              return node.payload.backendDOMNodeId === backendNodeId;
            });
            if (!needle) {
              return null;
            }
          }
          if (!interestingOnly) {
            return this.serializeTree(needle)[0] ?? null;
          }
          const interestingNodes = /* @__PURE__ */ new Set();
          this.collectInterestingNodes(interestingNodes, defaultRoot, false);
          if (!interestingNodes.has(needle)) {
            return null;
          }
          return this.serializeTree(needle, interestingNodes)[0] ?? null;
        }
        serializeTree(node, interestingNodes) {
          const children = [];
          for (const child of node.children) {
            children.push(...this.serializeTree(child, interestingNodes));
          }
          if (interestingNodes && !interestingNodes.has(node)) {
            return children;
          }
          const serializedNode = node.serialize();
          if (children.length) {
            serializedNode.children = children;
          }
          return [serializedNode];
        }
        collectInterestingNodes(collection, node, insideControl) {
          if (node.isInteresting(insideControl)) {
            collection.add(node);
          }
          if (node.isLeafNode()) {
            return;
          }
          insideControl = insideControl || node.isControl();
          for (const child of node.children) {
            this.collectInterestingNodes(collection, child, insideControl);
          }
        }
      };
      AXNode = class _AXNode {
        payload;
        children = [];
        #richlyEditable = false;
        #editable = false;
        #focusable = false;
        #hidden = false;
        #name;
        #role;
        #ignored;
        #cachedHasFocusableChild;
        constructor(payload) {
          this.payload = payload;
          this.#name = this.payload.name ? this.payload.name.value : "";
          this.#role = this.payload.role ? this.payload.role.value : "Unknown";
          this.#ignored = this.payload.ignored;
          for (const property of this.payload.properties || []) {
            if (property.name === "editable") {
              this.#richlyEditable = property.value.value === "richtext";
              this.#editable = true;
            }
            if (property.name === "focusable") {
              this.#focusable = property.value.value;
            }
            if (property.name === "hidden") {
              this.#hidden = property.value.value;
            }
          }
        }
        #isPlainTextField() {
          if (this.#richlyEditable) {
            return false;
          }
          if (this.#editable) {
            return true;
          }
          return this.#role === "textbox" || this.#role === "searchbox";
        }
        #isTextOnlyObject() {
          const role = this.#role;
          return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
        }
        #hasFocusableChild() {
          if (this.#cachedHasFocusableChild === void 0) {
            this.#cachedHasFocusableChild = false;
            for (const child of this.children) {
              if (child.#focusable || child.#hasFocusableChild()) {
                this.#cachedHasFocusableChild = true;
                break;
              }
            }
          }
          return this.#cachedHasFocusableChild;
        }
        find(predicate) {
          if (predicate(this)) {
            return this;
          }
          for (const child of this.children) {
            const result = child.find(predicate);
            if (result) {
              return result;
            }
          }
          return null;
        }
        isLeafNode() {
          if (!this.children.length) {
            return true;
          }
          if (this.#isPlainTextField() || this.#isTextOnlyObject()) {
            return true;
          }
          switch (this.#role) {
            case "doc-cover":
            case "graphics-symbol":
            case "img":
            case "image":
            case "Meter":
            case "scrollbar":
            case "slider":
            case "separator":
            case "progressbar":
              return true;
            default:
              break;
          }
          if (this.#hasFocusableChild()) {
            return false;
          }
          if (this.#focusable && this.#name) {
            return true;
          }
          if (this.#role === "heading" && this.#name) {
            return true;
          }
          return false;
        }
        isControl() {
          switch (this.#role) {
            case "button":
            case "checkbox":
            case "ColorWell":
            case "combobox":
            case "DisclosureTriangle":
            case "listbox":
            case "menu":
            case "menubar":
            case "menuitem":
            case "menuitemcheckbox":
            case "menuitemradio":
            case "radio":
            case "scrollbar":
            case "searchbox":
            case "slider":
            case "spinbutton":
            case "switch":
            case "tab":
            case "textbox":
            case "tree":
            case "treeitem":
              return true;
            default:
              return false;
          }
        }
        isInteresting(insideControl) {
          const role = this.#role;
          if (role === "Ignored" || this.#hidden || this.#ignored) {
            return false;
          }
          if (this.#focusable || this.#richlyEditable) {
            return true;
          }
          if (this.isControl()) {
            return true;
          }
          if (insideControl) {
            return false;
          }
          return this.isLeafNode() && !!this.#name;
        }
        serialize() {
          const properties = /* @__PURE__ */ new Map();
          for (const property of this.payload.properties || []) {
            properties.set(property.name.toLowerCase(), property.value.value);
          }
          if (this.payload.name) {
            properties.set("name", this.payload.name.value);
          }
          if (this.payload.value) {
            properties.set("value", this.payload.value.value);
          }
          if (this.payload.description) {
            properties.set("description", this.payload.description.value);
          }
          const node = {
            role: this.#role
          };
          const userStringProperties = [
            "name",
            "value",
            "description",
            "keyshortcuts",
            "roledescription",
            "valuetext"
          ];
          const getUserStringPropertyValue = (key) => {
            return properties.get(key);
          };
          for (const userStringProperty of userStringProperties) {
            if (!properties.has(userStringProperty)) {
              continue;
            }
            node[userStringProperty] = getUserStringPropertyValue(userStringProperty);
          }
          const booleanProperties = [
            "disabled",
            "expanded",
            "focused",
            "modal",
            "multiline",
            "multiselectable",
            "readonly",
            "required",
            "selected"
          ];
          const getBooleanPropertyValue = (key) => {
            return properties.get(key);
          };
          for (const booleanProperty of booleanProperties) {
            if (booleanProperty === "focused" && this.#role === "RootWebArea") {
              continue;
            }
            const value = getBooleanPropertyValue(booleanProperty);
            if (!value) {
              continue;
            }
            node[booleanProperty] = getBooleanPropertyValue(booleanProperty);
          }
          const tristateProperties = ["checked", "pressed"];
          for (const tristateProperty of tristateProperties) {
            if (!properties.has(tristateProperty)) {
              continue;
            }
            const value = properties.get(tristateProperty);
            node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
          }
          const numericalProperties = [
            "level",
            "valuemax",
            "valuemin"
          ];
          const getNumericalPropertyValue = (key) => {
            return properties.get(key);
          };
          for (const numericalProperty of numericalProperties) {
            if (!properties.has(numericalProperty)) {
              continue;
            }
            node[numericalProperty] = getNumericalPropertyValue(numericalProperty);
          }
          const tokenProperties = [
            "autocomplete",
            "haspopup",
            "invalid",
            "orientation"
          ];
          const getTokenPropertyValue = (key) => {
            return properties.get(key);
          };
          for (const tokenProperty of tokenProperties) {
            const value = getTokenPropertyValue(tokenProperty);
            if (!value || value === "false") {
              continue;
            }
            node[tokenProperty] = getTokenPropertyValue(tokenProperty);
          }
          return node;
        }
        static createTree(payloads) {
          const nodeById = /* @__PURE__ */ new Map();
          for (const payload of payloads) {
            nodeById.set(payload.nodeId, new _AXNode(payload));
          }
          for (const node of nodeById.values()) {
            for (const childId of node.payload.childIds || []) {
              const child = nodeById.get(childId);
              if (child) {
                node.children.push(child);
              }
            }
          }
          return nodeById.values().next().value;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js
  function convertToDisjointRanges(nestedRanges) {
    const points = [];
    for (const range of nestedRanges) {
      points.push({ offset: range.startOffset, type: 0, range });
      points.push({ offset: range.endOffset, type: 1, range });
    }
    points.sort((a8, b6) => {
      if (a8.offset !== b6.offset) {
        return a8.offset - b6.offset;
      }
      if (a8.type !== b6.type) {
        return b6.type - a8.type;
      }
      const aLength = a8.range.endOffset - a8.range.startOffset;
      const bLength = b6.range.endOffset - b6.range.startOffset;
      if (a8.type === 0) {
        return bLength - aLength;
      }
      return aLength - bLength;
    });
    const hitCountStack = [];
    const results = [];
    let lastOffset = 0;
    for (const point of points) {
      if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
        const lastResult = results[results.length - 1];
        if (lastResult && lastResult.end === lastOffset) {
          lastResult.end = point.offset;
        } else {
          results.push({ start: lastOffset, end: point.offset });
        }
      }
      lastOffset = point.offset;
      if (point.type === 0) {
        hitCountStack.push(point.range.count);
      } else {
        hitCountStack.pop();
      }
    }
    return results.filter((range) => {
      return range.end - range.start > 0;
    });
  }
  var Coverage, JSCoverage, CSSCoverage;
  var init_Coverage = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_EventEmitter();
      init_util2();
      init_assert();
      init_disposable();
      Coverage = class {
        #jsCoverage;
        #cssCoverage;
        constructor(client) {
          this.#jsCoverage = new JSCoverage(client);
          this.#cssCoverage = new CSSCoverage(client);
        }
        /**
         * @internal
         */
        updateClient(client) {
          this.#jsCoverage.updateClient(client);
          this.#cssCoverage.updateClient(client);
        }
        /**
         * @param options - Set of configurable options for coverage defaults to
         * `resetOnNavigation : true, reportAnonymousScripts : false,`
         * `includeRawScriptCoverage : false, useBlockCoverage : true`
         * @returns Promise that resolves when coverage is started.
         *
         * @remarks
         * Anonymous scripts are ones that don't have an associated url. These are
         * scripts that are dynamically created on the page using `eval` or
         * `new Function`. If `reportAnonymousScripts` is set to `true`, anonymous
         * scripts URL will start with `debugger://VM` (unless a magic //# sourceURL
         * comment is present, in which case that will the be URL).
         */
        async startJSCoverage(options = {}) {
          return await this.#jsCoverage.start(options);
        }
        /**
         * Promise that resolves to the array of coverage reports for
         * all scripts.
         *
         * @remarks
         * JavaScript Coverage doesn't include anonymous scripts by default.
         * However, scripts with sourceURLs are reported.
         */
        async stopJSCoverage() {
          return await this.#jsCoverage.stop();
        }
        /**
         * @param options - Set of configurable options for coverage, defaults to
         * `resetOnNavigation : true`
         * @returns Promise that resolves when coverage is started.
         */
        async startCSSCoverage(options = {}) {
          return await this.#cssCoverage.start(options);
        }
        /**
         * Promise that resolves to the array of coverage reports
         * for all stylesheets.
         *
         * @remarks
         * CSS Coverage doesn't include dynamically injected style tags
         * without sourceURLs.
         */
        async stopCSSCoverage() {
          return await this.#cssCoverage.stop();
        }
      };
      JSCoverage = class {
        #client;
        #enabled = false;
        #scriptURLs = /* @__PURE__ */ new Map();
        #scriptSources = /* @__PURE__ */ new Map();
        #subscriptions;
        #resetOnNavigation = false;
        #reportAnonymousScripts = false;
        #includeRawScriptCoverage = false;
        constructor(client) {
          this.#client = client;
        }
        /**
         * @internal
         */
        updateClient(client) {
          this.#client = client;
        }
        async start(options = {}) {
          assert2(!this.#enabled, "JSCoverage is already enabled");
          const { resetOnNavigation = true, reportAnonymousScripts = false, includeRawScriptCoverage = false, useBlockCoverage = true } = options;
          this.#resetOnNavigation = resetOnNavigation;
          this.#reportAnonymousScripts = reportAnonymousScripts;
          this.#includeRawScriptCoverage = includeRawScriptCoverage;
          this.#enabled = true;
          this.#scriptURLs.clear();
          this.#scriptSources.clear();
          this.#subscriptions = new DisposableStack();
          this.#subscriptions.use(new EventSubscription(this.#client, "Debugger.scriptParsed", this.#onScriptParsed.bind(this)));
          this.#subscriptions.use(new EventSubscription(this.#client, "Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this)));
          await Promise.all([
            this.#client.send("Profiler.enable"),
            this.#client.send("Profiler.startPreciseCoverage", {
              callCount: this.#includeRawScriptCoverage,
              detailed: useBlockCoverage
            }),
            this.#client.send("Debugger.enable"),
            this.#client.send("Debugger.setSkipAllPauses", { skip: true })
          ]);
        }
        #onExecutionContextsCleared() {
          if (!this.#resetOnNavigation) {
            return;
          }
          this.#scriptURLs.clear();
          this.#scriptSources.clear();
        }
        async #onScriptParsed(event) {
          if (PuppeteerURL.isPuppeteerURL(event.url)) {
            return;
          }
          if (!event.url && !this.#reportAnonymousScripts) {
            return;
          }
          try {
            const response = await this.#client.send("Debugger.getScriptSource", {
              scriptId: event.scriptId
            });
            this.#scriptURLs.set(event.scriptId, event.url);
            this.#scriptSources.set(event.scriptId, response.scriptSource);
          } catch (error) {
            debugError(error);
          }
        }
        async stop() {
          assert2(this.#enabled, "JSCoverage is not enabled");
          this.#enabled = false;
          const result = await Promise.all([
            this.#client.send("Profiler.takePreciseCoverage"),
            this.#client.send("Profiler.stopPreciseCoverage"),
            this.#client.send("Profiler.disable"),
            this.#client.send("Debugger.disable")
          ]);
          this.#subscriptions?.dispose();
          const coverage = [];
          const profileResponse = result[0];
          for (const entry of profileResponse.result) {
            let url = this.#scriptURLs.get(entry.scriptId);
            if (!url && this.#reportAnonymousScripts) {
              url = "debugger://VM" + entry.scriptId;
            }
            const text = this.#scriptSources.get(entry.scriptId);
            if (text === void 0 || url === void 0) {
              continue;
            }
            const flattenRanges = [];
            for (const func of entry.functions) {
              flattenRanges.push(...func.ranges);
            }
            const ranges = convertToDisjointRanges(flattenRanges);
            if (!this.#includeRawScriptCoverage) {
              coverage.push({ url, ranges, text });
            } else {
              coverage.push({ url, ranges, text, rawScriptCoverage: entry });
            }
          }
          return coverage;
        }
      };
      CSSCoverage = class {
        #client;
        #enabled = false;
        #stylesheetURLs = /* @__PURE__ */ new Map();
        #stylesheetSources = /* @__PURE__ */ new Map();
        #eventListeners;
        #resetOnNavigation = false;
        constructor(client) {
          this.#client = client;
        }
        /**
         * @internal
         */
        updateClient(client) {
          this.#client = client;
        }
        async start(options = {}) {
          assert2(!this.#enabled, "CSSCoverage is already enabled");
          const { resetOnNavigation = true } = options;
          this.#resetOnNavigation = resetOnNavigation;
          this.#enabled = true;
          this.#stylesheetURLs.clear();
          this.#stylesheetSources.clear();
          this.#eventListeners = new DisposableStack();
          this.#eventListeners.use(new EventSubscription(this.#client, "CSS.styleSheetAdded", this.#onStyleSheet.bind(this)));
          this.#eventListeners.use(new EventSubscription(this.#client, "Runtime.executionContextsCleared", this.#onExecutionContextsCleared.bind(this)));
          await Promise.all([
            this.#client.send("DOM.enable"),
            this.#client.send("CSS.enable"),
            this.#client.send("CSS.startRuleUsageTracking")
          ]);
        }
        #onExecutionContextsCleared() {
          if (!this.#resetOnNavigation) {
            return;
          }
          this.#stylesheetURLs.clear();
          this.#stylesheetSources.clear();
        }
        async #onStyleSheet(event) {
          const header = event.header;
          if (!header.sourceURL) {
            return;
          }
          try {
            const response = await this.#client.send("CSS.getStyleSheetText", {
              styleSheetId: header.styleSheetId
            });
            this.#stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this.#stylesheetSources.set(header.styleSheetId, response.text);
          } catch (error) {
            debugError(error);
          }
        }
        async stop() {
          assert2(this.#enabled, "CSSCoverage is not enabled");
          this.#enabled = false;
          const ruleTrackingResponse = await this.#client.send("CSS.stopRuleUsageTracking");
          await Promise.all([
            this.#client.send("CSS.disable"),
            this.#client.send("DOM.disable")
          ]);
          this.#eventListeners?.dispose();
          const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
          for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
              ranges = [];
              styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
              startOffset: entry.startOffset,
              endOffset: entry.endOffset,
              count: entry.used ? 1 : 0
            });
          }
          const coverage = [];
          for (const styleSheetId of this.#stylesheetURLs.keys()) {
            const url = this.#stylesheetURLs.get(styleSheetId);
            assert2(typeof url !== "undefined", `Stylesheet URL is undefined (styleSheetId=${styleSheetId})`);
            const text = this.#stylesheetSources.get(styleSheetId);
            assert2(typeof text !== "undefined", `Stylesheet text is undefined (styleSheetId=${styleSheetId})`);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
          }
          return coverage;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js
  var __runInitializers6, __esDecorate6, __setFunctionName2, EmulatedState, EmulationManager;
  var init_EmulationManager = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/EmulationManager.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_CDPSession();
      init_util2();
      init_assert();
      init_decorators();
      init_ErrorLike();
      __runInitializers6 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate6 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __setFunctionName2 = function(f7, name2, prefix) {
        if (typeof name2 === "symbol")
          name2 = name2.description ? "[".concat(name2.description, "]") : "";
        return Object.defineProperty(f7, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
      };
      EmulatedState = class {
        #state;
        #clientProvider;
        #updater;
        constructor(initialState, clientProvider, updater) {
          this.#state = initialState;
          this.#clientProvider = clientProvider;
          this.#updater = updater;
          this.#clientProvider.registerState(this);
        }
        async setState(state) {
          this.#state = state;
          await this.sync();
        }
        get state() {
          return this.#state;
        }
        async sync() {
          await Promise.all(this.#clientProvider.clients().map((client) => {
            return this.#updater(client, this.#state);
          }));
        }
      };
      EmulationManager = (() => {
        let _instanceExtraInitializers = [];
        let _private_applyViewport_decorators;
        let _private_applyViewport_descriptor;
        let _private_emulateIdleState_decorators;
        let _private_emulateIdleState_descriptor;
        let _private_emulateTimezone_decorators;
        let _private_emulateTimezone_descriptor;
        let _private_emulateVisionDeficiency_decorators;
        let _private_emulateVisionDeficiency_descriptor;
        let _private_emulateCpuThrottling_decorators;
        let _private_emulateCpuThrottling_descriptor;
        let _private_emulateMediaFeatures_decorators;
        let _private_emulateMediaFeatures_descriptor;
        let _private_emulateMediaType_decorators;
        let _private_emulateMediaType_descriptor;
        let _private_setGeolocation_decorators;
        let _private_setGeolocation_descriptor;
        let _private_setDefaultBackgroundColor_decorators;
        let _private_setDefaultBackgroundColor_descriptor;
        let _private_setJavaScriptEnabled_decorators;
        let _private_setJavaScriptEnabled_descriptor;
        return class EmulationManager {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
            _private_applyViewport_decorators = [invokeAtMostOnceForArguments];
            _private_emulateIdleState_decorators = [invokeAtMostOnceForArguments];
            _private_emulateTimezone_decorators = [invokeAtMostOnceForArguments];
            _private_emulateVisionDeficiency_decorators = [invokeAtMostOnceForArguments];
            _private_emulateCpuThrottling_decorators = [invokeAtMostOnceForArguments];
            _private_emulateMediaFeatures_decorators = [invokeAtMostOnceForArguments];
            _private_emulateMediaType_decorators = [invokeAtMostOnceForArguments];
            _private_setGeolocation_decorators = [invokeAtMostOnceForArguments];
            _private_setDefaultBackgroundColor_decorators = [invokeAtMostOnceForArguments];
            _private_setJavaScriptEnabled_decorators = [invokeAtMostOnceForArguments];
            __esDecorate6(this, _private_applyViewport_descriptor = { value: __setFunctionName2(async function(client, viewportState) {
              if (!viewportState.viewport) {
                return;
              }
              const { viewport } = viewportState;
              const mobile = viewport.isMobile || false;
              const width = viewport.width;
              const height = viewport.height;
              const deviceScaleFactor = viewport.deviceScaleFactor ?? 1;
              const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
              const hasTouch = viewport.hasTouch || false;
              await Promise.all([
                client.send("Emulation.setDeviceMetricsOverride", {
                  mobile,
                  width,
                  height,
                  deviceScaleFactor,
                  screenOrientation
                }),
                client.send("Emulation.setTouchEmulationEnabled", {
                  enabled: hasTouch
                })
              ]);
            }, "#applyViewport") }, _private_applyViewport_decorators, { kind: "method", name: "#applyViewport", static: false, private: true, access: { has: (obj) => #applyViewport in obj, get: (obj) => obj.#applyViewport }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateIdleState_descriptor = { value: __setFunctionName2(async function(client, idleStateState) {
              if (!idleStateState.active) {
                return;
              }
              if (idleStateState.overrides) {
                await client.send("Emulation.setIdleOverride", {
                  isUserActive: idleStateState.overrides.isUserActive,
                  isScreenUnlocked: idleStateState.overrides.isScreenUnlocked
                });
              } else {
                await client.send("Emulation.clearIdleOverride");
              }
            }, "#emulateIdleState") }, _private_emulateIdleState_decorators, { kind: "method", name: "#emulateIdleState", static: false, private: true, access: { has: (obj) => #emulateIdleState in obj, get: (obj) => obj.#emulateIdleState }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateTimezone_descriptor = { value: __setFunctionName2(async function(client, timezoneState) {
              if (!timezoneState.active) {
                return;
              }
              try {
                await client.send("Emulation.setTimezoneOverride", {
                  timezoneId: timezoneState.timezoneId || ""
                });
              } catch (error) {
                if (isErrorLike(error) && error.message.includes("Invalid timezone")) {
                  throw new Error(`Invalid timezone ID: ${timezoneState.timezoneId}`);
                }
                throw error;
              }
            }, "#emulateTimezone") }, _private_emulateTimezone_decorators, { kind: "method", name: "#emulateTimezone", static: false, private: true, access: { has: (obj) => #emulateTimezone in obj, get: (obj) => obj.#emulateTimezone }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateVisionDeficiency_descriptor = { value: __setFunctionName2(async function(client, visionDeficiency) {
              if (!visionDeficiency.active) {
                return;
              }
              await client.send("Emulation.setEmulatedVisionDeficiency", {
                type: visionDeficiency.visionDeficiency || "none"
              });
            }, "#emulateVisionDeficiency") }, _private_emulateVisionDeficiency_decorators, { kind: "method", name: "#emulateVisionDeficiency", static: false, private: true, access: { has: (obj) => #emulateVisionDeficiency in obj, get: (obj) => obj.#emulateVisionDeficiency }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateCpuThrottling_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setCPUThrottlingRate", {
                rate: state.factor ?? 1
              });
            }, "#emulateCpuThrottling") }, _private_emulateCpuThrottling_decorators, { kind: "method", name: "#emulateCpuThrottling", static: false, private: true, access: { has: (obj) => #emulateCpuThrottling in obj, get: (obj) => obj.#emulateCpuThrottling }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateMediaFeatures_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setEmulatedMedia", {
                features: state.mediaFeatures
              });
            }, "#emulateMediaFeatures") }, _private_emulateMediaFeatures_decorators, { kind: "method", name: "#emulateMediaFeatures", static: false, private: true, access: { has: (obj) => #emulateMediaFeatures in obj, get: (obj) => obj.#emulateMediaFeatures }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_emulateMediaType_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setEmulatedMedia", {
                media: state.type || ""
              });
            }, "#emulateMediaType") }, _private_emulateMediaType_decorators, { kind: "method", name: "#emulateMediaType", static: false, private: true, access: { has: (obj) => #emulateMediaType in obj, get: (obj) => obj.#emulateMediaType }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_setGeolocation_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setGeolocationOverride", state.geoLocation ? {
                longitude: state.geoLocation.longitude,
                latitude: state.geoLocation.latitude,
                accuracy: state.geoLocation.accuracy
              } : void 0);
            }, "#setGeolocation") }, _private_setGeolocation_decorators, { kind: "method", name: "#setGeolocation", static: false, private: true, access: { has: (obj) => #setGeolocation in obj, get: (obj) => obj.#setGeolocation }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_setDefaultBackgroundColor_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setDefaultBackgroundColorOverride", {
                color: state.color
              });
            }, "#setDefaultBackgroundColor") }, _private_setDefaultBackgroundColor_decorators, { kind: "method", name: "#setDefaultBackgroundColor", static: false, private: true, access: { has: (obj) => #setDefaultBackgroundColor in obj, get: (obj) => obj.#setDefaultBackgroundColor }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate6(this, _private_setJavaScriptEnabled_descriptor = { value: __setFunctionName2(async function(client, state) {
              if (!state.active) {
                return;
              }
              await client.send("Emulation.setScriptExecutionDisabled", {
                value: !state.javaScriptEnabled
              });
            }, "#setJavaScriptEnabled") }, _private_setJavaScriptEnabled_decorators, { kind: "method", name: "#setJavaScriptEnabled", static: false, private: true, access: { has: (obj) => #setJavaScriptEnabled in obj, get: (obj) => obj.#setJavaScriptEnabled }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          #client = (__runInitializers6(this, _instanceExtraInitializers), void 0);
          #emulatingMobile = false;
          #hasTouch = false;
          #states = [];
          #viewportState = new EmulatedState({
            active: false
          }, this, this.#applyViewport);
          #idleOverridesState = new EmulatedState({
            active: false
          }, this, this.#emulateIdleState);
          #timezoneState = new EmulatedState({
            active: false
          }, this, this.#emulateTimezone);
          #visionDeficiencyState = new EmulatedState({
            active: false
          }, this, this.#emulateVisionDeficiency);
          #cpuThrottlingState = new EmulatedState({
            active: false
          }, this, this.#emulateCpuThrottling);
          #mediaFeaturesState = new EmulatedState({
            active: false
          }, this, this.#emulateMediaFeatures);
          #mediaTypeState = new EmulatedState({
            active: false
          }, this, this.#emulateMediaType);
          #geoLocationState = new EmulatedState({
            active: false
          }, this, this.#setGeolocation);
          #defaultBackgroundColorState = new EmulatedState({
            active: false
          }, this, this.#setDefaultBackgroundColor);
          #javascriptEnabledState = new EmulatedState({
            javaScriptEnabled: true,
            active: false
          }, this, this.#setJavaScriptEnabled);
          #secondaryClients = /* @__PURE__ */ new Set();
          constructor(client) {
            this.#client = client;
          }
          updateClient(client) {
            this.#client = client;
            this.#secondaryClients.delete(client);
          }
          registerState(state) {
            this.#states.push(state);
          }
          clients() {
            return [this.#client, ...Array.from(this.#secondaryClients)];
          }
          async registerSpeculativeSession(client) {
            this.#secondaryClients.add(client);
            client.once(CDPSessionEvent.Disconnected, () => {
              this.#secondaryClients.delete(client);
            });
            void Promise.all(this.#states.map((s7) => {
              return s7.sync().catch(debugError);
            }));
          }
          get javascriptEnabled() {
            return this.#javascriptEnabledState.state.javaScriptEnabled;
          }
          async emulateViewport(viewport) {
            await this.#viewportState.setState({
              viewport,
              active: true
            });
            const mobile = viewport.isMobile || false;
            const hasTouch = viewport.hasTouch || false;
            const reloadNeeded = this.#emulatingMobile !== mobile || this.#hasTouch !== hasTouch;
            this.#emulatingMobile = mobile;
            this.#hasTouch = hasTouch;
            return reloadNeeded;
          }
          get #applyViewport() {
            return _private_applyViewport_descriptor.value;
          }
          async emulateIdleState(overrides) {
            await this.#idleOverridesState.setState({
              active: true,
              overrides
            });
          }
          get #emulateIdleState() {
            return _private_emulateIdleState_descriptor.value;
          }
          get #emulateTimezone() {
            return _private_emulateTimezone_descriptor.value;
          }
          async emulateTimezone(timezoneId) {
            await this.#timezoneState.setState({
              timezoneId,
              active: true
            });
          }
          get #emulateVisionDeficiency() {
            return _private_emulateVisionDeficiency_descriptor.value;
          }
          async emulateVisionDeficiency(type) {
            const visionDeficiencies = /* @__PURE__ */ new Set([
              "none",
              "achromatopsia",
              "blurredVision",
              "deuteranopia",
              "protanopia",
              "tritanopia"
            ]);
            assert2(!type || visionDeficiencies.has(type), `Unsupported vision deficiency: ${type}`);
            await this.#visionDeficiencyState.setState({
              active: true,
              visionDeficiency: type
            });
          }
          get #emulateCpuThrottling() {
            return _private_emulateCpuThrottling_descriptor.value;
          }
          async emulateCPUThrottling(factor) {
            assert2(factor === null || factor >= 1, "Throttling rate should be greater or equal to 1");
            await this.#cpuThrottlingState.setState({
              active: true,
              factor: factor ?? void 0
            });
          }
          get #emulateMediaFeatures() {
            return _private_emulateMediaFeatures_descriptor.value;
          }
          async emulateMediaFeatures(features2) {
            if (Array.isArray(features2)) {
              for (const mediaFeature of features2) {
                const name2 = mediaFeature.name;
                assert2(/^(?:prefers-(?:color-scheme|reduced-motion)|color-gamut)$/.test(name2), "Unsupported media feature: " + name2);
              }
            }
            await this.#mediaFeaturesState.setState({
              active: true,
              mediaFeatures: features2
            });
          }
          get #emulateMediaType() {
            return _private_emulateMediaType_descriptor.value;
          }
          async emulateMediaType(type) {
            assert2(type === "screen" || type === "print" || (type ?? void 0) === void 0, "Unsupported media type: " + type);
            await this.#mediaTypeState.setState({
              type,
              active: true
            });
          }
          get #setGeolocation() {
            return _private_setGeolocation_descriptor.value;
          }
          async setGeolocation(options) {
            const { longitude, latitude, accuracy = 0 } = options;
            if (longitude < -180 || longitude > 180) {
              throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
            }
            if (latitude < -90 || latitude > 90) {
              throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
            }
            if (accuracy < 0) {
              throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
            }
            await this.#geoLocationState.setState({
              active: true,
              geoLocation: {
                longitude,
                latitude,
                accuracy
              }
            });
          }
          get #setDefaultBackgroundColor() {
            return _private_setDefaultBackgroundColor_descriptor.value;
          }
          /**
           * Resets default white background
           */
          async resetDefaultBackgroundColor() {
            await this.#defaultBackgroundColorState.setState({
              active: true,
              color: void 0
            });
          }
          /**
           * Hides default white background
           */
          async setTransparentBackgroundColor() {
            await this.#defaultBackgroundColorState.setState({
              active: true,
              color: { r: 0, g: 0, b: 0, a: 0 }
            });
          }
          get #setJavaScriptEnabled() {
            return _private_setJavaScriptEnabled_descriptor.value;
          }
          async setJavaScriptEnabled(enabled) {
            await this.#javascriptEnabledState.setState({
              active: true,
              javaScriptEnabled: enabled
            });
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js
  var FrameTree;
  var init_FrameTree = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Deferred();
      FrameTree = class {
        #frames = /* @__PURE__ */ new Map();
        // frameID -> parentFrameID
        #parentIds = /* @__PURE__ */ new Map();
        // frameID -> childFrameIDs
        #childIds = /* @__PURE__ */ new Map();
        #mainFrame;
        #waitRequests = /* @__PURE__ */ new Map();
        getMainFrame() {
          return this.#mainFrame;
        }
        getById(frameId) {
          return this.#frames.get(frameId);
        }
        /**
         * Returns a promise that is resolved once the frame with
         * the given ID is added to the tree.
         */
        waitForFrame(frameId) {
          const frame = this.getById(frameId);
          if (frame) {
            return Promise.resolve(frame);
          }
          const deferred = Deferred.create();
          const callbacks = this.#waitRequests.get(frameId) || /* @__PURE__ */ new Set();
          callbacks.add(deferred);
          return deferred.valueOrThrow();
        }
        frames() {
          return Array.from(this.#frames.values());
        }
        addFrame(frame) {
          this.#frames.set(frame._id, frame);
          if (frame._parentId) {
            this.#parentIds.set(frame._id, frame._parentId);
            if (!this.#childIds.has(frame._parentId)) {
              this.#childIds.set(frame._parentId, /* @__PURE__ */ new Set());
            }
            this.#childIds.get(frame._parentId).add(frame._id);
          } else if (!this.#mainFrame) {
            this.#mainFrame = frame;
          }
          this.#waitRequests.get(frame._id)?.forEach((request) => {
            return request.resolve(frame);
          });
        }
        removeFrame(frame) {
          this.#frames.delete(frame._id);
          this.#parentIds.delete(frame._id);
          if (frame._parentId) {
            this.#childIds.get(frame._parentId)?.delete(frame._id);
          } else {
            this.#mainFrame = void 0;
          }
        }
        childFrames(frameId) {
          const childIds = this.#childIds.get(frameId);
          if (!childIds) {
            return [];
          }
          return Array.from(childIds).map((id) => {
            return this.getById(id);
          }).filter((frame) => {
            return frame !== void 0;
          });
        }
        parentFrame(frameId) {
          const parentId = this.#parentIds.get(frameId);
          return parentId ? this.getById(parentId) : void 0;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js
  var Tracing;
  var init_Tracing = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Tracing.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_util2();
      init_assert();
      init_Deferred();
      init_ErrorLike();
      Tracing = class {
        #client;
        #recording = false;
        #path;
        /**
         * @internal
         */
        constructor(client) {
          this.#client = client;
        }
        /**
         * @internal
         */
        updateClient(client) {
          this.#client = client;
        }
        /**
         * Starts a trace for the current page.
         * @remarks
         * Only one trace can be active at a time per browser.
         *
         * @param options - Optional `TracingOptions`.
         */
        async start(options = {}) {
          assert2(!this.#recording, "Cannot start recording trace while already recording trace.");
          const defaultCategories = [
            "-*",
            "devtools.timeline",
            "v8.execute",
            "disabled-by-default-devtools.timeline",
            "disabled-by-default-devtools.timeline.frame",
            "toplevel",
            "blink.console",
            "blink.user_timing",
            "latencyInfo",
            "disabled-by-default-devtools.timeline.stack",
            "disabled-by-default-v8.cpu_profiler"
          ];
          const { path: path2, screenshots = false, categories = defaultCategories } = options;
          if (screenshots) {
            categories.push("disabled-by-default-devtools.screenshot");
          }
          const excludedCategories = categories.filter((cat) => {
            return cat.startsWith("-");
          }).map((cat) => {
            return cat.slice(1);
          });
          const includedCategories = categories.filter((cat) => {
            return !cat.startsWith("-");
          });
          this.#path = path2;
          this.#recording = true;
          await this.#client.send("Tracing.start", {
            transferMode: "ReturnAsStream",
            traceConfig: {
              excludedCategories,
              includedCategories
            }
          });
        }
        /**
         * Stops a trace started with the `start` method.
         * @returns Promise which resolves to buffer with trace data.
         */
        async stop() {
          const contentDeferred = Deferred.create();
          this.#client.once("Tracing.tracingComplete", async (event) => {
            try {
              assert2(event.stream, 'Missing "stream"');
              const readable = await getReadableFromProtocolStream(this.#client, event.stream);
              const buffer2 = await getReadableAsBuffer(readable, this.#path);
              contentDeferred.resolve(buffer2 ?? void 0);
            } catch (error) {
              if (isErrorLike(error)) {
                contentDeferred.reject(error);
              } else {
                contentDeferred.reject(new Error(`Unknown error: ${error}`));
              }
            }
          });
          await this.#client.send("Tracing.end");
          this.#recording = false;
          return await contentDeferred.valueOrThrow();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js
  var ConsoleMessage;
  var init_ConsoleMessage = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      ConsoleMessage = class {
        #type;
        #text;
        #args;
        #stackTraceLocations;
        /**
         * @public
         */
        constructor(type, text, args, stackTraceLocations) {
          this.#type = type;
          this.#text = text;
          this.#args = args;
          this.#stackTraceLocations = stackTraceLocations;
        }
        /**
         * The type of the console message.
         */
        type() {
          return this.#type;
        }
        /**
         * The text of the console message.
         */
        text() {
          return this.#text;
        }
        /**
         * An array of arguments passed to the console.
         */
        args() {
          return this.#args;
        }
        /**
         * The location of the console message.
         */
        location() {
          return this.#stackTraceLocations[0] ?? {};
        }
        /**
         * The array of locations on the stack of the console message.
         */
        stackTrace() {
          return this.#stackTraceLocations;
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js
  var Dialog;
  var init_Dialog = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Dialog.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_assert();
      Dialog = class {
        #type;
        #message;
        #defaultValue;
        #handled = false;
        /**
         * @internal
         */
        constructor(type, message, defaultValue = "") {
          this.#type = type;
          this.#message = message;
          this.#defaultValue = defaultValue;
        }
        /**
         * The type of the dialog.
         */
        type() {
          return this.#type;
        }
        /**
         * The message displayed in the dialog.
         */
        message() {
          return this.#message;
        }
        /**
         * The default value of the prompt, or an empty string if the dialog
         * is not a `prompt`.
         */
        defaultValue() {
          return this.#defaultValue;
        }
        /**
         * A promise that resolves when the dialog has been accepted.
         *
         * @param promptText - optional text that will be entered in the dialog
         * prompt. Has no effect if the dialog's type is not `prompt`.
         *
         */
        async accept(promptText) {
          assert2(!this.#handled, "Cannot accept dialog which is already handled!");
          this.#handled = true;
          await this.sendCommand({
            accept: true,
            text: promptText
          });
        }
        /**
         * A promise which will resolve once the dialog has been dismissed
         */
        async dismiss() {
          assert2(!this.#handled, "Cannot dismiss dialog which is already handled!");
          this.#handled = true;
          await this.sendCommand({
            accept: false
          });
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js
  var BidiDialog;
  var init_Dialog2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Dialog();
      BidiDialog = class extends Dialog {
        #context;
        /**
         * @internal
         */
        constructor(context, type, message, defaultValue) {
          super(type, message, defaultValue);
          this.#context = context;
        }
        /**
         * @internal
         */
        async sendCommand(options) {
          await this.#context.connection.send("browsingContext.handleUserPrompt", {
            context: this.#context.id,
            accept: options.accept,
            userText: options.text
          });
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/EmulationManager.js
  var EmulationManager2;
  var init_EmulationManager2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/EmulationManager.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      EmulationManager2 = class {
        #browsingContext;
        constructor(browsingContext) {
          this.#browsingContext = browsingContext;
        }
        async emulateViewport(viewport) {
          await this.#browsingContext.connection.send("browsingContext.setViewport", {
            context: this.#browsingContext.id,
            viewport: viewport.width && viewport.height ? {
              width: viewport.width,
              height: viewport.height
            } : null,
            devicePixelRatio: viewport.deviceScaleFactor ? viewport.deviceScaleFactor : null
          });
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js
  var __runInitializers7, __esDecorate7, __addDisposableResource9, __disposeResources9, FrameEvent, throwIfDetached, Frame;
  var init_Frame = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Frame.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_EventEmitter();
      init_GetQueryHandler();
      init_HandleIterator();
      init_LazyArg();
      init_util2();
      init_assert();
      init_decorators();
      init_locators();
      __runInitializers7 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate7 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __addDisposableResource9 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources9 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      (function(FrameEvent2) {
        FrameEvent2.FrameNavigated = Symbol("Frame.FrameNavigated");
        FrameEvent2.FrameSwapped = Symbol("Frame.FrameSwapped");
        FrameEvent2.LifecycleEvent = Symbol("Frame.LifecycleEvent");
        FrameEvent2.FrameNavigatedWithinDocument = Symbol("Frame.FrameNavigatedWithinDocument");
        FrameEvent2.FrameDetached = Symbol("Frame.FrameDetached");
        FrameEvent2.FrameSwappedByActivation = Symbol("Frame.FrameSwappedByActivation");
      })(FrameEvent || (FrameEvent = {}));
      throwIfDetached = throwIfDisposed((frame) => {
        return `Attempted to use detached Frame '${frame._id}'.`;
      });
      Frame = (() => {
        let _classSuper = EventEmitter;
        let _instanceExtraInitializers = [];
        let _frameElement_decorators;
        let _evaluateHandle_decorators;
        let _evaluate_decorators;
        let _locator_decorators;
        let _$_decorators;
        let _$$_decorators;
        let _$eval_decorators;
        let _$$eval_decorators;
        let _$x_decorators;
        let _waitForSelector_decorators;
        let _waitForXPath_decorators;
        let _waitForFunction_decorators;
        let _content_decorators;
        let _addScriptTag_decorators;
        let _addStyleTag_decorators;
        let _click_decorators;
        let _focus_decorators;
        let _hover_decorators;
        let _select_decorators;
        let _tap_decorators;
        let _type_decorators;
        let _title_decorators;
        return class Frame extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            _frameElement_decorators = [throwIfDetached];
            _evaluateHandle_decorators = [throwIfDetached];
            _evaluate_decorators = [throwIfDetached];
            _locator_decorators = [throwIfDetached];
            _$_decorators = [throwIfDetached];
            _$$_decorators = [throwIfDetached];
            _$eval_decorators = [throwIfDetached];
            _$$eval_decorators = [throwIfDetached];
            _$x_decorators = [throwIfDetached];
            _waitForSelector_decorators = [throwIfDetached];
            _waitForXPath_decorators = [throwIfDetached];
            _waitForFunction_decorators = [throwIfDetached];
            _content_decorators = [throwIfDetached];
            _addScriptTag_decorators = [throwIfDetached];
            _addStyleTag_decorators = [throwIfDetached];
            _click_decorators = [throwIfDetached];
            _focus_decorators = [throwIfDetached];
            _hover_decorators = [throwIfDetached];
            _select_decorators = [throwIfDetached];
            _tap_decorators = [throwIfDetached];
            _type_decorators = [throwIfDetached];
            _title_decorators = [throwIfDetached];
            __esDecorate7(this, null, _frameElement_decorators, { kind: "method", name: "frameElement", static: false, private: false, access: { has: (obj) => "frameElement" in obj, get: (obj) => obj.frameElement }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _evaluateHandle_decorators, { kind: "method", name: "evaluateHandle", static: false, private: false, access: { has: (obj) => "evaluateHandle" in obj, get: (obj) => obj.evaluateHandle }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _evaluate_decorators, { kind: "method", name: "evaluate", static: false, private: false, access: { has: (obj) => "evaluate" in obj, get: (obj) => obj.evaluate }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _locator_decorators, { kind: "method", name: "locator", static: false, private: false, access: { has: (obj) => "locator" in obj, get: (obj) => obj.locator }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _$_decorators, { kind: "method", name: "$", static: false, private: false, access: { has: (obj) => "$" in obj, get: (obj) => obj.$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _$$_decorators, { kind: "method", name: "$$", static: false, private: false, access: { has: (obj) => "$$" in obj, get: (obj) => obj.$$ }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _$eval_decorators, { kind: "method", name: "$eval", static: false, private: false, access: { has: (obj) => "$eval" in obj, get: (obj) => obj.$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _$$eval_decorators, { kind: "method", name: "$$eval", static: false, private: false, access: { has: (obj) => "$$eval" in obj, get: (obj) => obj.$$eval }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _$x_decorators, { kind: "method", name: "$x", static: false, private: false, access: { has: (obj) => "$x" in obj, get: (obj) => obj.$x }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _waitForSelector_decorators, { kind: "method", name: "waitForSelector", static: false, private: false, access: { has: (obj) => "waitForSelector" in obj, get: (obj) => obj.waitForSelector }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _waitForXPath_decorators, { kind: "method", name: "waitForXPath", static: false, private: false, access: { has: (obj) => "waitForXPath" in obj, get: (obj) => obj.waitForXPath }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _waitForFunction_decorators, { kind: "method", name: "waitForFunction", static: false, private: false, access: { has: (obj) => "waitForFunction" in obj, get: (obj) => obj.waitForFunction }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _content_decorators, { kind: "method", name: "content", static: false, private: false, access: { has: (obj) => "content" in obj, get: (obj) => obj.content }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _addScriptTag_decorators, { kind: "method", name: "addScriptTag", static: false, private: false, access: { has: (obj) => "addScriptTag" in obj, get: (obj) => obj.addScriptTag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _addStyleTag_decorators, { kind: "method", name: "addStyleTag", static: false, private: false, access: { has: (obj) => "addStyleTag" in obj, get: (obj) => obj.addStyleTag }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _click_decorators, { kind: "method", name: "click", static: false, private: false, access: { has: (obj) => "click" in obj, get: (obj) => obj.click }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _focus_decorators, { kind: "method", name: "focus", static: false, private: false, access: { has: (obj) => "focus" in obj, get: (obj) => obj.focus }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _hover_decorators, { kind: "method", name: "hover", static: false, private: false, access: { has: (obj) => "hover" in obj, get: (obj) => obj.hover }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _select_decorators, { kind: "method", name: "select", static: false, private: false, access: { has: (obj) => "select" in obj, get: (obj) => obj.select }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _tap_decorators, { kind: "method", name: "tap", static: false, private: false, access: { has: (obj) => "tap" in obj, get: (obj) => obj.tap }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _type_decorators, { kind: "method", name: "type", static: false, private: false, access: { has: (obj) => "type" in obj, get: (obj) => obj.type }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate7(this, null, _title_decorators, { kind: "method", name: "title", static: false, private: false, access: { has: (obj) => "title" in obj, get: (obj) => obj.title }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          /**
           * @internal
           */
          _id = (__runInitializers7(this, _instanceExtraInitializers), void 0);
          /**
           * @internal
           */
          _parentId;
          /**
           * @internal
           */
          worlds;
          /**
           * @internal
           */
          _name;
          /**
           * @internal
           */
          _hasStartedLoading = false;
          /**
           * @internal
           */
          constructor() {
            super();
          }
          #_document;
          /**
           * @internal
           */
          #document() {
            if (!this.#_document) {
              this.#_document = this.isolatedRealm().evaluateHandle(() => {
                return document;
              }).then((handle) => {
                return this.mainRealm().transferHandle(handle);
              });
            }
            return this.#_document;
          }
          /**
           * Used to clear the document handle that has been destroyed.
           *
           * @internal
           */
          clearDocumentHandle() {
            this.#_document = void 0;
          }
          /**
           * @internal
           */
          async frameElement() {
            const env_1 = { stack: [], error: void 0, hasError: false };
            try {
              const parentFrame = this.parentFrame();
              if (!parentFrame) {
                return null;
              }
              const list = __addDisposableResource9(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {
                return document.querySelectorAll("iframe");
              }), false);
              for await (const iframe_1 of transposeIterableHandle(list)) {
                const env_2 = { stack: [], error: void 0, hasError: false };
                try {
                  const iframe = __addDisposableResource9(env_2, iframe_1, false);
                  const frame = await iframe.contentFrame();
                  if (frame._id === this._id) {
                    return iframe.move();
                  }
                } catch (e_1) {
                  env_2.error = e_1;
                  env_2.hasError = true;
                } finally {
                  __disposeResources9(env_2);
                }
              }
              return null;
            } catch (e_2) {
              env_1.error = e_2;
              env_1.hasError = true;
            } finally {
              __disposeResources9(env_1);
            }
          }
          /**
           * Behaves identically to {@link Page.evaluateHandle} except it's run within
           * the context of this frame.
           *
           * @see {@link Page.evaluateHandle} for details.
           */
          async evaluateHandle(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
            return await this.mainRealm().evaluateHandle(pageFunction, ...args);
          }
          /**
           * Behaves identically to {@link Page.evaluate} except it's run within the
           * the context of this frame.
           *
           * @see {@link Page.evaluate} for details.
           */
          async evaluate(pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
            return await this.mainRealm().evaluate(pageFunction, ...args);
          }
          /**
           * @internal
           */
          locator(selectorOrFunc) {
            if (typeof selectorOrFunc === "string") {
              return NodeLocator.create(this, selectorOrFunc);
            } else {
              return FunctionLocator.create(this, selectorOrFunc);
            }
          }
          /**
           * Queries the frame for an element matching the given selector.
           *
           * @param selector - The selector to query for.
           * @returns A {@link ElementHandle | element handle} to the first element
           * matching the given selector. Otherwise, `null`.
           */
          async $(selector) {
            const document2 = await this.#document();
            return await document2.$(selector);
          }
          /**
           * Queries the frame for all elements matching the given selector.
           *
           * @param selector - The selector to query for.
           * @returns An array of {@link ElementHandle | element handles} that point to
           * elements matching the given selector.
           */
          async $$(selector) {
            const document2 = await this.#document();
            return await document2.$$(selector);
          }
          /**
           * Runs the given function on the first element matching the given selector in
           * the frame.
           *
           * If the given function returns a promise, then this method will wait till
           * the promise resolves.
           *
           * @example
           *
           * ```ts
           * const searchValue = await frame.$eval('#search', el => el.value);
           * ```
           *
           * @param selector - The selector to query for.
           * @param pageFunction - The function to be evaluated in the frame's context.
           * The first element matching the selector will be passed to the function as
           * its first argument.
           * @param args - Additional arguments to pass to `pageFunction`.
           * @returns A promise to the result of the function.
           */
          async $eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);
            const document2 = await this.#document();
            return await document2.$eval(selector, pageFunction, ...args);
          }
          /**
           * Runs the given function on an array of elements matching the given selector
           * in the frame.
           *
           * If the given function returns a promise, then this method will wait till
           * the promise resolves.
           *
           * @example
           *
           * ```ts
           * const divsCounts = await frame.$$eval('div', divs => divs.length);
           * ```
           *
           * @param selector - The selector to query for.
           * @param pageFunction - The function to be evaluated in the frame's context.
           * An array of elements matching the given selector will be passed to the
           * function as its first argument.
           * @param args - Additional arguments to pass to `pageFunction`.
           * @returns A promise to the result of the function.
           */
          async $$eval(selector, pageFunction, ...args) {
            pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);
            const document2 = await this.#document();
            return await document2.$$eval(selector, pageFunction, ...args);
          }
          /**
           * @deprecated Use {@link Frame.$$} with the `xpath` prefix.
           *
           * Example: `await frame.$$('xpath/' + xpathExpression)`
           *
           * This method evaluates the given XPath expression and returns the results.
           * If `xpath` starts with `//` instead of `.//`, the dot will be appended
           * automatically.
           * @param expression - the XPath expression to evaluate.
           */
          async $x(expression) {
            const document2 = await this.#document();
            return await document2.$x(expression);
          }
          /**
           * Waits for an element matching the given selector to appear in the frame.
           *
           * This method works across navigations.
           *
           * @example
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           *
           * (async () => {
           *   const browser = await puppeteer.launch();
           *   const page = await browser.newPage();
           *   let currentURL;
           *   page
           *     .mainFrame()
           *     .waitForSelector('img')
           *     .then(() => console.log('First URL with image: ' + currentURL));
           *
           *   for (currentURL of [
           *     'https://example.com',
           *     'https://google.com',
           *     'https://bbc.com',
           *   ]) {
           *     await page.goto(currentURL);
           *   }
           *   await browser.close();
           * })();
           * ```
           *
           * @param selector - The selector to query and wait for.
           * @param options - Options for customizing waiting behavior.
           * @returns An element matching the given selector.
           * @throws Throws if an element matching the given selector doesn't appear.
           */
          async waitForSelector(selector, options = {}) {
            const { updatedSelector, QueryHandler: QueryHandler2 } = getQueryHandlerAndSelector(selector);
            return await QueryHandler2.waitFor(this, updatedSelector, options);
          }
          /**
           * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.
           *
           * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`
           *
           * The method evaluates the XPath expression relative to the Frame.
           * If `xpath` starts with `//` instead of `.//`, the dot will be appended
           * automatically.
           *
           * Wait for the `xpath` to appear in page. If at the moment of calling the
           * method the `xpath` already exists, the method will return immediately. If
           * the xpath doesn't appear after the `timeout` milliseconds of waiting, the
           * function will throw.
           *
           * For a code example, see the example for {@link Frame.waitForSelector}. That
           * function behaves identically other than taking a CSS selector rather than
           * an XPath.
           *
           * @param xpath - the XPath expression to wait for.
           * @param options - options to configure the visibility of the element and how
           * long to wait before timing out.
           */
          async waitForXPath(xpath, options = {}) {
            if (xpath.startsWith("//")) {
              xpath = `.${xpath}`;
            }
            return await this.waitForSelector(`xpath/${xpath}`, options);
          }
          /**
           * @example
           * The `waitForFunction` can be used to observe viewport size change:
           *
           * ```ts
           * import puppeteer from 'puppeteer';
           *
           * (async () => {
           * .  const browser = await puppeteer.launch();
           * .  const page = await browser.newPage();
           * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');
           * .  page.setViewport({width: 50, height: 50});
           * .  await watchDog;
           * .  await browser.close();
           * })();
           * ```
           *
           * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:
           *
           * ```ts
           * const selector = '.foo';
           * await frame.waitForFunction(
           *   selector => !!document.querySelector(selector),
           *   {}, // empty options object
           *   selector
           * );
           * ```
           *
           * @param pageFunction - the function to evaluate in the frame context.
           * @param options - options to configure the polling method and timeout.
           * @param args - arguments to pass to the `pageFunction`.
           * @returns the promise which resolve when the `pageFunction` returns a truthy value.
           */
          async waitForFunction(pageFunction, options = {}, ...args) {
            return await this.mainRealm().waitForFunction(pageFunction, options, ...args);
          }
          /**
           * The full HTML contents of the frame, including the DOCTYPE.
           */
          async content() {
            return await this.evaluate(getPageContent);
          }
          /**
           * @internal
           */
          async setFrameContent(content) {
            return await this.evaluate((html) => {
              document.open();
              document.write(html);
              document.close();
            }, content);
          }
          /**
           * The frame's `name` attribute as specified in the tag.
           *
           * @remarks
           * If the name is empty, it returns the `id` attribute instead.
           *
           * @remarks
           * This value is calculated once when the frame is created, and will not
           * update if the attribute is changed later.
           */
          name() {
            return this._name || "";
          }
          /**
           * Is`true` if the frame has been detached. Otherwise, `false`.
           *
           * @deprecated Use the `detached` getter.
           */
          isDetached() {
            return this.detached;
          }
          /**
           * @internal
           */
          get disposed() {
            return this.detached;
          }
          /**
           * Adds a `<script>` tag into the page with the desired url or content.
           *
           * @param options - Options for the script.
           * @returns An {@link ElementHandle | element handle} to the injected
           * `<script>` element.
           */
          async addScriptTag(options) {
            let { content = "", type } = options;
            const { path: path2 } = options;
            if (+!!options.url + +!!path2 + +!!content !== 1) {
              throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
            }
            if (path2) {
              const fs3 = await importFSPromises();
              content = await fs3.readFile(path2, "utf8");
              content += `//# sourceURL=${path2.replace(/\n/g, "")}`;
            }
            type = type ?? "text/javascript";
            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred: Deferred2 }, { url, id, type: type2, content: content2 }) => {
              const deferred = Deferred2.create();
              const script = document.createElement("script");
              script.type = type2;
              script.text = content2;
              if (url) {
                script.src = url;
                script.addEventListener("load", () => {
                  return deferred.resolve();
                }, { once: true });
                script.addEventListener("error", (event) => {
                  deferred.reject(new Error(event.message ?? "Could not load script"));
                }, { once: true });
              } else {
                deferred.resolve();
              }
              if (id) {
                script.id = id;
              }
              document.head.appendChild(script);
              await deferred.valueOrThrow();
              return script;
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), { ...options, type, content }));
          }
          /**
           * @internal
           */
          async addStyleTag(options) {
            let { content = "" } = options;
            const { path: path2 } = options;
            if (+!!options.url + +!!path2 + +!!content !== 1) {
              throw new Error("Exactly one of `url`, `path`, or `content` must be specified.");
            }
            if (path2) {
              const fs3 = await importFSPromises();
              content = await fs3.readFile(path2, "utf8");
              content += "/*# sourceURL=" + path2.replace(/\n/g, "") + "*/";
              options.content = content;
            }
            return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async ({ Deferred: Deferred2 }, { url, content: content2 }) => {
              const deferred = Deferred2.create();
              let element;
              if (!url) {
                element = document.createElement("style");
                element.appendChild(document.createTextNode(content2));
              } else {
                const link3 = document.createElement("link");
                link3.rel = "stylesheet";
                link3.href = url;
                element = link3;
              }
              element.addEventListener("load", () => {
                deferred.resolve();
              }, { once: true });
              element.addEventListener("error", (event) => {
                deferred.reject(new Error(event.message ?? "Could not load style"));
              }, { once: true });
              document.head.appendChild(element);
              await deferred.valueOrThrow();
              return element;
            }, LazyArg.create((context) => {
              return context.puppeteerUtil;
            }), options));
          }
          /**
           * Clicks the first element found that matches `selector`.
           *
           * @remarks
           * If `click()` triggers a navigation event and there's a separate
           * `page.waitForNavigation()` promise to be resolved, you may end up with a
           * race condition that yields unexpected results. The correct pattern for
           * click and wait for navigation is the following:
           *
           * ```ts
           * const [response] = await Promise.all([
           *   page.waitForNavigation(waitOptions),
           *   frame.click(selector, clickOptions),
           * ]);
           * ```
           *
           * @param selector - The selector to query for.
           */
          async click(selector, options = {}) {
            const env_3 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_3, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              await handle.click(options);
              await handle.dispose();
            } catch (e_3) {
              env_3.error = e_3;
              env_3.hasError = true;
            } finally {
              __disposeResources9(env_3);
            }
          }
          /**
           * Focuses the first element that matches the `selector`.
           *
           * @param selector - The selector to query for.
           * @throws Throws if there's no element matching `selector`.
           */
          async focus(selector) {
            const env_4 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_4, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              await handle.focus();
            } catch (e_4) {
              env_4.error = e_4;
              env_4.hasError = true;
            } finally {
              __disposeResources9(env_4);
            }
          }
          /**
           * Hovers the pointer over the center of the first element that matches the
           * `selector`.
           *
           * @param selector - The selector to query for.
           * @throws Throws if there's no element matching `selector`.
           */
          async hover(selector) {
            const env_5 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_5, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              await handle.hover();
            } catch (e_5) {
              env_5.error = e_5;
              env_5.hasError = true;
            } finally {
              __disposeResources9(env_5);
            }
          }
          /**
           * Selects a set of value on the first `<select>` element that matches the
           * `selector`.
           *
           * @example
           *
           * ```ts
           * frame.select('select#colors', 'blue'); // single selection
           * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections
           * ```
           *
           * @param selector - The selector to query for.
           * @param values - The array of values to select. If the `<select>` has the
           * `multiple` attribute, all values are considered, otherwise only the first
           * one is taken into account.
           * @returns the list of values that were successfully selected.
           * @throws Throws if there's no `<select>` matching `selector`.
           */
          async select(selector, ...values) {
            const env_6 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_6, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              return await handle.select(...values);
            } catch (e_6) {
              env_6.error = e_6;
              env_6.hasError = true;
            } finally {
              __disposeResources9(env_6);
            }
          }
          /**
           * Taps the first element that matches the `selector`.
           *
           * @param selector - The selector to query for.
           * @throws Throws if there's no element matching `selector`.
           */
          async tap(selector) {
            const env_7 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_7, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              await handle.tap();
            } catch (e_7) {
              env_7.error = e_7;
              env_7.hasError = true;
            } finally {
              __disposeResources9(env_7);
            }
          }
          /**
           * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character
           * in the text.
           *
           * @remarks
           * To press a special key, like `Control` or `ArrowDown`, use
           * {@link Keyboard.press}.
           *
           * @example
           *
           * ```ts
           * await frame.type('#mytextarea', 'Hello'); // Types instantly
           * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user
           * ```
           *
           * @param selector - the selector for the element to type into. If there are
           * multiple the first will be used.
           * @param text - text to type into the element
           * @param options - takes one option, `delay`, which sets the time to wait
           * between key presses in milliseconds. Defaults to `0`.
           */
          async type(selector, text, options) {
            const env_8 = { stack: [], error: void 0, hasError: false };
            try {
              const handle = __addDisposableResource9(env_8, await this.$(selector), false);
              assert2(handle, `No element found for selector: ${selector}`);
              await handle.type(text, options);
            } catch (e_8) {
              env_8.error = e_8;
              env_8.hasError = true;
            } finally {
              __disposeResources9(env_8);
            }
          }
          /**
           * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.
           *
           * Causes your script to wait for the given number of milliseconds.
           *
           * @remarks
           * It's generally recommended to not wait for a number of seconds, but instead
           * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or
           * {@link Frame.waitForFunction} to wait for exactly the conditions you want.
           *
           * @example
           *
           * Wait for 1 second:
           *
           * ```ts
           * await frame.waitForTimeout(1000);
           * ```
           *
           * @param milliseconds - the number of milliseconds to wait.
           */
          async waitForTimeout(milliseconds) {
            return await new Promise((resolve3) => {
              setTimeout(resolve3, milliseconds);
            });
          }
          /**
           * The frame's title.
           */
          async title() {
            return await this.isolatedRealm().evaluate(() => {
              return document.title;
            });
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js
  var Bidi2, ExposeableFunction;
  var init_ExposedFunction = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Bidi2 = __toESM(require_protocol(), 1);
      init_util2();
      init_assert();
      init_Deferred();
      init_Function();
      init_Deserializer();
      init_Serializer();
      ExposeableFunction = class {
        #frame;
        name;
        #apply;
        #channels;
        #callerInfos = /* @__PURE__ */ new Map();
        #preloadScriptId;
        constructor(frame, name2, apply) {
          this.#frame = frame;
          this.name = name2;
          this.#apply = apply;
          this.#channels = {
            args: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_args`,
            resolve: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_resolve`,
            reject: `__puppeteer__${this.#frame._id}_page_exposeFunction_${this.name}_reject`
          };
        }
        async expose() {
          const connection = this.#connection;
          const channelArguments = this.#channelArguments;
          const { name: name2 } = this;
          connection.on(Bidi2.ChromiumBidi.Script.EventNames.Message, this.#handleArgumentsMessage);
          connection.on(Bidi2.ChromiumBidi.Script.EventNames.Message, this.#handleResolveMessage);
          connection.on(Bidi2.ChromiumBidi.Script.EventNames.Message, this.#handleRejectMessage);
          const functionDeclaration = stringifyFunction(interpolateFunction((sendArgs, sendResolve, sendReject) => {
            let id = 0;
            Object.assign(globalThis, {
              [PLACEHOLDER("name")]: function(...args) {
                return new Promise((resolve3, reject) => {
                  sendArgs([id, args]);
                  sendResolve([id, resolve3]);
                  sendReject([id, reject]);
                  ++id;
                });
              }
            });
          }, { name: JSON.stringify(name2) }));
          const { result } = await connection.send("script.addPreloadScript", {
            functionDeclaration,
            arguments: channelArguments,
            contexts: [this.#frame.page().mainFrame()._id]
          });
          this.#preloadScriptId = result.script;
          await Promise.all(this.#frame.page().frames().map(async (frame) => {
            return await connection.send("script.callFunction", {
              functionDeclaration,
              arguments: channelArguments,
              awaitPromise: false,
              target: frame.mainRealm().realm.target
            });
          }));
        }
        #handleArgumentsMessage = async (params) => {
          if (params.channel !== this.#channels.args) {
            return;
          }
          const connection = this.#connection;
          const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
          const args = remoteValue.value?.[1];
          assert2(args);
          try {
            const result = await this.#apply(...BidiDeserializer.deserialize(args));
            await connection.send("script.callFunction", {
              functionDeclaration: stringifyFunction(([_5, resolve3], result2) => {
                resolve3(result2);
              }),
              arguments: [
                await callbacks.resolve.valueOrThrow(),
                BidiSerializer.serializeRemoteValue(result)
              ],
              awaitPromise: false,
              target: params.source
            });
          } catch (error) {
            try {
              if (error instanceof Error) {
                await connection.send("script.callFunction", {
                  functionDeclaration: stringifyFunction(([_5, reject], name2, message, stack) => {
                    const error2 = new Error(message);
                    error2.name = name2;
                    if (stack) {
                      error2.stack = stack;
                    }
                    reject(error2);
                  }),
                  arguments: [
                    await callbacks.reject.valueOrThrow(),
                    BidiSerializer.serializeRemoteValue(error.name),
                    BidiSerializer.serializeRemoteValue(error.message),
                    BidiSerializer.serializeRemoteValue(error.stack)
                  ],
                  awaitPromise: false,
                  target: params.source
                });
              } else {
                await connection.send("script.callFunction", {
                  functionDeclaration: stringifyFunction(([_5, reject], error2) => {
                    reject(error2);
                  }),
                  arguments: [
                    await callbacks.reject.valueOrThrow(),
                    BidiSerializer.serializeRemoteValue(error)
                  ],
                  awaitPromise: false,
                  target: params.source
                });
              }
            } catch (error2) {
              debugError(error2);
            }
          }
        };
        get #connection() {
          return this.#frame.context().connection;
        }
        get #channelArguments() {
          return [
            {
              type: "channel",
              value: {
                channel: this.#channels.args,
                ownership: "root"
              }
            },
            {
              type: "channel",
              value: {
                channel: this.#channels.resolve,
                ownership: "root"
              }
            },
            {
              type: "channel",
              value: {
                channel: this.#channels.reject,
                ownership: "root"
              }
            }
          ];
        }
        #handleResolveMessage = (params) => {
          if (params.channel !== this.#channels.resolve) {
            return;
          }
          const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
          callbacks.resolve.resolve(remoteValue);
        };
        #handleRejectMessage = (params) => {
          if (params.channel !== this.#channels.reject) {
            return;
          }
          const { callbacks, remoteValue } = this.#getCallbacksAndRemoteValue(params);
          callbacks.reject.resolve(remoteValue);
        };
        #getCallbacksAndRemoteValue(params) {
          const { data, source: source2 } = params;
          assert2(data.type === "array");
          assert2(data.value);
          const callerIdRemote = data.value[0];
          assert2(callerIdRemote);
          assert2(callerIdRemote.type === "number");
          assert2(typeof callerIdRemote.value === "number");
          let bindingMap = this.#callerInfos.get(source2.realm);
          if (!bindingMap) {
            bindingMap = /* @__PURE__ */ new Map();
            this.#callerInfos.set(source2.realm, bindingMap);
          }
          const callerId = callerIdRemote.value;
          let callbacks = bindingMap.get(callerId);
          if (!callbacks) {
            callbacks = {
              resolve: new Deferred(),
              reject: new Deferred()
            };
            bindingMap.set(callerId, callbacks);
          }
          return { callbacks, remoteValue: data };
        }
        [Symbol.dispose]() {
          void this[Symbol.asyncDispose]().catch(debugError);
        }
        async [Symbol.asyncDispose]() {
          if (this.#preloadScriptId) {
            await this.#connection.send("script.removePreloadScript", {
              script: this.#preloadScriptId
            });
          }
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/lifecycle.js
  function getBiDiLifeCycles(event) {
    if (Array.isArray(event)) {
      const pageLifeCycle = event.some((lifeCycle) => {
        return lifeCycle !== "domcontentloaded";
      }) ? "load" : "domcontentloaded";
      const networkLifeCycle = event.reduce((acc, lifeCycle) => {
        if (lifeCycle === "networkidle0") {
          return lifeCycle;
        } else if (acc !== "networkidle0" && lifeCycle === "networkidle2") {
          return lifeCycle;
        }
        return acc;
      }, null);
      return [pageLifeCycle, networkLifeCycle];
    }
    if (event === "networkidle0" || event === "networkidle2") {
      return ["load", event];
    }
    return [event, null];
  }
  function getBiDiReadinessState(event) {
    const lifeCycles = getBiDiLifeCycles(event);
    const readiness = lifeCycleToReadinessState.get(lifeCycles[0]);
    return [readiness, lifeCycles[1]];
  }
  function getBiDiLifecycleEvent(event) {
    const lifeCycles = getBiDiLifeCycles(event);
    const bidiEvent = lifeCycleToSubscribedEvent.get(lifeCycles[0]);
    return [bidiEvent, lifeCycles[1]];
  }
  function rewriteNavigationError(message, ms) {
    return kr((error) => {
      if (error instanceof ProtocolError) {
        error.message += ` at ${message}`;
      } else if (error instanceof TimeoutError) {
        error.message = `Navigation timeout of ${ms} ms exceeded`;
      }
      throw error;
    });
  }
  var lifeCycleToReadinessState, lifeCycleToSubscribedEvent;
  var init_lifecycle = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/lifecycle.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_Errors();
      lifeCycleToReadinessState = /* @__PURE__ */ new Map([
        [
          "load",
          "complete"
          /* Bidi.BrowsingContext.ReadinessState.Complete */
        ],
        [
          "domcontentloaded",
          "interactive"
          /* Bidi.BrowsingContext.ReadinessState.Interactive */
        ]
      ]);
      lifeCycleToSubscribedEvent = /* @__PURE__ */ new Map([
        ["load", "browsingContext.load"],
        ["domcontentloaded", "browsingContext.domContentLoaded"]
      ]);
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js
  var WaitTask, TaskManager;
  var init_WaitTask = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/WaitTask.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Deferred();
      init_ErrorLike();
      init_Function();
      init_Errors();
      init_LazyArg();
      WaitTask = class {
        #world;
        #polling;
        #root;
        #fn;
        #args;
        #timeout;
        #timeoutError;
        #result = Deferred.create();
        #poller;
        #signal;
        #reruns = [];
        constructor(world, options, fn, ...args) {
          this.#world = world;
          this.#polling = options.polling;
          this.#root = options.root;
          this.#signal = options.signal;
          this.#signal?.addEventListener("abort", () => {
            void this.terminate(this.#signal?.reason);
          }, {
            once: true
          });
          switch (typeof fn) {
            case "string":
              this.#fn = `() => {return (${fn});}`;
              break;
            default:
              this.#fn = stringifyFunction(fn);
              break;
          }
          this.#args = args;
          this.#world.taskManager.add(this);
          if (options.timeout) {
            this.#timeoutError = new TimeoutError(`Waiting failed: ${options.timeout}ms exceeded`);
            this.#timeout = setTimeout(() => {
              void this.terminate(this.#timeoutError);
            }, options.timeout);
          }
          void this.rerun();
        }
        get result() {
          return this.#result.valueOrThrow();
        }
        async rerun() {
          for (const prev of this.#reruns) {
            prev.abort();
          }
          this.#reruns.length = 0;
          const controller = new AbortController();
          this.#reruns.push(controller);
          try {
            switch (this.#polling) {
              case "raf":
                this.#poller = await this.#world.evaluateHandle(({ RAFPoller, createFunction: createFunction2 }, fn, ...args) => {
                  const fun = createFunction2(fn);
                  return new RAFPoller(() => {
                    return fun(...args);
                  });
                }, LazyArg.create((context) => {
                  return context.puppeteerUtil;
                }), this.#fn, ...this.#args);
                break;
              case "mutation":
                this.#poller = await this.#world.evaluateHandle(({ MutationPoller, createFunction: createFunction2 }, root, fn, ...args) => {
                  const fun = createFunction2(fn);
                  return new MutationPoller(() => {
                    return fun(...args);
                  }, root || document);
                }, LazyArg.create((context) => {
                  return context.puppeteerUtil;
                }), this.#root, this.#fn, ...this.#args);
                break;
              default:
                this.#poller = await this.#world.evaluateHandle(({ IntervalPoller, createFunction: createFunction2 }, ms, fn, ...args) => {
                  const fun = createFunction2(fn);
                  return new IntervalPoller(() => {
                    return fun(...args);
                  }, ms);
                }, LazyArg.create((context) => {
                  return context.puppeteerUtil;
                }), this.#polling, this.#fn, ...this.#args);
                break;
            }
            await this.#poller.evaluate((poller) => {
              void poller.start();
            });
            const result = await this.#poller.evaluateHandle((poller) => {
              return poller.result();
            });
            this.#result.resolve(result);
            await this.terminate();
          } catch (error) {
            if (controller.signal.aborted) {
              return;
            }
            const badError = this.getBadError(error);
            if (badError) {
              await this.terminate(badError);
            }
          }
        }
        async terminate(error) {
          this.#world.taskManager.delete(this);
          clearTimeout(this.#timeout);
          if (error && !this.#result.finished()) {
            this.#result.reject(error);
          }
          if (this.#poller) {
            try {
              await this.#poller.evaluateHandle(async (poller) => {
                await poller.stop();
              });
              if (this.#poller) {
                await this.#poller.dispose();
                this.#poller = void 0;
              }
            } catch {
            }
          }
        }
        /**
         * Not all errors lead to termination. They usually imply we need to rerun the task.
         */
        getBadError(error) {
          if (isErrorLike(error)) {
            if (error.message.includes("Execution context is not available in detached frame")) {
              return new Error("Waiting failed: Frame detached");
            }
            if (error.message.includes("Execution context was destroyed")) {
              return;
            }
            if (error.message.includes("Cannot find context with specified id")) {
              return;
            }
            if (error.message.includes("AbortError: Actor 'MessageHandlerFrame' destroyed")) {
              return;
            }
            return error;
          }
          return new Error("WaitTask failed with an error", {
            cause: error
          });
        }
      };
      TaskManager = class {
        #tasks = /* @__PURE__ */ new Set();
        add(task) {
          this.#tasks.add(task);
        }
        delete(task) {
          this.#tasks.delete(task);
        }
        terminateAll(error) {
          for (const task of this.#tasks) {
            void task.terminate(error);
          }
          this.#tasks.clear();
        }
        async rerunAll() {
          await Promise.all([...this.#tasks].map((task) => {
            return task.rerun();
          }));
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js
  var Realm;
  var init_Realm2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Realm.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_WaitTask();
      init_disposable();
      Realm = class {
        timeoutSettings;
        taskManager = new TaskManager();
        constructor(timeoutSettings) {
          this.timeoutSettings = timeoutSettings;
        }
        async waitForFunction(pageFunction, options = {}, ...args) {
          const { polling = "raf", timeout: timeout2 = this.timeoutSettings.timeout(), root, signal } = options;
          if (typeof polling === "number" && polling < 0) {
            throw new Error("Cannot poll with non-positive interval");
          }
          const waitTask = new WaitTask(this, {
            polling,
            root,
            timeout: timeout2,
            signal
          }, pageFunction, ...args);
          return await waitTask.result;
        }
        get disposed() {
          return this.#disposed;
        }
        #disposed = false;
        /** @internal */
        [disposeSymbol]() {
          this.#disposed = true;
          this.taskManager.terminateAll(new Error("waitForFunction failed: frame got detached."));
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Sandbox.js
  var MAIN_SANDBOX, PUPPETEER_SANDBOX, Sandbox;
  var init_Sandbox = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Sandbox.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Realm2();
      init_util2();
      init_ElementHandle2();
      MAIN_SANDBOX = Symbol("mainSandbox");
      PUPPETEER_SANDBOX = Symbol("puppeteerSandbox");
      Sandbox = class extends Realm {
        name;
        realm;
        #frame;
        constructor(name2, frame, realm, timeoutSettings) {
          super(timeoutSettings);
          this.name = name2;
          this.realm = realm;
          this.#frame = frame;
          this.realm.setSandbox(this);
        }
        get environment() {
          return this.#frame;
        }
        async evaluateHandle(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
          return await this.realm.evaluateHandle(pageFunction, ...args);
        }
        async evaluate(pageFunction, ...args) {
          pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
          return await this.realm.evaluate(pageFunction, ...args);
        }
        async adoptHandle(handle) {
          return await this.evaluateHandle((node) => {
            return node;
          }, handle);
        }
        async transferHandle(handle) {
          if (handle.realm === this) {
            return handle;
          }
          const transferredHandle = await this.evaluateHandle((node) => {
            return node;
          }, handle);
          await handle.dispose();
          return transferredHandle;
        }
        async adoptBackendNode(backendNodeId) {
          const { object } = await this.environment.client.send("DOM.resolveNode", {
            backendNodeId
          });
          return new BidiElementHandle(this, {
            handle: object.objectId,
            type: "node"
          });
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js
  var Bidi3, __runInitializers8, __esDecorate8, BidiFrame;
  var init_Frame2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Frame.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Bidi3 = __toESM(require_protocol(), 1);
      init_rxjs();
      init_Frame();
      init_Errors();
      init_util2();
      init_Deferred();
      init_disposable();
      init_ExposedFunction();
      init_lifecycle();
      init_Sandbox();
      __runInitializers8 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i7 = 0; i7 < initializers.length; i7++) {
          value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __esDecorate8 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f7) {
          if (f7 !== void 0 && typeof f7 !== "function")
            throw new TypeError("Function expected");
          return f7;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _5, done = false;
        for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
          var context = {};
          for (var p8 in contextIn)
            context[p8] = p8 === "access" ? {} : contextIn[p8];
          for (var p8 in contextIn.access)
            context.access[p8] = contextIn.access[p8];
          context.addInitializer = function(f7) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f7 || null));
          };
          var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_5 = accept(result.get))
              descriptor.get = _5;
            if (_5 = accept(result.set))
              descriptor.set = _5;
            if (_5 = accept(result.init))
              initializers.unshift(_5);
          } else if (_5 = accept(result)) {
            if (kind === "field")
              initializers.unshift(_5);
            else
              descriptor[key] = _5;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      BidiFrame = (() => {
        let _classSuper = Frame;
        let _instanceExtraInitializers = [];
        let _goto_decorators;
        let _setContent_decorators;
        let _waitForNavigation_decorators;
        return class BidiFrame extends _classSuper {
          static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
            __esDecorate8(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate8(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate8(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata)
              Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
          }
          #page = (__runInitializers8(this, _instanceExtraInitializers), void 0);
          #context;
          #timeoutSettings;
          #abortDeferred = Deferred.create();
          #disposed = false;
          sandboxes;
          _id;
          constructor(page, context, timeoutSettings, parentId) {
            super();
            this.#page = page;
            this.#context = context;
            this.#timeoutSettings = timeoutSettings;
            this._id = this.#context.id;
            this._parentId = parentId ?? void 0;
            this.sandboxes = {
              [MAIN_SANDBOX]: new Sandbox(void 0, this, context, timeoutSettings),
              [PUPPETEER_SANDBOX]: new Sandbox(UTILITY_WORLD_NAME, this, context.createRealmForSandbox(), timeoutSettings)
            };
          }
          get client() {
            return this.context().cdpSession;
          }
          mainRealm() {
            return this.sandboxes[MAIN_SANDBOX];
          }
          isolatedRealm() {
            return this.sandboxes[PUPPETEER_SANDBOX];
          }
          page() {
            return this.#page;
          }
          isOOPFrame() {
            throw new UnsupportedOperation();
          }
          url() {
            return this.#context.url;
          }
          parentFrame() {
            return this.#page.frame(this._parentId ?? "");
          }
          childFrames() {
            return this.#page.childFrames(this.#context.id);
          }
          async goto(url, options = {}) {
            const { waitUntil = "load", timeout: ms = this.#timeoutSettings.navigationTimeout() } = options;
            const [readiness, networkIdle] = getBiDiReadinessState(waitUntil);
            const response = await fe(this.#page._waitWithNetworkIdle(this.#context.connection.send("browsingContext.navigate", {
              context: this.#context.id,
              url,
              wait: readiness
            }), networkIdle).pipe(Oe(timeout(ms), j(this.#abortDeferred.valueOrThrow()))).pipe(rewriteNavigationError(url, ms)));
            return this.#page.getNavigationResponse(response?.result.navigation);
          }
          async setContent(html, options = {}) {
            const { waitUntil = "load", timeout: ms = this.#timeoutSettings.navigationTimeout() } = options;
            const [waitEvent, networkIdle] = getBiDiLifecycleEvent(waitUntil);
            await fe(this.#page._waitWithNetworkIdle(le([
              xr(this.#context, waitEvent).pipe(Ee()),
              j(this.setFrameContent(html))
            ]).pipe(k(() => {
              return null;
            })), networkIdle).pipe(Oe(timeout(ms), j(this.#abortDeferred.valueOrThrow()))).pipe(rewriteNavigationError("setContent", ms)));
          }
          context() {
            return this.#context;
          }
          async waitForNavigation(options = {}) {
            const { waitUntil = "load", timeout: ms = this.#timeoutSettings.navigationTimeout() } = options;
            const [waitUntilEvent, networkIdle] = getBiDiLifecycleEvent(waitUntil);
            const navigatedObservable = he(le([
              xr(this.#context, Bidi3.ChromiumBidi.BrowsingContext.EventNames.NavigationStarted).pipe(Ee()),
              xr(this.#context, waitUntilEvent).pipe(Ee())
            ]), xr(this.#context, Bidi3.ChromiumBidi.BrowsingContext.EventNames.FragmentNavigated)).pipe(k((result) => {
              if (Array.isArray(result)) {
                return { result: result[1] };
              }
              return { result };
            }));
            const response = await fe(this.#page._waitWithNetworkIdle(navigatedObservable, networkIdle).pipe(Oe(timeout(ms), j(this.#abortDeferred.valueOrThrow()))));
            return this.#page.getNavigationResponse(response?.result.navigation);
          }
          waitForDevicePrompt() {
            throw new UnsupportedOperation();
          }
          get detached() {
            return this.#disposed;
          }
          [(_goto_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], disposeSymbol)]() {
            if (this.#disposed) {
              return;
            }
            this.#disposed = true;
            this.#abortDeferred.reject(new Error("Frame detached"));
            this.#context.dispose();
            this.sandboxes[MAIN_SANDBOX][disposeSymbol]();
            this.sandboxes[PUPPETEER_SANDBOX][disposeSymbol]();
          }
          #exposedFunctions = /* @__PURE__ */ new Map();
          async exposeFunction(name2, apply) {
            if (this.#exposedFunctions.has(name2)) {
              throw new Error(`Failed to add page binding with name ${name2}: globalThis['${name2}'] already exists!`);
            }
            const exposeable = new ExposeableFunction(this, name2, apply);
            this.#exposedFunctions.set(name2, exposeable);
            try {
              await exposeable.expose();
            } catch (error) {
              this.#exposedFunctions.delete(name2);
              throw error;
            }
          }
          waitForSelector(selector, options) {
            if (selector.startsWith("aria")) {
              throw new UnsupportedOperation("ARIA selector is not supported for BiDi!");
            }
            return super.waitForSelector(selector, options);
          }
        };
      })();
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js
  var Keyboard, MouseButton, Mouse, Touchscreen;
  var init_Input = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/Input.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      Keyboard = class {
        /**
         * @internal
         */
        constructor() {
        }
      };
      MouseButton = Object.freeze({
        Left: "left",
        Right: "right",
        Middle: "middle",
        Back: "back",
        Forward: "forward"
      });
      Mouse = class {
        /**
         * @internal
         */
        constructor() {
        }
      };
      Touchscreen = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * Dispatches a `touchstart` and `touchend` event.
         * @param x - Horizontal position of the tap.
         * @param y - Vertical position of the tap.
         */
        async tap(x4, y6) {
          await this.touchStart(x4, y6);
          await this.touchEnd();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js
  var SourceActionsType, ActionType, getBidiKeyValue, BidiKeyboard, getBidiButton, BidiMouse, BidiTouchscreen;
  var init_Input2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Input.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Input();
      init_Errors();
      (function(SourceActionsType2) {
        SourceActionsType2["None"] = "none";
        SourceActionsType2["Key"] = "key";
        SourceActionsType2["Pointer"] = "pointer";
        SourceActionsType2["Wheel"] = "wheel";
      })(SourceActionsType || (SourceActionsType = {}));
      (function(ActionType2) {
        ActionType2["Pause"] = "pause";
        ActionType2["KeyDown"] = "keyDown";
        ActionType2["KeyUp"] = "keyUp";
        ActionType2["PointerUp"] = "pointerUp";
        ActionType2["PointerDown"] = "pointerDown";
        ActionType2["PointerMove"] = "pointerMove";
        ActionType2["Scroll"] = "scroll";
      })(ActionType || (ActionType = {}));
      getBidiKeyValue = (key) => {
        switch (key) {
          case "\r":
          case "\n":
            key = "Enter";
            break;
        }
        if ([...key].length === 1) {
          return key;
        }
        switch (key) {
          case "Cancel":
            return "\uE001";
          case "Help":
            return "\uE002";
          case "Backspace":
            return "\uE003";
          case "Tab":
            return "\uE004";
          case "Clear":
            return "\uE005";
          case "Enter":
            return "\uE007";
          case "Shift":
          case "ShiftLeft":
            return "\uE008";
          case "Control":
          case "ControlLeft":
            return "\uE009";
          case "Alt":
          case "AltLeft":
            return "\uE00A";
          case "Pause":
            return "\uE00B";
          case "Escape":
            return "\uE00C";
          case "PageUp":
            return "\uE00E";
          case "PageDown":
            return "\uE00F";
          case "End":
            return "\uE010";
          case "Home":
            return "\uE011";
          case "ArrowLeft":
            return "\uE012";
          case "ArrowUp":
            return "\uE013";
          case "ArrowRight":
            return "\uE014";
          case "ArrowDown":
            return "\uE015";
          case "Insert":
            return "\uE016";
          case "Delete":
            return "\uE017";
          case "NumpadEqual":
            return "\uE019";
          case "Numpad0":
            return "\uE01A";
          case "Numpad1":
            return "\uE01B";
          case "Numpad2":
            return "\uE01C";
          case "Numpad3":
            return "\uE01D";
          case "Numpad4":
            return "\uE01E";
          case "Numpad5":
            return "\uE01F";
          case "Numpad6":
            return "\uE020";
          case "Numpad7":
            return "\uE021";
          case "Numpad8":
            return "\uE022";
          case "Numpad9":
            return "\uE023";
          case "NumpadMultiply":
            return "\uE024";
          case "NumpadAdd":
            return "\uE025";
          case "NumpadSubtract":
            return "\uE027";
          case "NumpadDecimal":
            return "\uE028";
          case "NumpadDivide":
            return "\uE029";
          case "F1":
            return "\uE031";
          case "F2":
            return "\uE032";
          case "F3":
            return "\uE033";
          case "F4":
            return "\uE034";
          case "F5":
            return "\uE035";
          case "F6":
            return "\uE036";
          case "F7":
            return "\uE037";
          case "F8":
            return "\uE038";
          case "F9":
            return "\uE039";
          case "F10":
            return "\uE03A";
          case "F11":
            return "\uE03B";
          case "F12":
            return "\uE03C";
          case "Meta":
          case "MetaLeft":
            return "\uE03D";
          case "ShiftRight":
            return "\uE050";
          case "ControlRight":
            return "\uE051";
          case "AltRight":
            return "\uE052";
          case "MetaRight":
            return "\uE053";
          case "Digit0":
            return "0";
          case "Digit1":
            return "1";
          case "Digit2":
            return "2";
          case "Digit3":
            return "3";
          case "Digit4":
            return "4";
          case "Digit5":
            return "5";
          case "Digit6":
            return "6";
          case "Digit7":
            return "7";
          case "Digit8":
            return "8";
          case "Digit9":
            return "9";
          case "KeyA":
            return "a";
          case "KeyB":
            return "b";
          case "KeyC":
            return "c";
          case "KeyD":
            return "d";
          case "KeyE":
            return "e";
          case "KeyF":
            return "f";
          case "KeyG":
            return "g";
          case "KeyH":
            return "h";
          case "KeyI":
            return "i";
          case "KeyJ":
            return "j";
          case "KeyK":
            return "k";
          case "KeyL":
            return "l";
          case "KeyM":
            return "m";
          case "KeyN":
            return "n";
          case "KeyO":
            return "o";
          case "KeyP":
            return "p";
          case "KeyQ":
            return "q";
          case "KeyR":
            return "r";
          case "KeyS":
            return "s";
          case "KeyT":
            return "t";
          case "KeyU":
            return "u";
          case "KeyV":
            return "v";
          case "KeyW":
            return "w";
          case "KeyX":
            return "x";
          case "KeyY":
            return "y";
          case "KeyZ":
            return "z";
          case "Semicolon":
            return ";";
          case "Equal":
            return "=";
          case "Comma":
            return ",";
          case "Minus":
            return "-";
          case "Period":
            return ".";
          case "Slash":
            return "/";
          case "Backquote":
            return "`";
          case "BracketLeft":
            return "[";
          case "Backslash":
            return "\\";
          case "BracketRight":
            return "]";
          case "Quote":
            return '"';
          default:
            throw new Error(`Unknown key: "${key}"`);
        }
      };
      BidiKeyboard = class extends Keyboard {
        #page;
        constructor(page) {
          super();
          this.#page = page;
        }
        async down(key, _options) {
          await this.#page.connection.send("input.performActions", {
            context: this.#page.mainFrame()._id,
            actions: [
              {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard",
                actions: [
                  {
                    type: ActionType.KeyDown,
                    value: getBidiKeyValue(key)
                  }
                ]
              }
            ]
          });
        }
        async up(key) {
          await this.#page.connection.send("input.performActions", {
            context: this.#page.mainFrame()._id,
            actions: [
              {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard",
                actions: [
                  {
                    type: ActionType.KeyUp,
                    value: getBidiKeyValue(key)
                  }
                ]
              }
            ]
          });
        }
        async press(key, options = {}) {
          const { delay = 0 } = options;
          const actions = [
            {
              type: ActionType.KeyDown,
              value: getBidiKeyValue(key)
            }
          ];
          if (delay > 0) {
            actions.push({
              type: ActionType.Pause,
              duration: delay
            });
          }
          actions.push({
            type: ActionType.KeyUp,
            value: getBidiKeyValue(key)
          });
          await this.#page.connection.send("input.performActions", {
            context: this.#page.mainFrame()._id,
            actions: [
              {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard",
                actions
              }
            ]
          });
        }
        async type(text, options = {}) {
          const { delay = 0 } = options;
          const values = [...text].map(getBidiKeyValue);
          const actions = [];
          if (delay <= 0) {
            for (const value of values) {
              actions.push({
                type: ActionType.KeyDown,
                value
              }, {
                type: ActionType.KeyUp,
                value
              });
            }
          } else {
            for (const value of values) {
              actions.push({
                type: ActionType.KeyDown,
                value
              }, {
                type: ActionType.Pause,
                duration: delay
              }, {
                type: ActionType.KeyUp,
                value
              });
            }
          }
          await this.#page.connection.send("input.performActions", {
            context: this.#page.mainFrame()._id,
            actions: [
              {
                type: SourceActionsType.Key,
                id: "__puppeteer_keyboard",
                actions
              }
            ]
          });
        }
        async sendCharacter(char) {
          if ([...char].length > 1) {
            throw new Error("Cannot send more than 1 character.");
          }
          const frame = await this.#page.focusedFrame();
          await frame.isolatedRealm().evaluate(async (char2) => {
            document.execCommand("insertText", false, char2);
          }, char);
        }
      };
      getBidiButton = (button) => {
        switch (button) {
          case MouseButton.Left:
            return 0;
          case MouseButton.Middle:
            return 1;
          case MouseButton.Right:
            return 2;
          case MouseButton.Back:
            return 3;
          case MouseButton.Forward:
            return 4;
        }
      };
      BidiMouse = class extends Mouse {
        #context;
        #lastMovePoint = { x: 0, y: 0 };
        constructor(context) {
          super();
          this.#context = context;
        }
        async reset() {
          this.#lastMovePoint = { x: 0, y: 0 };
          await this.#context.connection.send("input.releaseActions", {
            context: this.#context.id
          });
        }
        async move(x4, y6, options = {}) {
          const from = this.#lastMovePoint;
          const to = {
            x: Math.round(x4),
            y: Math.round(y6)
          };
          const actions = [];
          const steps = options.steps ?? 0;
          for (let i7 = 0; i7 < steps; ++i7) {
            actions.push({
              type: ActionType.PointerMove,
              x: from.x + (to.x - from.x) * (i7 / steps),
              y: from.y + (to.y - from.y) * (i7 / steps),
              origin: options.origin
            });
          }
          actions.push({
            type: ActionType.PointerMove,
            ...to,
            origin: options.origin
          });
          this.#lastMovePoint = to;
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse",
                actions
              }
            ]
          });
        }
        async down(options = {}) {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse",
                actions: [
                  {
                    type: ActionType.PointerDown,
                    button: getBidiButton(options.button ?? MouseButton.Left)
                  }
                ]
              }
            ]
          });
        }
        async up(options = {}) {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse",
                actions: [
                  {
                    type: ActionType.PointerUp,
                    button: getBidiButton(options.button ?? MouseButton.Left)
                  }
                ]
              }
            ]
          });
        }
        async click(x4, y6, options = {}) {
          const actions = [
            {
              type: ActionType.PointerMove,
              x: Math.round(x4),
              y: Math.round(y6),
              origin: options.origin
            }
          ];
          const pointerDownAction = {
            type: ActionType.PointerDown,
            button: getBidiButton(options.button ?? MouseButton.Left)
          };
          const pointerUpAction = {
            type: ActionType.PointerUp,
            button: pointerDownAction.button
          };
          for (let i7 = 1; i7 < (options.count ?? 1); ++i7) {
            actions.push(pointerDownAction, pointerUpAction);
          }
          actions.push(pointerDownAction);
          if (options.delay) {
            actions.push({
              type: ActionType.Pause,
              duration: options.delay
            });
          }
          actions.push(pointerUpAction);
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_mouse",
                actions
              }
            ]
          });
        }
        async wheel(options = {}) {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Wheel,
                id: "__puppeteer_wheel",
                actions: [
                  {
                    type: ActionType.Scroll,
                    ...this.#lastMovePoint ?? {
                      x: 0,
                      y: 0
                    },
                    deltaX: options.deltaX ?? 0,
                    deltaY: options.deltaY ?? 0
                  }
                ]
              }
            ]
          });
        }
        drag() {
          throw new UnsupportedOperation();
        }
        dragOver() {
          throw new UnsupportedOperation();
        }
        dragEnter() {
          throw new UnsupportedOperation();
        }
        drop() {
          throw new UnsupportedOperation();
        }
        dragAndDrop() {
          throw new UnsupportedOperation();
        }
      };
      BidiTouchscreen = class extends Touchscreen {
        #context;
        constructor(context) {
          super();
          this.#context = context;
        }
        async touchStart(x4, y6, options = {}) {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger",
                parameters: {
                  pointerType: "touch"
                },
                actions: [
                  {
                    type: ActionType.PointerMove,
                    x: Math.round(x4),
                    y: Math.round(y6),
                    origin: options.origin
                  },
                  {
                    type: ActionType.PointerDown,
                    button: 0
                  }
                ]
              }
            ]
          });
        }
        async touchMove(x4, y6, options = {}) {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger",
                parameters: {
                  pointerType: "touch"
                },
                actions: [
                  {
                    type: ActionType.PointerMove,
                    x: Math.round(x4),
                    y: Math.round(y6),
                    origin: options.origin
                  }
                ]
              }
            ]
          });
        }
        async touchEnd() {
          await this.#context.connection.send("input.performActions", {
            context: this.#context.id,
            actions: [
              {
                type: SourceActionsType.Pointer,
                id: "__puppeteer_finger",
                parameters: {
                  pointerType: "touch"
                },
                actions: [
                  {
                    type: ActionType.PointerUp,
                    button: 0
                  }
                ]
              }
            ]
          });
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js
  function headersArray(headers) {
    const result = [];
    for (const name2 in headers) {
      const value = headers[name2];
      if (!Object.is(value, void 0)) {
        const values = Array.isArray(value) ? value : [value];
        result.push(...values.map((value2) => {
          return { name: name2, value: value2 + "" };
        }));
      }
    }
    return result;
  }
  var HTTPRequest, InterceptResolutionAction, STATUS_TEXTS;
  var init_HTTPRequest = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPRequest.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      HTTPRequest = class {
        /**
         * @internal
         */
        _requestId = "";
        /**
         * @internal
         */
        _interceptionId;
        /**
         * @internal
         */
        _failureText = null;
        /**
         * @internal
         */
        _response = null;
        /**
         * @internal
         */
        _fromMemoryCache = false;
        /**
         * @internal
         */
        _redirectChain = [];
        /**
         * @internal
         */
        constructor() {
        }
      };
      (function(InterceptResolutionAction2) {
        InterceptResolutionAction2["Abort"] = "abort";
        InterceptResolutionAction2["Respond"] = "respond";
        InterceptResolutionAction2["Continue"] = "continue";
        InterceptResolutionAction2["Disabled"] = "disabled";
        InterceptResolutionAction2["None"] = "none";
        InterceptResolutionAction2["AlreadyHandled"] = "already-handled";
      })(InterceptResolutionAction || (InterceptResolutionAction = {}));
      STATUS_TEXTS = {
        "100": "Continue",
        "101": "Switching Protocols",
        "102": "Processing",
        "103": "Early Hints",
        "200": "OK",
        "201": "Created",
        "202": "Accepted",
        "203": "Non-Authoritative Information",
        "204": "No Content",
        "205": "Reset Content",
        "206": "Partial Content",
        "207": "Multi-Status",
        "208": "Already Reported",
        "226": "IM Used",
        "300": "Multiple Choices",
        "301": "Moved Permanently",
        "302": "Found",
        "303": "See Other",
        "304": "Not Modified",
        "305": "Use Proxy",
        "306": "Switch Proxy",
        "307": "Temporary Redirect",
        "308": "Permanent Redirect",
        "400": "Bad Request",
        "401": "Unauthorized",
        "402": "Payment Required",
        "403": "Forbidden",
        "404": "Not Found",
        "405": "Method Not Allowed",
        "406": "Not Acceptable",
        "407": "Proxy Authentication Required",
        "408": "Request Timeout",
        "409": "Conflict",
        "410": "Gone",
        "411": "Length Required",
        "412": "Precondition Failed",
        "413": "Payload Too Large",
        "414": "URI Too Long",
        "415": "Unsupported Media Type",
        "416": "Range Not Satisfiable",
        "417": "Expectation Failed",
        "418": "I'm a teapot",
        "421": "Misdirected Request",
        "422": "Unprocessable Entity",
        "423": "Locked",
        "424": "Failed Dependency",
        "425": "Too Early",
        "426": "Upgrade Required",
        "428": "Precondition Required",
        "429": "Too Many Requests",
        "431": "Request Header Fields Too Large",
        "451": "Unavailable For Legal Reasons",
        "500": "Internal Server Error",
        "501": "Not Implemented",
        "502": "Bad Gateway",
        "503": "Service Unavailable",
        "504": "Gateway Timeout",
        "505": "HTTP Version Not Supported",
        "506": "Variant Also Negotiates",
        "507": "Insufficient Storage",
        "508": "Loop Detected",
        "510": "Not Extended",
        "511": "Network Authentication Required"
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js
  var BidiHTTPRequest;
  var init_HTTPRequest2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPRequest.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_HTTPRequest();
      init_Errors();
      BidiHTTPRequest = class extends HTTPRequest {
        _response = null;
        _redirectChain;
        _navigationId;
        #url;
        #resourceType;
        #method;
        #postData;
        #headers = {};
        #initiator;
        #frame;
        constructor(event, frame, redirectChain = []) {
          super();
          this.#url = event.request.url;
          this.#resourceType = event.initiator.type.toLowerCase();
          this.#method = event.request.method;
          this.#postData = void 0;
          this.#initiator = event.initiator;
          this.#frame = frame;
          this._requestId = event.request.request;
          this._redirectChain = redirectChain;
          this._navigationId = event.navigation;
          for (const header of event.request.headers) {
            if (header.value.type === "string") {
              this.#headers[header.name.toLowerCase()] = header.value.value;
            }
          }
        }
        get client() {
          throw new UnsupportedOperation();
        }
        url() {
          return this.#url;
        }
        resourceType() {
          return this.#resourceType;
        }
        method() {
          return this.#method;
        }
        postData() {
          return this.#postData;
        }
        hasPostData() {
          return this.#postData !== void 0;
        }
        async fetchPostData() {
          return this.#postData;
        }
        headers() {
          return this.#headers;
        }
        response() {
          return this._response;
        }
        isNavigationRequest() {
          return Boolean(this._navigationId);
        }
        initiator() {
          return this.#initiator;
        }
        redirectChain() {
          return this._redirectChain.slice();
        }
        enqueueInterceptAction(pendingHandler) {
          void pendingHandler();
        }
        frame() {
          return this.#frame;
        }
        continueRequestOverrides() {
          throw new UnsupportedOperation();
        }
        continue(_overrides = {}) {
          throw new UnsupportedOperation();
        }
        responseForRequest() {
          throw new UnsupportedOperation();
        }
        abortErrorReason() {
          throw new UnsupportedOperation();
        }
        interceptResolutionState() {
          throw new UnsupportedOperation();
        }
        isInterceptResolutionHandled() {
          throw new UnsupportedOperation();
        }
        finalizeInterceptions() {
          throw new UnsupportedOperation();
        }
        abort() {
          throw new UnsupportedOperation();
        }
        respond(_response, _priority) {
          throw new UnsupportedOperation();
        }
        failure() {
          throw new UnsupportedOperation();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js
  var HTTPResponse;
  var init_HTTPResponse = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      HTTPResponse = class {
        /**
         * @internal
         */
        constructor() {
        }
        /**
         * True if the response was successful (status in the range 200-299).
         */
        ok() {
          const status = this.status();
          return status === 0 || status >= 200 && status <= 299;
        }
        /**
         * Promise which resolves to a text representation of response body.
         */
        async text() {
          const content = await this.buffer();
          return content.toString("utf8");
        }
        /**
         * Promise which resolves to a JSON representation of response body.
         *
         * @remarks
         *
         * This method will throw if the response body is not parsable via
         * `JSON.parse`.
         */
        async json() {
          const content = await this.text();
          return JSON.parse(content);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js
  var BidiHTTPResponse;
  var init_HTTPResponse2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/HTTPResponse.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_HTTPResponse();
      init_Errors();
      BidiHTTPResponse = class extends HTTPResponse {
        #request;
        #remoteAddress;
        #status;
        #statusText;
        #url;
        #fromCache;
        #headers = {};
        #timings;
        constructor(request, { response }) {
          super();
          this.#request = request;
          this.#remoteAddress = {
            ip: "",
            port: -1
          };
          this.#url = response.url;
          this.#fromCache = response.fromCache;
          this.#status = response.status;
          this.#statusText = response.statusText;
          this.#timings = null;
          for (const header of response.headers || []) {
            if (header.value.type === "string") {
              this.#headers[header.name.toLowerCase()] = header.value.value;
            }
          }
        }
        remoteAddress() {
          return this.#remoteAddress;
        }
        url() {
          return this.#url;
        }
        status() {
          return this.#status;
        }
        statusText() {
          return this.#statusText;
        }
        headers() {
          return this.#headers;
        }
        request() {
          return this.#request;
        }
        fromCache() {
          return this.#fromCache;
        }
        timing() {
          return this.#timings;
        }
        frame() {
          return this.#request.frame();
        }
        fromServiceWorker() {
          return false;
        }
        securityDetails() {
          throw new UnsupportedOperation();
        }
        buffer() {
          throw new UnsupportedOperation();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/NetworkManager.js
  var BidiNetworkManager;
  var init_NetworkManager = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/NetworkManager.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_EventEmitter();
      init_NetworkManagerEvents();
      init_disposable();
      init_HTTPRequest2();
      init_HTTPResponse2();
      BidiNetworkManager = class extends EventEmitter {
        #connection;
        #page;
        #subscriptions = new DisposableStack();
        #requestMap = /* @__PURE__ */ new Map();
        #navigationMap = /* @__PURE__ */ new Map();
        constructor(connection, page) {
          super();
          this.#connection = connection;
          this.#page = page;
          this.#subscriptions.use(new EventSubscription(this.#connection, "network.beforeRequestSent", this.#onBeforeRequestSent.bind(this)));
          this.#subscriptions.use(new EventSubscription(this.#connection, "network.responseStarted", this.#onResponseStarted.bind(this)));
          this.#subscriptions.use(new EventSubscription(this.#connection, "network.responseCompleted", this.#onResponseCompleted.bind(this)));
          this.#subscriptions.use(new EventSubscription(this.#connection, "network.fetchError", this.#onFetchError.bind(this)));
        }
        #onBeforeRequestSent(event) {
          const frame = this.#page.frame(event.context ?? "");
          if (!frame) {
            return;
          }
          const request = this.#requestMap.get(event.request.request);
          let upsertRequest;
          if (request) {
            request._redirectChain.push(request);
            upsertRequest = new BidiHTTPRequest(event, frame, request._redirectChain);
          } else {
            upsertRequest = new BidiHTTPRequest(event, frame, []);
          }
          this.#requestMap.set(event.request.request, upsertRequest);
          this.emit(NetworkManagerEvent.Request, upsertRequest);
        }
        #onResponseStarted(_event) {
        }
        #onResponseCompleted(event) {
          const request = this.#requestMap.get(event.request.request);
          if (!request) {
            return;
          }
          const response = new BidiHTTPResponse(request, event);
          request._response = response;
          if (event.navigation) {
            this.#navigationMap.set(event.navigation, response);
          }
          if (response.fromCache()) {
            this.emit(NetworkManagerEvent.RequestServedFromCache, request);
          }
          this.emit(NetworkManagerEvent.Response, response);
          this.emit(NetworkManagerEvent.RequestFinished, request);
        }
        #onFetchError(event) {
          const request = this.#requestMap.get(event.request.request);
          if (!request) {
            return;
          }
          request._failureText = event.errorText;
          this.emit(NetworkManagerEvent.RequestFailed, request);
          this.#requestMap.delete(event.request.request);
        }
        getNavigationResponse(navigationId) {
          if (!navigationId) {
            return null;
          }
          const response = this.#navigationMap.get(navigationId);
          return response ?? null;
        }
        inFlightRequestsCount() {
          let inFlightRequestCounter = 0;
          for (const request of this.#requestMap.values()) {
            if (!request.response() || request._failureText) {
              inFlightRequestCounter++;
            }
          }
          return inFlightRequestCounter;
        }
        clearMapAfterFrameDispose(frame) {
          for (const [id, request] of this.#requestMap.entries()) {
            if (request.frame() === frame) {
              this.#requestMap.delete(id);
            }
          }
          for (const [id, response] of this.#navigationMap.entries()) {
            if (response.frame() === frame) {
              this.#navigationMap.delete(id);
            }
          }
        }
        dispose() {
          this.removeAllListeners();
          this.#requestMap.clear();
          this.#navigationMap.clear();
          this.#subscriptions.dispose();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js
  function isConsoleLogEntry(event) {
    return event.type === "console";
  }
  function isJavaScriptLogEntry(event) {
    return event.type === "javascript";
  }
  function getStackTraceLocations(stackTrace) {
    const stackTraceLocations = [];
    if (stackTrace) {
      for (const callFrame of stackTrace.callFrames) {
        stackTraceLocations.push({
          url: callFrame.url,
          lineNumber: callFrame.lineNumber,
          columnNumber: callFrame.columnNumber
        });
      }
    }
    return stackTraceLocations;
  }
  function evaluationExpression(fun, ...args) {
    return `() => {${evaluationString(fun, ...args)}}`;
  }
  var __addDisposableResource10, __disposeResources10, BidiPage;
  var init_Page2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Page.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_rxjs();
      init_Page();
      init_Accessibility();
      init_Coverage();
      init_EmulationManager();
      init_FrameTree();
      init_Tracing();
      init_ConsoleMessage();
      init_Errors();
      init_NetworkManagerEvents();
      init_util2();
      init_assert();
      init_Deferred();
      init_disposable();
      init_ErrorLike();
      init_BrowsingContext();
      init_Deserializer();
      init_Dialog2();
      init_ElementHandle2();
      init_EmulationManager2();
      init_Frame2();
      init_Input2();
      init_lifecycle();
      init_NetworkManager();
      init_Realm();
      __addDisposableResource10 = function(env2, value, async) {
        if (value !== null && value !== void 0) {
          if (typeof value !== "object" && typeof value !== "function")
            throw new TypeError("Object expected.");
          var dispose;
          if (async) {
            if (!Symbol.asyncDispose)
              throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
          }
          if (dispose === void 0) {
            if (!Symbol.dispose)
              throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
          }
          if (typeof dispose !== "function")
            throw new TypeError("Object not disposable.");
          env2.stack.push({ value, dispose, async });
        } else if (async) {
          env2.stack.push({ async: true });
        }
        return value;
      };
      __disposeResources10 = /* @__PURE__ */ function(SuppressedError2) {
        return function(env2) {
          function fail2(e9) {
            env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
            env2.hasError = true;
          }
          function next() {
            while (env2.stack.length) {
              var rec = env2.stack.pop();
              try {
                var result = rec.dispose && rec.dispose.call(rec.value);
                if (rec.async)
                  return Promise.resolve(result).then(next, function(e9) {
                    fail2(e9);
                    return next();
                  });
              } catch (e9) {
                fail2(e9);
              }
            }
            if (env2.hasError)
              throw env2.error;
          }
          return next();
        };
      }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
        var e9 = new Error(message);
        return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
      });
      BidiPage = class extends Page {
        #accessibility;
        #connection;
        #frameTree = new FrameTree();
        #networkManager;
        #viewport = null;
        #closedDeferred = Deferred.create();
        #subscribedEvents = /* @__PURE__ */ new Map([
          ["log.entryAdded", this.#onLogEntryAdded.bind(this)],
          ["browsingContext.load", this.#onFrameLoaded.bind(this)],
          [
            "browsingContext.fragmentNavigated",
            this.#onFrameFragmentNavigated.bind(this)
          ],
          [
            "browsingContext.domContentLoaded",
            this.#onFrameDOMContentLoaded.bind(this)
          ],
          ["browsingContext.userPromptOpened", this.#onDialog.bind(this)]
        ]);
        #networkManagerEvents = [
          [
            NetworkManagerEvent.Request,
            (request) => {
              this.emit("request", request);
            }
          ],
          [
            NetworkManagerEvent.RequestServedFromCache,
            (request) => {
              this.emit("requestservedfromcache", request);
            }
          ],
          [
            NetworkManagerEvent.RequestFailed,
            (request) => {
              this.emit("requestfailed", request);
            }
          ],
          [
            NetworkManagerEvent.RequestFinished,
            (request) => {
              this.emit("requestfinished", request);
            }
          ],
          [
            NetworkManagerEvent.Response,
            (response) => {
              this.emit("response", response);
            }
          ]
        ];
        #browsingContextEvents = /* @__PURE__ */ new Map([
          [BrowsingContextEvent.Created, this.#onContextCreated.bind(this)],
          [BrowsingContextEvent.Destroyed, this.#onContextDestroyed.bind(this)]
        ]);
        #tracing;
        #coverage;
        #cdpEmulationManager;
        #emulationManager;
        #mouse;
        #touchscreen;
        #keyboard;
        #browsingContext;
        #browserContext;
        #target;
        _client() {
          return this.mainFrame().context().cdpSession;
        }
        constructor(browsingContext, browserContext, target) {
          super();
          this.#browsingContext = browsingContext;
          this.#browserContext = browserContext;
          this.#target = target;
          this.#connection = browsingContext.connection;
          for (const [event, subscriber] of this.#browsingContextEvents) {
            this.#browsingContext.on(event, subscriber);
          }
          this.#networkManager = new BidiNetworkManager(this.#connection, this);
          for (const [event, subscriber] of this.#subscribedEvents) {
            this.#connection.on(event, subscriber);
          }
          for (const [event, subscriber] of this.#networkManagerEvents) {
            this.#networkManager.on(event, subscriber);
          }
          const frame = new BidiFrame(this, this.#browsingContext, this._timeoutSettings, this.#browsingContext.parent);
          this.#frameTree.addFrame(frame);
          this.emit("frameattached", frame);
          this.#accessibility = new Accessibility(this.mainFrame().context().cdpSession);
          this.#tracing = new Tracing(this.mainFrame().context().cdpSession);
          this.#coverage = new Coverage(this.mainFrame().context().cdpSession);
          this.#cdpEmulationManager = new EmulationManager(this.mainFrame().context().cdpSession);
          this.#emulationManager = new EmulationManager2(browsingContext);
          this.#mouse = new BidiMouse(this.mainFrame().context());
          this.#touchscreen = new BidiTouchscreen(this.mainFrame().context());
          this.#keyboard = new BidiKeyboard(this);
        }
        /**
         * @internal
         */
        get connection() {
          return this.#connection;
        }
        async setUserAgent(userAgent, userAgentMetadata) {
          await this._client().send("Network.setUserAgentOverride", {
            userAgent,
            userAgentMetadata
          });
        }
        async setBypassCSP(enabled) {
          await this._client().send("Page.setBypassCSP", { enabled });
        }
        async queryObjects(prototypeHandle) {
          assert2(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
          assert2(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
          const response = await this.mainFrame().client.send("Runtime.queryObjects", {
            prototypeObjectId: prototypeHandle.id
          });
          return createBidiHandle(this.mainFrame().mainRealm(), {
            type: "array",
            handle: response.objects.objectId
          });
        }
        _setBrowserContext(browserContext) {
          this.#browserContext = browserContext;
        }
        get accessibility() {
          return this.#accessibility;
        }
        get tracing() {
          return this.#tracing;
        }
        get coverage() {
          return this.#coverage;
        }
        get mouse() {
          return this.#mouse;
        }
        get touchscreen() {
          return this.#touchscreen;
        }
        get keyboard() {
          return this.#keyboard;
        }
        browser() {
          return this.browserContext().browser();
        }
        browserContext() {
          return this.#browserContext;
        }
        mainFrame() {
          const mainFrame = this.#frameTree.getMainFrame();
          assert2(mainFrame, "Requesting main frame too early!");
          return mainFrame;
        }
        /**
         * @internal
         */
        async focusedFrame() {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const frame = __addDisposableResource10(env_1, await this.mainFrame().isolatedRealm().evaluateHandle(() => {
              let frame2;
              let win = window;
              while (win?.document.activeElement instanceof HTMLIFrameElement) {
                frame2 = win.document.activeElement;
                win = frame2.contentWindow;
              }
              return frame2;
            }), false);
            if (!(frame instanceof BidiElementHandle)) {
              return this.mainFrame();
            }
            return await frame.contentFrame();
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources10(env_1);
          }
        }
        frames() {
          return Array.from(this.#frameTree.frames());
        }
        frame(frameId) {
          return this.#frameTree.getById(frameId ?? "") || null;
        }
        childFrames(frameId) {
          return this.#frameTree.childFrames(frameId);
        }
        #onFrameLoaded(info) {
          const frame = this.frame(info.context);
          if (frame && this.mainFrame() === frame) {
            this.emit("load", void 0);
          }
        }
        #onFrameFragmentNavigated(info) {
          const frame = this.frame(info.context);
          if (frame) {
            this.emit("framenavigated", frame);
          }
        }
        #onFrameDOMContentLoaded(info) {
          const frame = this.frame(info.context);
          if (frame) {
            frame._hasStartedLoading = true;
            if (this.mainFrame() === frame) {
              this.emit("domcontentloaded", void 0);
            }
            this.emit("framenavigated", frame);
          }
        }
        #onContextCreated(context) {
          if (!this.frame(context.id) && (this.frame(context.parent ?? "") || !this.#frameTree.getMainFrame())) {
            const frame = new BidiFrame(this, context, this._timeoutSettings, context.parent);
            this.#frameTree.addFrame(frame);
            if (frame !== this.mainFrame()) {
              this.emit("frameattached", frame);
            }
          }
        }
        #onContextDestroyed(context) {
          const frame = this.frame(context.id);
          if (frame) {
            if (frame === this.mainFrame()) {
              this.emit("close", void 0);
            }
            this.#removeFramesRecursively(frame);
          }
        }
        #removeFramesRecursively(frame) {
          for (const child of frame.childFrames()) {
            this.#removeFramesRecursively(child);
          }
          frame[disposeSymbol]();
          this.#networkManager.clearMapAfterFrameDispose(frame);
          this.#frameTree.removeFrame(frame);
          this.emit("framedetached", frame);
        }
        #onLogEntryAdded(event) {
          const frame = this.frame(event.source.context);
          if (!frame) {
            return;
          }
          if (isConsoleLogEntry(event)) {
            const args = event.args.map((arg) => {
              return createBidiHandle(frame.mainRealm(), arg);
            });
            const text = args.reduce((value, arg) => {
              const parsedValue = arg.isPrimitiveValue ? BidiDeserializer.deserialize(arg.remoteValue()) : arg.toString();
              return `${value} ${parsedValue}`;
            }, "").slice(1);
            this.emit("console", new ConsoleMessage(event.method, text, args, getStackTraceLocations(event.stackTrace)));
          } else if (isJavaScriptLogEntry(event)) {
            const error = new Error(event.text ?? "");
            const messageHeight = error.message.split("\n").length;
            const messageLines = error.stack.split("\n").splice(0, messageHeight);
            const stackLines = [];
            if (event.stackTrace) {
              for (const frame2 of event.stackTrace.callFrames) {
                stackLines.push(`    at ${frame2.functionName || "<anonymous>"} (${frame2.url}:${frame2.lineNumber + 1}:${frame2.columnNumber + 1})`);
                if (stackLines.length >= Error.stackTraceLimit) {
                  break;
                }
              }
            }
            error.stack = [...messageLines, ...stackLines].join("\n");
            this.emit("pageerror", error);
          } else {
            debugError(`Unhandled LogEntry with type "${event.type}", text "${event.text}" and level "${event.level}"`);
          }
        }
        #onDialog(event) {
          const frame = this.frame(event.context);
          if (!frame) {
            return;
          }
          const type = validateDialogType(event.type);
          const dialog = new BidiDialog(frame.context(), type, event.message, event.defaultValue);
          this.emit("dialog", dialog);
        }
        getNavigationResponse(id) {
          return this.#networkManager.getNavigationResponse(id);
        }
        isClosed() {
          return this.#closedDeferred.finished();
        }
        async close(options) {
          if (this.#closedDeferred.finished()) {
            return;
          }
          this.#closedDeferred.reject(new TargetCloseError("Page closed!"));
          this.#networkManager.dispose();
          await this.#connection.send("browsingContext.close", {
            context: this.mainFrame()._id,
            promptUnload: options?.runBeforeUnload ?? false
          });
          this.emit("close", void 0);
          this.removeAllListeners();
        }
        async reload(options = {}) {
          const { waitUntil = "load", timeout: ms = this._timeoutSettings.navigationTimeout() } = options;
          const [readiness, networkIdle] = getBiDiReadinessState(waitUntil);
          const response = await fe(this._waitWithNetworkIdle(this.#connection.send("browsingContext.reload", {
            context: this.mainFrame()._id,
            wait: readiness
          }), networkIdle).pipe(Oe(timeout(ms), j(this.#closedDeferred.valueOrThrow()))).pipe(rewriteNavigationError(this.url(), ms)));
          return this.getNavigationResponse(response?.result.navigation);
        }
        setDefaultNavigationTimeout(timeout2) {
          this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
        }
        setDefaultTimeout(timeout2) {
          this._timeoutSettings.setDefaultTimeout(timeout2);
        }
        getDefaultTimeout() {
          return this._timeoutSettings.timeout();
        }
        isJavaScriptEnabled() {
          return this.#cdpEmulationManager.javascriptEnabled;
        }
        async setGeolocation(options) {
          return await this.#cdpEmulationManager.setGeolocation(options);
        }
        async setJavaScriptEnabled(enabled) {
          return await this.#cdpEmulationManager.setJavaScriptEnabled(enabled);
        }
        async emulateMediaType(type) {
          return await this.#cdpEmulationManager.emulateMediaType(type);
        }
        async emulateCPUThrottling(factor) {
          return await this.#cdpEmulationManager.emulateCPUThrottling(factor);
        }
        async emulateMediaFeatures(features2) {
          return await this.#cdpEmulationManager.emulateMediaFeatures(features2);
        }
        async emulateTimezone(timezoneId) {
          return await this.#cdpEmulationManager.emulateTimezone(timezoneId);
        }
        async emulateIdleState(overrides) {
          return await this.#cdpEmulationManager.emulateIdleState(overrides);
        }
        async emulateVisionDeficiency(type) {
          return await this.#cdpEmulationManager.emulateVisionDeficiency(type);
        }
        async setViewport(viewport) {
          if (!this.#browsingContext.supportsCdp()) {
            await this.#emulationManager.emulateViewport(viewport);
            this.#viewport = viewport;
            return;
          }
          const needsReload = await this.#cdpEmulationManager.emulateViewport(viewport);
          this.#viewport = viewport;
          if (needsReload) {
            await this.reload();
          }
        }
        viewport() {
          return this.#viewport;
        }
        async pdf(options = {}) {
          const { path: path2 = void 0 } = options;
          const { printBackground: background, margin, landscape, width, height, pageRanges: ranges, scale, preferCSSPageSize, timeout: ms } = this._getPDFOptions(options, "cm");
          const pageRanges = ranges ? ranges.split(", ") : [];
          const { result } = await fe(j(this.#connection.send("browsingContext.print", {
            context: this.mainFrame()._id,
            background,
            margin,
            orientation: landscape ? "landscape" : "portrait",
            page: {
              width,
              height
            },
            pageRanges,
            scale,
            shrinkToFit: !preferCSSPageSize
          })).pipe(Oe(timeout(ms))));
          const buffer2 = Buffer2.from(result.data, "base64");
          await this._maybeWriteBufferToFile(path2, buffer2);
          return buffer2;
        }
        async createPDFStream(options) {
          const buffer2 = await this.pdf(options);
          try {
            const { Readable: Readable2 } = await Promise.resolve().then(() => (init_stream(), stream_exports));
            return Readable2.from(buffer2);
          } catch (error) {
            if (error instanceof TypeError) {
              throw new Error("Can only pass a file path in a Node-like environment.");
            }
            throw error;
          }
        }
        async _screenshot(options) {
          const { clip, type, captureBeyondViewport, quality } = options;
          if (options.omitBackground !== void 0 && options.omitBackground) {
            throw new UnsupportedOperation(`BiDi does not support 'omitBackground'.`);
          }
          if (options.optimizeForSpeed !== void 0 && options.optimizeForSpeed) {
            throw new UnsupportedOperation(`BiDi does not support 'optimizeForSpeed'.`);
          }
          if (options.fromSurface !== void 0 && !options.fromSurface) {
            throw new UnsupportedOperation(`BiDi does not support 'fromSurface'.`);
          }
          if (clip !== void 0 && clip.scale !== void 0 && clip.scale !== 1) {
            throw new UnsupportedOperation(`BiDi does not support 'scale' in 'clip'.`);
          }
          let box;
          if (clip) {
            if (captureBeyondViewport) {
              box = clip;
            } else {
              const [pageLeft, pageTop] = await this.evaluate(() => {
                if (!window.visualViewport) {
                  throw new Error("window.visualViewport is not supported.");
                }
                return [
                  window.visualViewport.pageLeft,
                  window.visualViewport.pageTop
                ];
              });
              box = {
                ...clip,
                x: clip.x - pageLeft,
                y: clip.y - pageTop
              };
            }
          }
          const { result: { data } } = await this.#connection.send("browsingContext.captureScreenshot", {
            context: this.mainFrame()._id,
            origin: captureBeyondViewport ? "document" : "viewport",
            format: {
              type: `image/${type}`,
              ...quality !== void 0 ? { quality: quality / 100 } : {}
            },
            ...box ? { clip: { type: "box", ...box } } : {}
          });
          return data;
        }
        async waitForRequest(urlOrPredicate, options = {}) {
          const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
          return await waitForHTTP(this.#networkManager, NetworkManagerEvent.Request, urlOrPredicate, timeout2, this.#closedDeferred);
        }
        async waitForResponse(urlOrPredicate, options = {}) {
          const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
          return await waitForHTTP(this.#networkManager, NetworkManagerEvent.Response, urlOrPredicate, timeout2, this.#closedDeferred);
        }
        async waitForNetworkIdle(options = {}) {
          const { idleTime = NETWORK_IDLE_TIME, timeout: ms = this._timeoutSettings.timeout() } = options;
          await fe(this._waitForNetworkIdle(this.#networkManager, idleTime).pipe(Oe(timeout(ms), j(this.#closedDeferred.valueOrThrow()))));
        }
        /** @internal */
        _waitWithNetworkIdle(observableInput, networkIdle) {
          const delay = networkIdle ? this._waitForNetworkIdle(this.#networkManager, NETWORK_IDLE_TIME, networkIdle === "networkidle0" ? 0 : 2) : j(Promise.resolve());
          return le([
            j(observableInput).pipe(Ee()),
            delay.pipe(Ee())
          ]).pipe(k(([response]) => {
            return response;
          }));
        }
        async createCDPSession() {
          const { sessionId } = await this.mainFrame().context().cdpSession.send("Target.attachToTarget", {
            targetId: this.mainFrame()._id,
            flatten: true
          });
          return new CdpSessionWrapper(this.mainFrame().context(), sessionId);
        }
        async bringToFront() {
          await this.#connection.send("browsingContext.activate", {
            context: this.mainFrame()._id
          });
        }
        async evaluateOnNewDocument(pageFunction, ...args) {
          const expression = evaluationExpression(pageFunction, ...args);
          const { result } = await this.#connection.send("script.addPreloadScript", {
            functionDeclaration: expression,
            contexts: [this.mainFrame()._id]
          });
          return { identifier: result.script };
        }
        async removeScriptToEvaluateOnNewDocument(id) {
          await this.#connection.send("script.removePreloadScript", {
            script: id
          });
        }
        async exposeFunction(name2, pptrFunction) {
          return await this.mainFrame().exposeFunction(name2, "default" in pptrFunction ? pptrFunction.default : pptrFunction);
        }
        isDragInterceptionEnabled() {
          return false;
        }
        async setCacheEnabled(enabled) {
          await this._client().send("Network.setCacheDisabled", {
            cacheDisabled: !enabled
          });
        }
        isServiceWorkerBypassed() {
          throw new UnsupportedOperation();
        }
        target() {
          return this.#target;
        }
        waitForFileChooser() {
          throw new UnsupportedOperation();
        }
        workers() {
          throw new UnsupportedOperation();
        }
        setRequestInterception() {
          throw new UnsupportedOperation();
        }
        setDragInterception() {
          throw new UnsupportedOperation();
        }
        setBypassServiceWorker() {
          throw new UnsupportedOperation();
        }
        setOfflineMode() {
          throw new UnsupportedOperation();
        }
        emulateNetworkConditions() {
          throw new UnsupportedOperation();
        }
        cookies() {
          throw new UnsupportedOperation();
        }
        setCookie() {
          throw new UnsupportedOperation();
        }
        deleteCookie() {
          throw new UnsupportedOperation();
        }
        removeExposedFunction() {
          throw new UnsupportedOperation();
        }
        authenticate() {
          throw new UnsupportedOperation();
        }
        setExtraHTTPHeaders() {
          throw new UnsupportedOperation();
        }
        metrics() {
          throw new UnsupportedOperation();
        }
        async goBack(options = {}) {
          return await this.#go(-1, options);
        }
        async goForward(options = {}) {
          return await this.#go(1, options);
        }
        async #go(delta, options) {
          try {
            const result = await Promise.all([
              this.waitForNavigation(options),
              this.#connection.send("browsingContext.traverseHistory", {
                delta,
                context: this.mainFrame()._id
              })
            ]);
            return result[0];
          } catch (err) {
            if (isErrorLike(err)) {
              if (err.message.includes("no such history entry")) {
                return null;
              }
            }
            throw err;
          }
        }
        waitForDevicePrompt() {
          throw new UnsupportedOperation();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js
  var BidiTarget, BiDiBrowserTarget, BiDiBrowsingContextTarget, BiDiPageTarget;
  var init_Target2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Target.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Target();
      init_Errors();
      init_BrowsingContext();
      init_Page2();
      BidiTarget = class extends Target {
        _browserContext;
        constructor(browserContext) {
          super();
          this._browserContext = browserContext;
        }
        _setBrowserContext(browserContext) {
          this._browserContext = browserContext;
        }
        asPage() {
          throw new UnsupportedOperation();
        }
        browser() {
          return this._browserContext.browser();
        }
        browserContext() {
          return this._browserContext;
        }
        opener() {
          throw new UnsupportedOperation();
        }
        createCDPSession() {
          throw new UnsupportedOperation();
        }
      };
      BiDiBrowserTarget = class extends BidiTarget {
        url() {
          return "";
        }
        type() {
          return TargetType.BROWSER;
        }
      };
      BiDiBrowsingContextTarget = class extends BidiTarget {
        _browsingContext;
        constructor(browserContext, browsingContext) {
          super(browserContext);
          this._browsingContext = browsingContext;
        }
        url() {
          return this._browsingContext.url;
        }
        async createCDPSession() {
          const { sessionId } = await this._browsingContext.cdpSession.send("Target.attachToTarget", {
            targetId: this._browsingContext.id,
            flatten: true
          });
          return new CdpSessionWrapper(this._browsingContext, sessionId);
        }
        type() {
          return TargetType.PAGE;
        }
      };
      BiDiPageTarget = class extends BiDiBrowsingContextTarget {
        #page;
        constructor(browserContext, browsingContext) {
          super(browserContext, browsingContext);
          this.#page = new BidiPage(browsingContext, browserContext, this);
        }
        async page() {
          return this.#page;
        }
        _setBrowserContext(browserContext) {
          super._setBrowserContext(browserContext);
          this.#page._setBrowserContext(browserContext);
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js
  var BidiBrowser;
  var init_Browser2 = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/Browser.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_Browser();
      init_Errors();
      init_util2();
      init_BrowserContext2();
      init_BrowsingContext();
      init_Target2();
      BidiBrowser = class _BidiBrowser extends Browser {
        protocol = "webDriverBiDi";
        // TODO: Update generator to include fully module
        static subscribeModules = [
          "browsingContext",
          "network",
          "log",
          "script"
        ];
        static subscribeCdpEvents = [
          // Coverage
          "cdp.Debugger.scriptParsed",
          "cdp.CSS.styleSheetAdded",
          "cdp.Runtime.executionContextsCleared",
          // Tracing
          "cdp.Tracing.tracingComplete",
          // TODO: subscribe to all CDP events in the future.
          "cdp.Network.requestWillBeSent",
          "cdp.Debugger.scriptParsed",
          "cdp.Page.screencastFrame"
        ];
        static async create(opts) {
          let browserName = "";
          let browserVersion = "";
          try {
            const { result } = await opts.connection.send("session.new", {
              capabilities: {
                alwaysMatch: {
                  acceptInsecureCerts: opts.ignoreHTTPSErrors
                }
              }
            });
            browserName = result.capabilities.browserName ?? "";
            browserVersion = result.capabilities.browserVersion ?? "";
          } catch (err) {
            debugError(err);
          }
          await opts.connection.send("session.subscribe", {
            events: browserName.toLocaleLowerCase().includes("firefox") ? _BidiBrowser.subscribeModules : [..._BidiBrowser.subscribeModules, ..._BidiBrowser.subscribeCdpEvents]
          });
          const browser = new _BidiBrowser({
            ...opts,
            browserName,
            browserVersion
          });
          await browser.#getTree();
          return browser;
        }
        #browserName = "";
        #browserVersion = "";
        #process;
        #closeCallback;
        #connection;
        #defaultViewport;
        #defaultContext;
        #targets = /* @__PURE__ */ new Map();
        #contexts = [];
        #browserTarget;
        #connectionEventHandlers = /* @__PURE__ */ new Map([
          ["browsingContext.contextCreated", this.#onContextCreated.bind(this)],
          ["browsingContext.contextDestroyed", this.#onContextDestroyed.bind(this)],
          ["browsingContext.domContentLoaded", this.#onContextDomLoaded.bind(this)],
          ["browsingContext.fragmentNavigated", this.#onContextNavigation.bind(this)],
          ["browsingContext.navigationStarted", this.#onContextNavigation.bind(this)]
        ]);
        constructor(opts) {
          super();
          this.#process = opts.process;
          this.#closeCallback = opts.closeCallback;
          this.#connection = opts.connection;
          this.#defaultViewport = opts.defaultViewport;
          this.#browserName = opts.browserName;
          this.#browserVersion = opts.browserVersion;
          this.#process?.once("close", () => {
            this.#connection.dispose();
            this.emit("disconnected", void 0);
          });
          this.#defaultContext = new BidiBrowserContext(this, {
            defaultViewport: this.#defaultViewport,
            isDefault: true
          });
          this.#browserTarget = new BiDiBrowserTarget(this.#defaultContext);
          this.#contexts.push(this.#defaultContext);
          for (const [eventName, handler] of this.#connectionEventHandlers) {
            this.#connection.on(eventName, handler);
          }
        }
        userAgent() {
          throw new UnsupportedOperation();
        }
        #onContextDomLoaded(event) {
          const target = this.#targets.get(event.context);
          if (target) {
            this.emit("targetchanged", target);
          }
        }
        #onContextNavigation(event) {
          const target = this.#targets.get(event.context);
          if (target) {
            this.emit("targetchanged", target);
            target.browserContext().emit("targetchanged", target);
          }
        }
        #onContextCreated(event) {
          const context = new BrowsingContext(this.#connection, event, this.#browserName);
          this.#connection.registerBrowsingContexts(context);
          const browserContext = this.browserContexts().at(-1);
          if (!browserContext) {
            throw new Error("Missing browser contexts");
          }
          const target = !context.parent ? new BiDiPageTarget(browserContext, context) : new BiDiBrowsingContextTarget(browserContext, context);
          this.#targets.set(event.context, target);
          this.emit("targetcreated", target);
          target.browserContext().emit("targetcreated", target);
          if (context.parent) {
            const topLevel = this.#connection.getTopLevelContext(context.parent);
            topLevel.emit(BrowsingContextEvent.Created, context);
          }
        }
        async #getTree() {
          const { result } = await this.#connection.send("browsingContext.getTree", {});
          for (const context of result.contexts) {
            this.#onContextCreated(context);
          }
        }
        async #onContextDestroyed(event) {
          const context = this.#connection.getBrowsingContext(event.context);
          const topLevelContext = this.#connection.getTopLevelContext(event.context);
          topLevelContext.emit(BrowsingContextEvent.Destroyed, context);
          const target = this.#targets.get(event.context);
          const page = await target?.page();
          await page?.close().catch(debugError);
          this.#targets.delete(event.context);
          if (target) {
            this.emit("targetdestroyed", target);
            target.browserContext().emit("targetdestroyed", target);
          }
        }
        get connection() {
          return this.#connection;
        }
        wsEndpoint() {
          return this.#connection.url;
        }
        async close() {
          for (const [eventName, handler] of this.#connectionEventHandlers) {
            this.#connection.off(eventName, handler);
          }
          if (this.#connection.closed) {
            return;
          }
          await this.#connection.send("browser.close", {}).catch(debugError);
          await this.#closeCallback?.call(null);
          this.#connection.dispose();
        }
        get connected() {
          return !this.#connection.closed;
        }
        process() {
          return this.#process ?? null;
        }
        async createIncognitoBrowserContext(_options) {
          const context = new BidiBrowserContext(this, {
            defaultViewport: this.#defaultViewport,
            isDefault: false
          });
          this.#contexts.push(context);
          return context;
        }
        async version() {
          return `${this.#browserName}/${this.#browserVersion}`;
        }
        browserContexts() {
          return this.#contexts;
        }
        async _closeContext(browserContext) {
          this.#contexts = this.#contexts.filter((c7) => {
            return c7 !== browserContext;
          });
          for (const target of browserContext.targets()) {
            const page = await target?.page();
            await page?.close().catch((error) => {
              debugError(error);
            });
          }
        }
        defaultBrowserContext() {
          return this.#defaultContext;
        }
        newPage() {
          return this.#defaultContext.newPage();
        }
        targets() {
          return [this.#browserTarget, ...Array.from(this.#targets.values())];
        }
        _getTargetById(id) {
          const target = this.#targets.get(id);
          if (!target) {
            throw new Error("Target not found");
          }
          return target;
        }
        target() {
          return this.#browserTarget;
        }
        async disconnect() {
          try {
            await this.#connection.send("session.end", {});
          } catch (e9) {
            debugError(e9);
          }
          this.#connection.dispose();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js
  var bidi_exports = {};
  __export(bidi_exports, {
    BiDiBrowserTarget: () => BiDiBrowserTarget,
    BiDiBrowsingContextTarget: () => BiDiBrowsingContextTarget,
    BiDiPageTarget: () => BiDiPageTarget,
    BidiBrowser: () => BidiBrowser,
    BidiBrowserContext: () => BidiBrowserContext,
    BidiConnection: () => BidiConnection,
    BidiElementHandle: () => BidiElementHandle,
    BidiFrame: () => BidiFrame,
    BidiHTTPRequest: () => BidiHTTPRequest,
    BidiHTTPResponse: () => BidiHTTPResponse,
    BidiJSHandle: () => BidiJSHandle,
    BidiKeyboard: () => BidiKeyboard,
    BidiMouse: () => BidiMouse,
    BidiNetworkManager: () => BidiNetworkManager,
    BidiPage: () => BidiPage,
    BidiRealm: () => BidiRealm,
    BidiTarget: () => BidiTarget,
    BidiTouchscreen: () => BidiTouchscreen,
    BrowsingContext: () => BrowsingContext,
    BrowsingContextEvent: () => BrowsingContextEvent,
    CdpSessionWrapper: () => CdpSessionWrapper,
    MAIN_SANDBOX: () => MAIN_SANDBOX,
    PUPPETEER_SANDBOX: () => PUPPETEER_SANDBOX,
    Sandbox: () => Sandbox,
    cdpSessions: () => cdpSessions,
    connectBidiOverCdp: () => connectBidiOverCdp,
    createBidiHandle: () => createBidiHandle
  });
  var init_bidi = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/bidi/bidi.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      init_BidiOverCdp();
      init_Browser2();
      init_BrowserContext2();
      init_BrowsingContext();
      init_Connection();
      init_ElementHandle2();
      init_Frame2();
      init_HTTPRequest2();
      init_HTTPResponse2();
      init_Input2();
      init_JSHandle2();
      init_NetworkManager();
      init_Page2();
      init_Realm();
      init_Sandbox();
      init_Target2();
    }
  });

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports8, module) {
      init_dirname();
      init_buffer2();
      init_process2();
      var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
      var __globalThis__ = function() {
        function F5() {
          this.fetch = false;
          this.DOMException = __global__.DOMException;
        }
        F5.prototype = __global__;
        return new F5();
      }();
      (function(globalThis2) {
        var irrelevant = function(exports9) {
          var global2 = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || typeof global2 !== "undefined" && global2;
          var support = {
            searchParams: "URLSearchParams" in global2,
            iterable: "Symbol" in global2 && "iterator" in Symbol,
            blob: "FileReader" in global2 && "Blob" in global2 && function() {
              try {
                new Blob();
                return true;
              } catch (e9) {
                return false;
              }
            }(),
            formData: "FormData" in global2,
            arrayBuffer: "ArrayBuffer" in global2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name2) {
            if (typeof name2 !== "string") {
              name2 = String(name2);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name2) || name2 === "") {
              throw new TypeError('Invalid character in header field name: "' + name2 + '"');
            }
            return name2.toLowerCase();
          }
          function normalizeValue2(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name2) {
                this.append(name2, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name2) {
                this.append(name2, headers[name2]);
              }, this);
            }
          }
          Headers.prototype.append = function(name2, value) {
            name2 = normalizeName(name2);
            value = normalizeValue2(value);
            var oldValue = this.map[name2];
            this.map[name2] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name2) {
            delete this.map[normalizeName(name2)];
          };
          Headers.prototype.get = function(name2) {
            name2 = normalizeName(name2);
            return this.has(name2) ? this.map[name2] : null;
          };
          Headers.prototype.has = function(name2) {
            return this.map.hasOwnProperty(normalizeName(name2));
          };
          Headers.prototype.set = function(name2, value) {
            this.map[normalizeName(name2)] = normalizeValue2(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name2 in this.map) {
              if (this.map.hasOwnProperty(name2)) {
                callback.call(thisArg, this.map[name2], name2, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push(name2);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push([name2, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve3, reject) {
              reader.onload = function() {
                resolve3(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i7 = 0; i7 < view.length; i7++) {
              chars[i7] = String.fromCharCode(view[i7]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this.bodyUsed = this.bodyUsed;
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  var isConsumed = consumed(this);
                  if (isConsumed) {
                    return isConsumed;
                  }
                  if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                    return Promise.resolve(
                      this._bodyArrayBuffer.buffer.slice(
                        this._bodyArrayBuffer.byteOffset,
                        this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                      )
                    );
                  } else {
                    return Promise.resolve(this._bodyArrayBuffer);
                  }
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options) {
            if (!(this instanceof Request)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || "same-origin";
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || "GET");
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
            if (this.method === "GET" || this.method === "HEAD") {
              if (options.cache === "no-store" || options.cache === "no-cache") {
                var reParamSearch = /([?&])_=[^&]*/;
                if (reParamSearch.test(this.url)) {
                  this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
                } else {
                  var reQueryString = /\?/;
                  this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
                }
              }
            }
          }
          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit });
          };
          function decode(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split("=");
                var name2 = split.shift().replace(/\+/g, " ");
                var value = split.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name2), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split("\r").map(function(header) {
              return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
            }).forEach(function(line) {
              var parts = line.split(":");
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(":").trim();
                headers.append(key, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!(this instanceof Response)) {
              throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
            }
            if (!options) {
              options = {};
            }
            this.type = "default";
            this.status = options.status === void 0 ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
            this.headers = new Headers(options.headers);
            this.url = options.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports9.DOMException = global2.DOMException;
          try {
            new exports9.DOMException();
          } catch (err) {
            exports9.DOMException = function(message, name2) {
              this.message = message;
              this.name = name2;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports9.DOMException.prototype = Object.create(Error.prototype);
            exports9.DOMException.prototype.constructor = exports9.DOMException;
          }
          function fetch2(input, init2) {
            return new Promise(function(resolve3, reject) {
              var request = new Request(input, init2);
              if (request.signal && request.signal.aborted) {
                return reject(new exports9.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                setTimeout(function() {
                  resolve3(new Response(body, options));
                }, 0);
              };
              xhr.onerror = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request failed"));
                }, 0);
              };
              xhr.ontimeout = function() {
                setTimeout(function() {
                  reject(new TypeError("Network request failed"));
                }, 0);
              };
              xhr.onabort = function() {
                setTimeout(function() {
                  reject(new exports9.DOMException("Aborted", "AbortError"));
                }, 0);
              };
              function fixUrl(url) {
                try {
                  return url === "" && global2.location.href ? global2.location.href : url;
                } catch (e9) {
                  return url;
                }
              }
              xhr.open(request.method, fixUrl(request.url), true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr) {
                if (support.blob) {
                  xhr.responseType = "blob";
                } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
                  xhr.responseType = "arraybuffer";
                }
              }
              if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
                Object.getOwnPropertyNames(init2.headers).forEach(function(name2) {
                  xhr.setRequestHeader(name2, normalizeValue2(init2.headers[name2]));
                });
              } else {
                request.headers.forEach(function(value, name2) {
                  xhr.setRequestHeader(name2, value);
                });
              }
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch2.polyfill = true;
          if (!global2.fetch) {
            global2.fetch = fetch2;
            global2.Headers = Headers;
            global2.Request = Request;
            global2.Response = Response;
          }
          exports9.Headers = Headers;
          exports9.Request = Request;
          exports9.Response = Response;
          exports9.fetch = fetch2;
          return exports9;
        }({});
      })(__globalThis__);
      __globalThis__.fetch.ponyfill = true;
      delete __globalThis__.fetch.polyfill;
      var ctx = __global__.fetch ? __global__ : __globalThis__;
      exports8 = ctx.fetch;
      exports8.default = ctx.fetch;
      exports8.fetch = ctx.fetch;
      exports8.Headers = ctx.Headers;
      exports8.Request = ctx.Request;
      exports8.Response = ctx.Response;
      module.exports = exports8;
    }
  });

  // node_modules/ws/browser.js
  var require_browser2 = __commonJS({
    "node_modules/ws/browser.js"(exports8, module) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      module.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/generated/version.js
  var packageVersion;
  var init_version = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/generated/version.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      packageVersion = "21.7.0";
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js
  var NodeWebSocketTransport_exports = {};
  __export(NodeWebSocketTransport_exports, {
    NodeWebSocketTransport: () => NodeWebSocketTransport
  });
  var import_ws, NodeWebSocketTransport;
  var init_NodeWebSocketTransport = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      import_ws = __toESM(require_browser2(), 1);
      init_version();
      NodeWebSocketTransport = class _NodeWebSocketTransport {
        static create(url, headers) {
          return new Promise((resolve3, reject) => {
            const ws = new import_ws.default(url, [], {
              followRedirects: true,
              perMessageDeflate: false,
              maxPayload: 256 * 1024 * 1024,
              // 256Mb
              headers: {
                "User-Agent": `Puppeteer ${packageVersion}`,
                ...headers
              }
            });
            ws.addEventListener("open", () => {
              return resolve3(new _NodeWebSocketTransport(ws));
            });
            ws.addEventListener("error", reject);
          });
        }
        #ws;
        onmessage;
        onclose;
        constructor(ws) {
          this.#ws = ws;
          this.#ws.addEventListener("message", (event) => {
            if (this.onmessage) {
              this.onmessage.call(null, event.data);
            }
          });
          this.#ws.addEventListener("close", () => {
            if (this.onclose) {
              this.onclose.call(null);
            }
          });
          this.#ws.addEventListener("error", () => {
          });
        }
        send(message) {
          this.#ws.send(message);
        }
        close() {
          this.#ws.close();
        }
      };
    }
  });

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js
  var BrowserWebSocketTransport_exports = {};
  __export(BrowserWebSocketTransport_exports, {
    BrowserWebSocketTransport: () => BrowserWebSocketTransport
  });
  var BrowserWebSocketTransport;
  var init_BrowserWebSocketTransport = __esm({
    "node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserWebSocketTransport.js"() {
      init_dirname();
      init_buffer2();
      init_process2();
      BrowserWebSocketTransport = class _BrowserWebSocketTransport {
        static create(url) {
          return new Promise((resolve3, reject) => {
            const ws = new WebSocket(url);
            ws.addEventListener("open", () => {
              return resolve3(new _BrowserWebSocketTransport(ws));
            });
            ws.addEventListener("error", reject);
          });
        }
        #ws;
        onmessage;
        onclose;
        constructor(ws) {
          this.#ws = ws;
          this.#ws.addEventListener("message", (event) => {
            if (this.onmessage) {
              this.onmessage.call(null, event.data);
            }
          });
          this.#ws.addEventListener("close", () => {
            if (this.onclose) {
              this.onclose.call(null);
            }
          });
          this.#ws.addEventListener("error", () => {
          });
        }
        send(message) {
          this.#ws.send(message);
        }
        close() {
          this.#ws.close();
        }
      };
    }
  });

  // node_modules/puppeteer-extension-transport/build/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/puppeteer-extension-transport/build/lib/index.js"(exports8) {
      "use strict";
      init_dirname();
      init_buffer2();
      init_process2();
      var __awaiter = exports8 && exports8.__awaiter || function(thisArg, _arguments, P5, generator) {
        function adopt(value) {
          return value instanceof P5 ? value : new P5(function(resolve3) {
            resolve3(value);
          });
        }
        return new (P5 || (P5 = Promise))(function(resolve3, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e9) {
              reject(e9);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e9) {
              reject(e9);
            }
          }
          function step(result) {
            result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      Object.defineProperty(exports8, "__esModule", { value: true });
      exports8.ExtensionDebuggerTransport = void 0;
      var ExtensionDebuggerTransport2 = class _ExtensionDebuggerTransport {
        constructor(target) {
          this.delay = 0.04 * 1e3;
          this.target = target;
          this._sessionId = target.id;
          this.debugee = {
            tabId: target.tabId
          };
          chrome.debugger.onEvent.addListener((source2, method, params) => {
            const event = {
              method,
              params,
              sessionId: this._sessionId
            };
            source2.tabId === this.target.tabId ? this._emit(event) : null;
          });
          chrome.debugger.onDetach.addListener((source2) => {
            source2.tabId === this.target.tabId ? this._closeTarget() : null;
          });
        }
        /**
         * Returns a puppeteer connection transport instance for extension.
         * @example
         * How to use it:
         * ```javascript
         * const extensionTransport = await ExtensionDebuggerTransport.create(tabId)
         * const browser = await puppeteer.connect({
         *  transport: extensionTransport,
         *  defaultViewport: null
         * })
         *
         * // use first page from pages instead of using browser.newPage()
         * const [page] = await browser.pages()
         * await page.goto('https://wikipedia.org')
         * ```
         *
         * @param tabId - The id of tab to target. You can get this using chrome.tabs api
         * @param functionSerializer - Optional function serializer. If not specified and
         * if extension's manifest.json contains `unsafe_eval` then defaults to `new Function()`
         * else defaults to `() => {}`
         * @returns - The instance of {@link ExtensionDebuggerTransport}
         *
         * @throws Error
         * If debugger permission not given to extension
         */
        static create(tabId, functionSerializer) {
          if (chrome.debugger) {
            const debugee = {
              tabId
            };
            return new Promise((resolve3, reject) => {
              chrome.debugger.attach(debugee, "1.3", () => __awaiter(this, void 0, void 0, function* () {
                const error = chrome.runtime.lastError;
                if (!error) {
                  const target = yield this._getTargetInfo(debugee);
                  const transport = new _ExtensionDebuggerTransport(target);
                  transport._initialize(functionSerializer);
                  resolve3(transport);
                } else {
                  reject(error);
                }
              }));
            });
          } else {
            throw new Error("no debugger permission");
          }
        }
        /** @internal */
        send(message) {
          const command = JSON.parse(message);
          
const targetCommands = [
  "Target.getBrowserContexts",
  "Target.setDiscoverTargets",
  "Target.attachToTarget",
  "Target.activateTarget",
  "Target.closeTarget",
  "Target.setAutoAttach",
];
const browserCommands = ["Browser.getVersion"];
if (browserCommands.includes(command.method)) {
  this._handleBrowserCommand(command);
} else if (targetCommands.includes(command.method)) {
  this._handleTargetCommand(command);

          } else {
            chrome.debugger.sendCommand(this.debugee, command.method, command.params, (result) => this._handleCommandResponse(command, result));
          }
        }
        /** @internal */
        close() {
          chrome.debugger.detach(this.debugee, () => this._closeTarget());
        }
        static _getTargetInfo(debugee) {
          return new Promise((resolve3, reject) => {
            chrome.debugger.getTargets((targets) => {
              const target = targets.filter((target2) => target2.attached && target2.tabId === debugee.tabId).map((target2) => {
                return Object.assign(Object.assign({}, target2), { targetId: target2.id, canAccessOpener: false });
              });
              target[0] ? resolve3(target[0]) : reject(new Error("target not found"));
            });
          });
        }
        _initialize(functionSerializer) {
          if (functionSerializer) {
            Function = functionSerializer;
          } else {
            try {
              new Function();
            } catch (e9) {
              Function = function() {
                return () => {
                };
              };
            }
          }
        }
        _handleCommandResponse(command, result) {
          const error = chrome.runtime.lastError;
          const response = Object.assign(Object.assign({}, command), { error, result });
          this._delaySend(response);
        }
        
                _handleBrowserCommand(command) {
                    const response = Object.assign(Object.assign({}, command), {
                        error: void 0,
                        result: {},
                    });

                    response.result = {
                        product: "chrome",
                    };
                    this._delaySend(response);
                }
                _handleTargetCommand(command) {
          const response = Object.assign(Object.assign({}, command), { error: void 0, result: {} });
          switch (command.method) {
            case "Target.getBrowserContexts":
              response.result = {
                browserContextIds: []
              };
              break;
            case "Target.setDiscoverTargets":
              response.result = null;
              this._emitTargetCreated();
              break;
            
                        case "Target.setAutoAttach":
                        case "Target.attachToTarget":
                            
              response.result = {
                sessionId: this._sessionId
              };
              this._emitTargetAttached();
              break;
            case "Target.activateTarget":
              response.result = null;
              break;
            case "Target.closeTarget":
              response.result = {
                success: true
              };
              setTimeout(() => this.close(), this.delay);
              break;
          }
          this._delaySend(response);
        }
        _emitTargetCreated() {
          const event = {
            method: "Target.targetCreated",
            params: {
              targetInfo: this.target
            }
          };
          this._emit(event);
        }
        
                _emitTargetAttached() {
                    if (this._attached) {
                        return;
                    }
                    this._attached = true;
                    
          const event = {
            method: "Target.attachedToTarget",
            params: {
              targetInfo: this.target,
              sessionId: this._sessionId,
              waitingForDebugger: false
            }
          };
          this._emit(event);
        }
        _emitTargetDetached() {
          const event = {
            method: "Target.detachedFromTarget",
            params: {
              targetId: this.target.id,
              sessionId: this._sessionId
            }
          };
          this._emit(event);
        }
        _closeTarget() {
          var _a;
          this._emitTargetDetached();
          (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(null);
        }
        _emit(event) {
          var _a;
          (_a = this === null || this === void 0 ? void 0 : this.onmessage) === null || _a === void 0 ? void 0 : _a.call(null, JSON.stringify(event));
        }
        _delaySend(response) {
          setTimeout(() => {
            var _a;
            (_a = this === null || this === void 0 ? void 0 : this.onmessage) === null || _a === void 0 ? void 0 : _a.call(null, JSON.stringify(response));
          }, this.delay);
        }
      };
      exports8.ExtensionDebuggerTransport = ExtensionDebuggerTransport2;
    }
  });

  // extension/background.mjs
  init_dirname();
  init_buffer2();
  init_process2();

  // index.mjs
  init_dirname();
  init_buffer2();
  init_process2();

  // transports/chrome.runtime.connect.mjs
  init_dirname();
  init_buffer2();
  init_process2();

  // transport.mjs
  init_dirname();
  init_buffer2();
  init_process2();
  var Transport = class _Transport extends EventTarget {
    constructor() {
      super();
      if (new.target === _Transport) {
        throw new TypeError(
          "Cannot construct Transport instances directly"
        );
      }
      this.ready = new Promise((resolve3) => {
        this._ready = resolve3;
      });
    }
    async send(data) {
      throw new Error("Method 'send' not implemented");
    }
    receive(callback) {
      this.callback = callback;
    }
  };

  // transports/chrome.runtime.connect.mjs
  var ChromeExtensionBackgroundTransport = class extends Transport {
    constructor() {
      super();
      chrome.runtime.onConnectExternal.addListener((port) => {
        this.port = port;
        this.port.onMessage.addListener((message) => {
          this.callback?.(message);
        });
        this._ready();
      });
    }
    async send(data) {
      this.port.postMessage(data);
    }
  };

  // rpc.mjs
  init_dirname();
  init_buffer2();
  init_process2();
  var import_is_pojo = __toESM(require_is_pojo(), 1);
  function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(c7) {
        var r9 = Math.random() * 16 | 0, v7 = c7 === "x" ? r9 : r9 & 3 | 8;
        return v7.toString(16);
      }
    );
  }
  var Server = class _Server {
    static objects = /* @__PURE__ */ new Map();
    constructor(object, id = uuidv4(), transport) {
      console.log("RPCServer", id, object);
      this.id = id;
      _Server.objects.set(this.id, object);
      if (transport) {
        this.useTransport(transport);
      }
    }
    cloneWithRPCServerRefs(obj) {
      if ((0, import_is_pojo.default)(obj) && !Array.isArray(obj)) {
        const clone = {};
        for (const key in obj) {
          clone[key] = this.cloneWithRPCServerRefs(obj[key]);
        }
        return clone;
      } else if (Array.isArray(obj)) {
        return obj.map(this.cloneWithRPCServerRefs);
      } else if (typeof obj === "object" && obj !== null) {
        const server = new _Server(obj, void 0);
        return { object: server.id };
      } else {
        return obj;
      }
    }
    restoreFromRPCServerRefs(clone) {
      if ((0, import_is_pojo.default)(clone) && !Array.isArray(clone) && !clone.object) {
        const obj = {};
        for (const key in clone) {
          obj[key] = this.restoreFromRPCServerRefs(clone[key]);
        }
        return obj;
      } else if (Array.isArray(clone)) {
        return clone.map(restoreFromRPCServerRefs);
      } else if (typeof clone === "object" && clone !== null && clone.object) {
        const server = _Server.objects.get(clone.object);
        return server;
      } else {
        return clone;
      }
    }
    async _handle({ id, path: path2 = "", action, args }) {
      const object = _Server.objects.get(id);
      console.log("_handle", id, path2, action, args, object);
      if (!path2 && action === "get") {
        return { object: id };
      }
      const pathParts = path2.split(".").filter((part) => part);
      try {
        let result = object;
        for (const part of pathParts) {
          console.log("part", result, id, part);
          result = result[part].bind ? result[part].bind(result) : result[part];
        }
        if (action === "apply") {
          result = await result(...args);
        }
        return result;
      } catch (e9) {
        return "Error: " + e9.message;
      }
    }
    async handle({ id, path: path2, action, args = [] }) {
      console.log("handle", id, path2, action, args);
      args = args.map((arg) => {
        if (typeof arg === "object" && arg.object) {
          return this.restoreFromRPCServerRefs(arg);
        } else if (typeof arg === "object" && arg.callback) {
          return (...args2) => {
            this.callback(
              arg.callback,
              this.cloneWithRPCServerRefs(args2)
            );
          };
        }
        return arg;
      });
      const result = await this._handle({ id, path: path2, action, args });
      console.log("result", result);
      return this.cloneWithRPCServerRefs(result);
    }
    callback(id, result) {
      this.transport.send({ id, result });
    }
    useTransport(transport) {
      this.transport = transport;
      transport.receive(this.handleRequest.bind(this));
    }
    async handleRequest({ id: reqId, path: path2, action, args }) {
      const [id, ...pathParts] = path2.split(".");
      path2 = pathParts.join(".");
      const result = await this.handle({ id, path: path2, action, args });
      console.log("handleRequest", reqId, result);
      this.transport.send({
        id: reqId,
        result
      });
    }
    connected(callback) {
      console.log("connected", this.transport.connected);
      this.transport.connected(callback);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserConnector.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Connection.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_CallbackRegistry();
  init_Debug();
  init_Errors();
  init_EventEmitter();
  init_ErrorLike();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/CDPSession.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_CallbackRegistry();
  init_Errors();
  init_assert();
  init_ErrorLike();
  var CdpCDPSession = class extends CDPSession {
    #sessionId;
    #targetType;
    #callbacks = new CallbackRegistry();
    #connection;
    #parentSessionId;
    #target;
    /**
     * @internal
     */
    constructor(connection, targetType, sessionId, parentSessionId) {
      super();
      this.#connection = connection;
      this.#targetType = targetType;
      this.#sessionId = sessionId;
      this.#parentSessionId = parentSessionId;
    }
    /**
     * Sets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _setTarget(target) {
      this.#target = target;
    }
    /**
     * Gets the {@link CdpTarget} associated with the session instance.
     *
     * @internal
     */
    _target() {
      assert2(this.#target, "Target must exist");
      return this.#target;
    }
    connection() {
      return this.#connection;
    }
    parentSession() {
      if (!this.#parentSessionId) {
        return this;
      }
      const parent = this.#connection?.session(this.#parentSessionId);
      return parent ?? void 0;
    }
    send(method, params, options) {
      if (!this.#connection) {
        return Promise.reject(new TargetCloseError(`Protocol error (${method}): Session closed. Most likely the ${this.#targetType} has been closed.`));
      }
      return this.#connection._rawSend(this.#callbacks, method, params, this.#sessionId, options);
    }
    /**
     * @internal
     */
    _onMessage(object) {
      if (object.id) {
        if (object.error) {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        } else {
          this.#callbacks.resolve(object.id, object.result);
        }
      } else {
        assert2(!object.id);
        this.emit(object.method, object.params);
      }
    }
    /**
     * Detaches the cdpSession from the target. Once detached, the cdpSession object
     * won't emit any events and can't be used to send messages.
     */
    async detach() {
      if (!this.#connection) {
        throw new Error(`Session already detached. Most likely the ${this.#targetType} has been closed.`);
      }
      await this.#connection.send("Target.detachFromTarget", {
        sessionId: this.#sessionId
      });
    }
    /**
     * @internal
     */
    _onClosed() {
      this.#callbacks.clear();
      this.#connection = void 0;
      this.emit(CDPSessionEvent.Disconnected, void 0);
    }
    /**
     * Returns the session's id.
     */
    id() {
      return this.#sessionId;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Connection.js
  var debugProtocolSend = debug("puppeteer:protocol:SEND \u25BA");
  var debugProtocolReceive = debug("puppeteer:protocol:RECV \u25C0");
  var Connection = class extends EventEmitter {
    #url;
    #transport;
    #delay;
    #timeout;
    #sessions = /* @__PURE__ */ new Map();
    #closed = false;
    #manuallyAttached = /* @__PURE__ */ new Set();
    #callbacks = new CallbackRegistry();
    constructor(url, transport, delay = 0, timeout2) {
      super();
      this.#url = url;
      this.#delay = delay;
      this.#timeout = timeout2 ?? 18e4;
      this.#transport = transport;
      this.#transport.onmessage = this.onMessage.bind(this);
      this.#transport.onclose = this.#onClose.bind(this);
    }
    static fromSession(session) {
      return session.connection();
    }
    get timeout() {
      return this.#timeout;
    }
    /**
     * @internal
     */
    get _closed() {
      return this.#closed;
    }
    /**
     * @internal
     */
    get _sessions() {
      return this.#sessions;
    }
    /**
     * @param sessionId - The session id
     * @returns The current CDP session if it exists
     */
    session(sessionId) {
      return this.#sessions.get(sessionId) || null;
    }
    url() {
      return this.#url;
    }
    send(method, params, options) {
      return this._rawSend(this.#callbacks, method, params, void 0, options);
    }
    /**
     * @internal
     */
    _rawSend(callbacks, method, params, sessionId, options) {
      return callbacks.create(method, options?.timeout ?? this.#timeout, (id) => {
        const stringifiedMessage = JSON.stringify({
          method,
          params,
          id,
          sessionId
        });
        debugProtocolSend(stringifiedMessage);
        this.#transport.send(stringifiedMessage);
      });
    }
    /**
     * @internal
     */
    async closeBrowser() {
      await this.send("Browser.close");
    }
    /**
     * @internal
     */
    async onMessage(message) {
      if (this.#delay) {
        await new Promise((r9) => {
          return setTimeout(r9, this.#delay);
        });
      }
      debugProtocolReceive(message);
      const object = JSON.parse(message);
      if (object.method === "Target.attachedToTarget") {
        const sessionId = object.params.sessionId;
        const session = new CdpCDPSession(this, object.params.targetInfo.type, sessionId, object.sessionId);
        this.#sessions.set(sessionId, session);
        this.emit(CDPSessionEvent.SessionAttached, session);
        const parentSession = this.#sessions.get(object.sessionId);
        if (parentSession) {
          parentSession.emit(CDPSessionEvent.SessionAttached, session);
        }
      } else if (object.method === "Target.detachedFromTarget") {
        const session = this.#sessions.get(object.params.sessionId);
        if (session) {
          session._onClosed();
          this.#sessions.delete(object.params.sessionId);
          this.emit(CDPSessionEvent.SessionDetached, session);
          const parentSession = this.#sessions.get(object.sessionId);
          if (parentSession) {
            parentSession.emit(CDPSessionEvent.SessionDetached, session);
          }
        }
      }
      if (object.sessionId) {
        const session = this.#sessions.get(object.sessionId);
        if (session) {
          session._onMessage(object);
        }
      } else if (object.id) {
        if (object.error) {
          this.#callbacks.reject(object.id, createProtocolErrorMessage(object), object.error.message);
        } else {
          this.#callbacks.resolve(object.id, object.result);
        }
      } else {
        this.emit(object.method, object.params);
      }
    }
    #onClose() {
      if (this.#closed) {
        return;
      }
      this.#closed = true;
      this.#transport.onmessage = void 0;
      this.#transport.onclose = void 0;
      this.#callbacks.clear();
      for (const session of this.#sessions.values()) {
        session._onClosed();
      }
      this.#sessions.clear();
      this.emit(CDPSessionEvent.Disconnected, void 0);
    }
    dispose() {
      this.#onClose();
      this.#transport.close();
    }
    /**
     * @internal
     */
    isAutoAttached(targetId) {
      return !this.#manuallyAttached.has(targetId);
    }
    /**
     * @internal
     */
    async _createSession(targetInfo, isAutoAttachEmulated = true) {
      if (!isAutoAttachEmulated) {
        this.#manuallyAttached.add(targetInfo.targetId);
      }
      const { sessionId } = await this.send("Target.attachToTarget", {
        targetId: targetInfo.targetId,
        flatten: true
      });
      this.#manuallyAttached.delete(targetInfo.targetId);
      const session = this.#sessions.get(sessionId);
      if (!session) {
        throw new Error("CDPSession creation failed.");
      }
      return session;
    }
    /**
     * @param targetInfo - The target info
     * @returns The CDP session that is created
     */
    async createSession(targetInfo) {
      return await this._createSession(targetInfo, false);
    }
  };
  function isTargetClosedError(error) {
    return error instanceof TargetCloseError;
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/bidi/BrowserConnector.js
  init_Errors();
  init_util2();
  async function _connectToBiDiBrowser(connectionTransport, url, options) {
    const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT } = options;
    const { bidiConnection, closeCallback } = await getBiDiConnection(connectionTransport, url, options);
    const BiDi = await Promise.resolve().then(() => (init_bidi(), bidi_exports));
    const bidiBrowser = await BiDi.BidiBrowser.create({
      connection: bidiConnection,
      closeCallback,
      process: void 0,
      defaultViewport,
      ignoreHTTPSErrors
    });
    return bidiBrowser;
  }
  async function getBiDiConnection(connectionTransport, url, options) {
    const BiDi = await Promise.resolve().then(() => (init_bidi(), bidi_exports));
    const { ignoreHTTPSErrors = false, slowMo = 0, protocolTimeout } = options;
    const pureBidiConnection = new BiDi.BidiConnection(url, connectionTransport, slowMo, protocolTimeout);
    try {
      const result = await pureBidiConnection.send("session.status", {});
      if ("type" in result && result.type === "success") {
        return {
          bidiConnection: pureBidiConnection,
          closeCallback: async () => {
            await pureBidiConnection.send("browser.close", {}).catch(debugError);
          }
        };
      }
    } catch (e9) {
      if (!("name" in e9 && e9.name === "ProtocolError")) {
        throw e9;
      }
    }
    pureBidiConnection.unbind();
    const cdpConnection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const version2 = await cdpConnection.send("Browser.getVersion");
    if (version2.product.toLowerCase().includes("firefox")) {
      throw new UnsupportedOperation("Firefox is not supported in BiDi over CDP mode.");
    }
    const bidiOverCdpConnection = await BiDi.connectBidiOverCdp(cdpConnection, {
      acceptInsecureCerts: ignoreHTTPSErrors
    });
    return {
      bidiConnection: bidiOverCdpConnection,
      closeCallback: async () => {
        await cdpConnection.send("Browser.close").catch(debugError);
      }
    };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_util2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Browser();
  init_BrowserContext();
  init_CDPSession();
  init_assert();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_Deferred();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Target();
  init_util2();
  init_Deferred();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_rxjs();
  init_CDPSession();
  init_Page();
  init_ConsoleMessage();
  init_Errors();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/FileChooser.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_assert();
  var FileChooser = class {
    #element;
    #multiple;
    #handled = false;
    /**
     * @internal
     */
    constructor(element, event) {
      this.#element = element;
      this.#multiple = event.mode !== "selectSingle";
    }
    /**
     * Whether file chooser allow for
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#attr-multiple | multiple}
     * file selection.
     */
    isMultiple() {
      return this.#multiple;
    }
    /**
     * Accept the file chooser request with the given file paths.
     *
     * @remarks This will not validate whether the file paths exists. Also, if a
     * path is relative, then it is resolved against the
     * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.
     * For locals script connecting to remote chrome environments, paths must be
     * absolute.
     */
    async accept(paths) {
      assert2(!this.#handled, "Cannot accept FileChooser which is already handled!");
      this.#handled = true;
      await this.#element.uploadFile(...paths);
    }
    /**
     * Closes the file chooser without selecting any files.
     */
    async cancel() {
      assert2(!this.#handled, "Cannot cancel FileChooser which is already handled!");
      this.#handled = true;
      await this.#element.evaluate((element) => {
        element.dispatchEvent(new Event("cancel", { bubbles: true }));
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_NetworkManagerEvents();
  init_util2();
  init_assert();
  init_Deferred();
  init_disposable();
  init_ErrorLike();
  init_Accessibility();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Binding.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_JSHandle();
  init_util2();
  init_disposable();
  init_ErrorLike();
  var __addDisposableResource11 = function(env2, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env2.stack.push({ value, dispose, async });
    } else if (async) {
      env2.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources11 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env2) {
      function fail2(e9) {
        env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
        env2.hasError = true;
      }
      function next() {
        while (env2.stack.length) {
          var rec = env2.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var Binding = class {
    #name;
    #fn;
    constructor(name2, fn) {
      this.#name = name2;
      this.#fn = fn;
    }
    get name() {
      return this.#name;
    }
    /**
     * @param context - Context to run the binding in; the context should have
     * the binding added to it beforehand.
     * @param id - ID of the call. This should come from the CDP
     * `onBindingCalled` response.
     * @param args - Plain arguments from CDP.
     */
    async run(context, id, args, isTrivial) {
      const stack = new DisposableStack();
      try {
        if (!isTrivial) {
          const env_1 = { stack: [], error: void 0, hasError: false };
          try {
            const handles = __addDisposableResource11(env_1, await context.evaluateHandle((name2, seq) => {
              return globalThis[name2].args.get(seq);
            }, this.#name, id), false);
            const properties = await handles.getProperties();
            for (const [index, handle] of properties) {
              if (index in args) {
                switch (handle.remoteObject().subtype) {
                  case "node":
                    args[+index] = handle;
                    break;
                  default:
                    stack.use(handle);
                }
              } else {
                stack.use(handle);
              }
            }
          } catch (e_1) {
            env_1.error = e_1;
            env_1.hasError = true;
          } finally {
            __disposeResources11(env_1);
          }
        }
        await context.evaluate((name2, seq, result) => {
          const callbacks = globalThis[name2].callbacks;
          callbacks.get(seq).resolve(result);
          callbacks.delete(seq);
        }, this.#name, id, await this.#fn(...args));
        for (const arg of args) {
          if (arg instanceof JSHandle) {
            stack.use(arg);
          }
        }
      } catch (error) {
        if (isErrorLike(error)) {
          await context.evaluate((name2, seq, message, stack2) => {
            const error2 = new Error(message);
            error2.stack = stack2;
            const callbacks = globalThis[name2].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, this.#name, id, error.message, error.stack).catch(debugError);
        } else {
          await context.evaluate((name2, seq, error2) => {
            const callbacks = globalThis[name2].callbacks;
            callbacks.get(seq).reject(error2);
            callbacks.delete(seq);
          }, this.#name, id, error).catch(debugError);
        }
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_Coverage();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Dialog();
  var CdpDialog = class extends Dialog {
    #client;
    constructor(client, type, message, defaultValue = "") {
      super(type, message, defaultValue);
      this.#client = client;
    }
    async sendCommand(options) {
      await this.#client.send("Page.handleJavaScriptDialog", {
        accept: options.accept,
        promptText: options.text
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_EmulationManager();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_LazyArg();
  init_ScriptInjector();
  init_util2();
  init_AsyncIterableUtil();
  init_Function();
  init_AriaQueryHandler();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_ElementHandle();
  init_util2();
  init_assert();
  init_decorators();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_JSHandle();
  init_util2();
  var CdpJSHandle = class extends JSHandle {
    #disposed = false;
    #remoteObject;
    #world;
    constructor(world, remoteObject) {
      super();
      this.#world = world;
      this.#remoteObject = remoteObject;
    }
    get disposed() {
      return this.#disposed;
    }
    get realm() {
      return this.#world;
    }
    get client() {
      return this.realm.environment.client;
    }
    async jsonValue() {
      if (!this.#remoteObject.objectId) {
        return valueFromRemoteObject(this.#remoteObject);
      }
      const value = await this.evaluate((object) => {
        return object;
      });
      if (value === void 0) {
        throw new Error("Could not serialize referenced object");
      }
      return value;
    }
    /**
     * Either `null` or the handle itself if the handle is an
     * instance of {@link ElementHandle}.
     */
    asElement() {
      return null;
    }
    async dispose() {
      if (this.#disposed) {
        return;
      }
      this.#disposed = true;
      await releaseObject(this.client, this.#remoteObject);
    }
    toString() {
      if (!this.#remoteObject.objectId) {
        return "JSHandle:" + valueFromRemoteObject(this.#remoteObject);
      }
      const type = this.#remoteObject.subtype || this.#remoteObject.type;
      return "JSHandle@" + type;
    }
    get id() {
      return this.#remoteObject.objectId;
    }
    remoteObject() {
      return this.#remoteObject;
    }
  };
  async function releaseObject(client, remoteObject) {
    if (!remoteObject.objectId) {
      return;
    }
    await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
      debugError(error);
    });
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js
  var __runInitializers9 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate9 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _5, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context = {};
      for (var p8 in contextIn)
        context[p8] = p8 === "access" ? {} : contextIn[p8];
      for (var p8 in contextIn.access)
        context.access[p8] = contextIn.access[p8];
      context.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_5 = accept(result.get))
          descriptor.get = _5;
        if (_5 = accept(result.set))
          descriptor.set = _5;
        if (_5 = accept(result.init))
          initializers.unshift(_5);
      } else if (_5 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_5);
        else
          descriptor[key] = _5;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var CdpElementHandle = (() => {
    var _a, _b;
    let _classSuper = ElementHandle;
    let _instanceExtraInitializers = [];
    let _contentFrame_decorators;
    let _scrollIntoView_decorators;
    let _uploadFile_decorators;
    let _autofill_decorators;
    return class CdpElementHandle extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        _contentFrame_decorators = [throwIfDisposed()];
        _scrollIntoView_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];
        _uploadFile_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];
        _autofill_decorators = [throwIfDisposed()];
        __esDecorate9(this, null, _contentFrame_decorators, { kind: "method", name: "contentFrame", static: false, private: false, access: { has: (obj) => "contentFrame" in obj, get: (obj) => obj.contentFrame }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate9(this, null, _scrollIntoView_decorators, { kind: "method", name: "scrollIntoView", static: false, private: false, access: { has: (obj) => "scrollIntoView" in obj, get: (obj) => obj.scrollIntoView }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate9(this, null, _uploadFile_decorators, { kind: "method", name: "uploadFile", static: false, private: false, access: { has: (obj) => "uploadFile" in obj, get: (obj) => obj.uploadFile }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate9(this, null, _autofill_decorators, { kind: "method", name: "autofill", static: false, private: false, access: { has: (obj) => "autofill" in obj, get: (obj) => obj.autofill }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      constructor(world, remoteObject) {
        super(new CdpJSHandle(world, remoteObject));
        __runInitializers9(this, _instanceExtraInitializers);
      }
      get realm() {
        return this.handle.realm;
      }
      get client() {
        return this.handle.client;
      }
      remoteObject() {
        return this.handle.remoteObject();
      }
      get #frameManager() {
        return this.frame._frameManager;
      }
      get frame() {
        return this.realm.environment;
      }
      async contentFrame() {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        if (typeof nodeInfo.node.frameId !== "string") {
          return null;
        }
        return this.#frameManager.frame(nodeInfo.node.frameId);
      }
      async scrollIntoView() {
        await this.assertConnectedElement();
        try {
          await this.client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: this.id
          });
        } catch (error) {
          debugError(error);
          await super.scrollIntoView();
        }
      }
      async uploadFile(...filePaths) {
        const isMultiple = await this.evaluate((element) => {
          return element.multiple;
        });
        assert2(filePaths.length <= 1 || isMultiple, "Multiple file uploads only work with <input type=file multiple>");
        let path2;
        try {
          path2 = await Promise.resolve().then(() => (init_path(), path_exports));
        } catch (error) {
          if (error instanceof TypeError) {
            throw new Error(`JSHandle#uploadFile can only be used in Node-like environments.`);
          }
          throw error;
        }
        const files = filePaths.map((filePath) => {
          if (path2.win32.isAbsolute(filePath) || path2.posix.isAbsolute(filePath)) {
            return filePath;
          } else {
            return path2.resolve(filePath);
          }
        });
        if (files.length === 0) {
          await this.evaluate((element) => {
            element.files = new DataTransfer().files;
            element.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
            element.dispatchEvent(new Event("change", { bubbles: true }));
          });
          return;
        }
        const { node: { backendNodeId } } = await this.client.send("DOM.describeNode", {
          objectId: this.id
        });
        await this.client.send("DOM.setFileInputFiles", {
          objectId: this.id,
          files,
          backendNodeId
        });
      }
      async autofill(data) {
        const nodeInfo = await this.client.send("DOM.describeNode", {
          objectId: this.handle.id
        });
        const fieldId = nodeInfo.node.backendNodeId;
        const frameId = this.frame._id;
        await this.client.send("Autofill.trigger", {
          fieldId,
          frameId,
          card: data.creditCard
        });
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js
  var ExecutionContext = class {
    _client;
    _world;
    _contextId;
    _contextName;
    constructor(client, contextPayload, world) {
      this._client = client;
      this._world = world;
      this._contextId = contextPayload.id;
      if (contextPayload.name) {
        this._contextName = contextPayload.name;
      }
    }
    #bindingsInstalled = false;
    #puppeteerUtil;
    get puppeteerUtil() {
      let promise = Promise.resolve();
      if (!this.#bindingsInstalled) {
        promise = Promise.all([
          this.#installGlobalBinding(new Binding("__ariaQuerySelector", ARIAQueryHandler.queryOne)),
          this.#installGlobalBinding(new Binding("__ariaQuerySelectorAll", async (element, selector) => {
            const results = ARIAQueryHandler.queryAll(element, selector);
            return await element.realm.evaluateHandle((...elements) => {
              return elements;
            }, ...await AsyncIterableUtil.collect(results));
          }))
        ]);
        this.#bindingsInstalled = true;
      }
      scriptInjector.inject((script) => {
        if (this.#puppeteerUtil) {
          void this.#puppeteerUtil.then((handle) => {
            void handle.dispose();
          });
        }
        this.#puppeteerUtil = promise.then(() => {
          return this.evaluateHandle(script);
        });
      }, !this.#puppeteerUtil);
      return this.#puppeteerUtil;
    }
    async #installGlobalBinding(binding2) {
      try {
        if (this._world) {
          this._world._bindings.set(binding2.name, binding2);
          await this._world._addBindingToContext(this, binding2.name);
        }
      } catch {
      }
    }
    /**
     * Evaluates the given function.
     *
     * @example
     *
     * ```ts
     * const executionContext = await page.mainFrame().executionContext();
     * const result = await executionContext.evaluate(() => Promise.resolve(8 * 7))* ;
     * console.log(result); // prints "56"
     * ```
     *
     * @example
     * A string can also be passed in instead of a function:
     *
     * ```ts
     * console.log(await executionContext.evaluate('1 + 2')); // prints "3"
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const oneHandle = await executionContext.evaluateHandle(() => 1);
     * const twoHandle = await executionContext.evaluateHandle(() => 2);
     * const result = await executionContext.evaluate(
     *   (a, b) => a + b,
     *   oneHandle,
     *   twoHandle
     * );
     * await oneHandle.dispose();
     * await twoHandle.dispose();
     * console.log(result); // prints '3'.
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns The result of evaluating the function. If the result is an object,
     * a vanilla object containing the serializable properties of the result is
     * returned.
     */
    async evaluate(pageFunction, ...args) {
      return await this.#evaluate(true, pageFunction, ...args);
    }
    /**
     * Evaluates the given function.
     *
     * Unlike {@link ExecutionContext.evaluate | evaluate}, this method returns a
     * handle to the result of the function.
     *
     * This method may be better suited if the object cannot be serialized (e.g.
     * `Map`) and requires further manipulation.
     *
     * @example
     *
     * ```ts
     * const context = await page.mainFrame().executionContext();
     * const handle: JSHandle<typeof globalThis> = await context.evaluateHandle(
     *   () => Promise.resolve(self)
     * );
     * ```
     *
     * @example
     * A string can also be passed in instead of a function.
     *
     * ```ts
     * const handle: JSHandle<number> = await context.evaluateHandle('1 + 2');
     * ```
     *
     * @example
     * Handles can also be passed as `args`. They resolve to their referenced object:
     *
     * ```ts
     * const bodyHandle: ElementHandle<HTMLBodyElement> =
     *   await context.evaluateHandle(() => {
     *     return document.body;
     *   });
     * const stringHandle: JSHandle<string> = await context.evaluateHandle(
     *   body => body.innerHTML,
     *   body
     * );
     * console.log(await stringHandle.jsonValue()); // prints body's innerHTML
     * // Always dispose your garbage! :)
     * await bodyHandle.dispose();
     * await stringHandle.dispose();
     * ```
     *
     * @param pageFunction - The function to evaluate.
     * @param args - Additional arguments to pass into the function.
     * @returns A {@link JSHandle | handle} to the result of evaluating the
     * function. If the result is a `Node`, then this will return an
     * {@link ElementHandle | element handle}.
     */
    async evaluateHandle(pageFunction, ...args) {
      return await this.#evaluate(false, pageFunction, ...args);
    }
    async #evaluate(returnByValue, pageFunction, ...args) {
      const sourceUrlComment = getSourceUrlComment(getSourcePuppeteerURLIfAvailable(pageFunction)?.toString() ?? PuppeteerURL.INTERNAL_URL);
      if (isString3(pageFunction)) {
        const contextId = this._contextId;
        const expression = pageFunction;
        const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : `${expression}
${sourceUrlComment}
`;
        const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
          expression: expressionWithSourceUrl,
          contextId,
          returnByValue,
          awaitPromise: true,
          userGesture: true
        }).catch(rewriteError2);
        if (exceptionDetails2) {
          throw createEvaluationError(exceptionDetails2);
        }
        return returnByValue ? valueFromRemoteObject(remoteObject2) : createCdpHandle(this._world, remoteObject2);
      }
      const functionDeclaration = stringifyFunction(pageFunction);
      const functionDeclarationWithSourceUrl = SOURCE_URL_REGEX.test(functionDeclaration) ? functionDeclaration : `${functionDeclaration}
${sourceUrlComment}
`;
      let callFunctionOnPromise;
      try {
        callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: functionDeclarationWithSourceUrl,
          executionContextId: this._contextId,
          arguments: args.length ? await Promise.all(args.map(convertArgument.bind(this))) : [],
          returnByValue,
          awaitPromise: true,
          userGesture: true
        });
      } catch (error) {
        if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON")) {
          error.message += " Recursive objects are not allowed.";
        }
        throw error;
      }
      const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError2);
      if (exceptionDetails) {
        throw createEvaluationError(exceptionDetails);
      }
      return returnByValue ? valueFromRemoteObject(remoteObject) : createCdpHandle(this._world, remoteObject);
      async function convertArgument(arg) {
        if (arg instanceof LazyArg) {
          arg = await arg.get(this);
        }
        if (typeof arg === "bigint") {
          return { unserializableValue: `${arg.toString()}n` };
        }
        if (Object.is(arg, -0)) {
          return { unserializableValue: "-0" };
        }
        if (Object.is(arg, Infinity)) {
          return { unserializableValue: "Infinity" };
        }
        if (Object.is(arg, -Infinity)) {
          return { unserializableValue: "-Infinity" };
        }
        if (Object.is(arg, NaN)) {
          return { unserializableValue: "NaN" };
        }
        const objectHandle = arg && (arg instanceof CdpJSHandle || arg instanceof CdpElementHandle) ? arg : null;
        if (objectHandle) {
          if (objectHandle.realm !== this._world) {
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          }
          if (objectHandle.disposed) {
            throw new Error("JSHandle is disposed!");
          }
          if (objectHandle.remoteObject().unserializableValue) {
            return {
              unserializableValue: objectHandle.remoteObject().unserializableValue
            };
          }
          if (!objectHandle.remoteObject().objectId) {
            return { value: objectHandle.remoteObject().value };
          }
          return { objectId: objectHandle.remoteObject().objectId };
        }
        return { value: arg };
      }
    }
  };
  var rewriteError2 = (error) => {
    if (error.message.includes("Object reference chain is too long")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.includes("Object couldn't be returned by value")) {
      return { result: { type: "undefined" } };
    }
    if (error.message.endsWith("Cannot find context with specified id") || error.message.endsWith("Inspected target navigated or closed")) {
      throw new Error("Execution context was destroyed, most likely because of a navigation.");
    }
    throw error;
  };
  function createCdpHandle(realm, remoteObject) {
    if (remoteObject.subtype === "node") {
      return new CdpElementHandle(realm, remoteObject);
    }
    return new CdpJSHandle(realm, remoteObject);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FirefoxTargetManager.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_EventEmitter();
  init_assert();
  init_Deferred();
  var FirefoxTargetManager = class extends EventEmitter {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Keeps track of targets that were created via 'Target.targetCreated'
     * and which one are not filtered out by `targetFilterCallback`.
     *
     * The target is removed from here once it's been destroyed.
     */
    #availableTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #availableTargetsBySessionId = /* @__PURE__ */ new Map();
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    #ignoredTargets = /* @__PURE__ */ new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #initializeDeferred = Deferred.create();
    #targetsIdsForInit = /* @__PURE__ */ new Set();
    constructor(connection, targetFactory, targetFilterCallback) {
      super();
      this.#connection = connection;
      this.#targetFilterCallback = targetFilterCallback;
      this.#targetFactory = targetFactory;
      this.#connection.on("Target.targetCreated", this.#onTargetCreated);
      this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.setupAttachmentListeners(this.#connection);
    }
    setupAttachmentListeners(session) {
      const listener = (event) => {
        return this.#onAttachedToTarget(session, event);
      };
      assert2(!this.#attachedToTargetListenersBySession.has(session));
      this.#attachedToTargetListenersBySession.set(session, listener);
      session.on("Target.attachedToTarget", listener);
    }
    #onSessionDetached = (session) => {
      this.removeSessionListeners(session);
      this.#availableTargetsBySessionId.delete(session.id());
    };
    removeSessionListeners(session) {
      if (this.#attachedToTargetListenersBySession.has(session)) {
        session.off("Target.attachedToTarget", this.#attachedToTargetListenersBySession.get(session));
        this.#attachedToTargetListenersBySession.delete(session);
      }
    }
    getAvailableTargets() {
      return this.#availableTargetsByTargetId;
    }
    dispose() {
      this.#connection.off("Target.targetCreated", this.#onTargetCreated);
      this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
    }
    async initialize() {
      await this.#connection.send("Target.setDiscoverTargets", {
        discover: true,
        filter: [{}]
      });
      this.#targetsIdsForInit = new Set(this.#discoveredTargetsByTargetId.keys());
      await this.#initializeDeferred.valueOrThrow();
    }
    #onTargetCreated = async (event) => {
      if (this.#discoveredTargetsByTargetId.has(event.targetInfo.targetId)) {
        return;
      }
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        const target2 = this.#targetFactory(event.targetInfo, void 0);
        target2._initialize();
        this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target2);
        this.#finishInitializationIfReady(target2._targetId);
        return;
      }
      const target = this.#targetFactory(event.targetInfo, void 0);
      if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
        this.#ignoredTargets.add(event.targetInfo.targetId);
        this.#finishInitializationIfReady(event.targetInfo.targetId);
        return;
      }
      target._initialize();
      this.#availableTargetsByTargetId.set(event.targetInfo.targetId, target);
      this.emit("targetAvailable", target);
      this.#finishInitializationIfReady(target._targetId);
    };
    #onTargetDestroyed = (event) => {
      this.#discoveredTargetsByTargetId.delete(event.targetId);
      this.#finishInitializationIfReady(event.targetId);
      const target = this.#availableTargetsByTargetId.get(event.targetId);
      if (target) {
        this.emit("targetGone", target);
        this.#availableTargetsByTargetId.delete(event.targetId);
      }
    };
    #onAttachedToTarget = async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = this.#connection.session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const target = this.#availableTargetsByTargetId.get(targetInfo.targetId);
      assert2(target, `Target ${targetInfo.targetId} is missing`);
      session._setTarget(target);
      this.setupAttachmentListeners(session);
      this.#availableTargetsBySessionId.set(session.id(), this.#availableTargetsByTargetId.get(targetInfo.targetId));
      parentSession.emit(CDPSessionEvent.Ready, session);
    };
    #finishInitializationIfReady(targetId) {
      this.#targetsIdsForInit.delete(targetId);
      if (this.#targetsIdsForInit.size === 0) {
        this.#initializeDeferred.resolve();
      }
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_Frame();
  init_EventEmitter();
  init_util2();
  init_assert();
  init_Deferred();
  init_disposable();
  init_ErrorLike();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_assert();
  init_Deferred();
  var DeviceRequestPromptDevice = class {
    /**
     * Device id during a prompt.
     */
    id;
    /**
     * Device name as it appears in a prompt.
     */
    name;
    /**
     * @internal
     */
    constructor(id, name2) {
      this.id = id;
      this.name = name2;
    }
  };
  var DeviceRequestPrompt = class {
    #client;
    #timeoutSettings;
    #id;
    #handled = false;
    #updateDevicesHandle = this.#updateDevices.bind(this);
    #waitForDevicePromises = /* @__PURE__ */ new Set();
    /**
     * Current list of selectable devices.
     */
    devices = [];
    /**
     * @internal
     */
    constructor(client, timeoutSettings, firstEvent) {
      this.#client = client;
      this.#timeoutSettings = timeoutSettings;
      this.#id = firstEvent.id;
      this.#client.on("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#client.on("Target.detachedFromTarget", () => {
        this.#client = null;
      });
      this.#updateDevices(firstEvent);
    }
    #updateDevices(event) {
      if (event.id !== this.#id) {
        return;
      }
      for (const rawDevice of event.devices) {
        if (this.devices.some((device) => {
          return device.id === rawDevice.id;
        })) {
          continue;
        }
        const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);
        this.devices.push(newDevice);
        for (const waitForDevicePromise of this.#waitForDevicePromises) {
          if (waitForDevicePromise.filter(newDevice)) {
            waitForDevicePromise.promise.resolve(newDevice);
          }
        }
      }
    }
    /**
     * Resolve to the first device in the prompt matching a filter.
     */
    async waitForDevice(filter, options = {}) {
      for (const device of this.devices) {
        if (filter(device)) {
          return device;
        }
      }
      const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPromptDevice\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      const handle = { filter, promise: deferred };
      this.#waitForDevicePromises.add(handle);
      try {
        return await deferred.valueOrThrow();
      } finally {
        this.#waitForDevicePromises.delete(handle);
      }
    }
    /**
     * Select a device in the prompt's list.
     */
    async select(device) {
      assert2(this.#client !== null, "Cannot select device through detached session!");
      assert2(this.devices.includes(device), "Cannot select unknown device!");
      assert2(!this.#handled, "Cannot select DeviceRequestPrompt which is already handled!");
      this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#handled = true;
      return await this.#client.send("DeviceAccess.selectPrompt", {
        id: this.#id,
        deviceId: device.id
      });
    }
    /**
     * Cancel the prompt.
     */
    async cancel() {
      assert2(this.#client !== null, "Cannot cancel prompt through detached session!");
      assert2(!this.#handled, "Cannot cancel DeviceRequestPrompt which is already handled!");
      this.#client.off("DeviceAccess.deviceRequestPrompted", this.#updateDevicesHandle);
      this.#handled = true;
      return await this.#client.send("DeviceAccess.cancelPrompt", { id: this.#id });
    }
  };
  var DeviceRequestPromptManager = class {
    #client;
    #timeoutSettings;
    #deviceRequestPrompDeferreds = /* @__PURE__ */ new Set();
    /**
     * @internal
     */
    constructor(client, timeoutSettings) {
      this.#client = client;
      this.#timeoutSettings = timeoutSettings;
      this.#client.on("DeviceAccess.deviceRequestPrompted", (event) => {
        this.#onDeviceRequestPrompted(event);
      });
      this.#client.on("Target.detachedFromTarget", () => {
        this.#client = null;
      });
    }
    /**
     * Wait for device prompt created by an action like calling WebBluetooth's
     * requestDevice.
     */
    async waitForDevicePrompt(options = {}) {
      assert2(this.#client !== null, "Cannot wait for device prompt through detached session!");
      const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;
      let enablePromise;
      if (needsEnable) {
        enablePromise = this.#client.send("DeviceAccess.enable");
      }
      const { timeout: timeout2 = this.#timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`DeviceRequestPrompt\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      this.#deviceRequestPrompDeferreds.add(deferred);
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } finally {
        this.#deviceRequestPrompDeferreds.delete(deferred);
      }
    }
    /**
     * @internal
     */
    #onDeviceRequestPrompted(event) {
      if (!this.#deviceRequestPrompDeferreds.size) {
        return;
      }
      assert2(this.#client !== null);
      const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);
      for (const promise of this.#deviceRequestPrompDeferreds) {
        promise.resolve(devicePrompt);
      }
      this.#deviceRequestPrompDeferreds.clear();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Frame();
  init_Errors();
  init_Deferred();
  init_disposable();
  init_ErrorLike();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Realm2();
  init_util2();
  init_Deferred();
  init_disposable();
  init_Mutex();
  var __addDisposableResource12 = function(env2, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env2.stack.push({ value, dispose, async });
    } else if (async) {
      env2.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources12 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env2) {
      function fail2(e9) {
        env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
        env2.hasError = true;
      }
      function next() {
        while (env2.stack.length) {
          var rec = env2.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var IsolatedWorld = class extends Realm {
    #context = Deferred.create();
    // Set of bindings that have been registered in the current context.
    #contextBindings = /* @__PURE__ */ new Set();
    // Contains mapping from functions that should be bound to Puppeteer functions.
    #bindings = /* @__PURE__ */ new Map();
    get _bindings() {
      return this.#bindings;
    }
    #frameOrWorker;
    constructor(frameOrWorker, timeoutSettings) {
      super(timeoutSettings);
      this.#frameOrWorker = frameOrWorker;
      this.frameUpdated();
    }
    get environment() {
      return this.#frameOrWorker;
    }
    frameUpdated() {
      this.client.on("Runtime.bindingCalled", this.#onBindingCalled);
    }
    get client() {
      return this.#frameOrWorker.client;
    }
    clearContext() {
      this.#context?.reject(new Error("Execution context was destroyed"));
      this.#context = Deferred.create();
      if ("clearDocumentHandle" in this.#frameOrWorker) {
        this.#frameOrWorker.clearDocumentHandle();
      }
    }
    setContext(context) {
      this.#contextBindings.clear();
      this.#context.resolve(context);
      void this.taskManager.rerunAll();
    }
    hasContext() {
      return this.#context.resolved();
    }
    #executionContext() {
      if (this.disposed) {
        throw new Error(`Execution context is not available in detached frame "${this.environment.url()}" (are you trying to evaluate?)`);
      }
      if (this.#context === null) {
        throw new Error(`Execution content promise is missing`);
      }
      return this.#context.valueOrThrow();
    }
    async evaluateHandle(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);
      const context = await this.#executionContext();
      return await context.evaluateHandle(pageFunction, ...args);
    }
    async evaluate(pageFunction, ...args) {
      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);
      let context = this.#context.value();
      if (!context || !(context instanceof ExecutionContext)) {
        context = await this.#executionContext();
      }
      return await context.evaluate(pageFunction, ...args);
    }
    // If multiple waitFor are set up asynchronously, we need to wait for the
    // first one to set up the binding in the page before running the others.
    #mutex = new Mutex();
    async _addBindingToContext(context, name2) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        if (this.#contextBindings.has(name2)) {
          return;
        }
        const _5 = __addDisposableResource12(env_1, await this.#mutex.acquire(), false);
        try {
          await context._client.send("Runtime.addBinding", context._contextName ? {
            name: name2,
            executionContextName: context._contextName
          } : {
            name: name2,
            executionContextId: context._contextId
          });
          await context.evaluate(addPageBinding, "internal", name2);
          this.#contextBindings.add(name2);
        } catch (error) {
          if (error instanceof Error) {
            if (error.message.includes("Execution context was destroyed")) {
              return;
            }
            if (error.message.includes("Cannot find context with specified id")) {
              return;
            }
          }
          debugError(error);
        }
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources12(env_1);
      }
    }
    #onBindingCalled = async (event) => {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name: name2, seq, args, isTrivial } = payload;
      if (type !== "internal") {
        return;
      }
      if (!this.#contextBindings.has(name2)) {
        return;
      }
      try {
        const context = await this.#context.valueOrThrow();
        if (event.executionContextId !== context._contextId) {
          return;
        }
        const binding2 = this._bindings.get(name2);
        await binding2?.run(context, seq, args, isTrivial);
      } catch (err) {
        debugError(err);
      }
    };
    async adoptBackendNode(backendNodeId) {
      const executionContext = await this.#executionContext();
      const { object } = await this.client.send("DOM.resolveNode", {
        backendNodeId,
        executionContextId: executionContext._contextId
      });
      return createCdpHandle(this, object);
    }
    async adoptHandle(handle) {
      if (handle.realm === this) {
        return await handle.evaluateHandle((value) => {
          return value;
        });
      }
      const nodeInfo = await this.client.send("DOM.describeNode", {
        objectId: handle.id
      });
      return await this.adoptBackendNode(nodeInfo.node.backendNodeId);
    }
    async transferHandle(handle) {
      if (handle.realm === this) {
        return handle;
      }
      if (handle.remoteObject().objectId === void 0) {
        return handle;
      }
      const info = await this.client.send("DOM.describeNode", {
        objectId: handle.remoteObject().objectId
      });
      const newHandle = await this.adoptBackendNode(info.node.backendNodeId);
      await handle.dispose();
      return newHandle;
    }
    [disposeSymbol]() {
      super[disposeSymbol]();
      this.client.off("Runtime.bindingCalled", this.#onBindingCalled);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js
  init_dirname();
  init_buffer2();
  init_process2();
  var MAIN_WORLD = Symbol("mainWorld");
  var PUPPETEER_WORLD = Symbol("puppeteerWorld");

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Frame();
  init_EventEmitter();
  init_NetworkManagerEvents();
  init_assert();
  init_Deferred();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js
  init_dirname();
  init_buffer2();
  init_process2();
  var FrameManagerEvent;
  (function(FrameManagerEvent2) {
    FrameManagerEvent2.FrameAttached = Symbol("FrameManager.FrameAttached");
    FrameManagerEvent2.FrameNavigated = Symbol("FrameManager.FrameNavigated");
    FrameManagerEvent2.FrameDetached = Symbol("FrameManager.FrameDetached");
    FrameManagerEvent2.FrameSwapped = Symbol("FrameManager.FrameSwapped");
    FrameManagerEvent2.LifecycleEvent = Symbol("FrameManager.LifecycleEvent");
    FrameManagerEvent2.FrameNavigatedWithinDocument = Symbol("FrameManager.FrameNavigatedWithinDocument");
  })(FrameManagerEvent || (FrameManagerEvent = {}));

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js
  var puppeteerToProtocolLifecycle = /* @__PURE__ */ new Map([
    ["load", "load"],
    ["domcontentloaded", "DOMContentLoaded"],
    ["networkidle0", "networkIdle"],
    ["networkidle2", "networkAlmostIdle"]
  ]);
  var LifecycleWatcher = class {
    #expectedLifecycle;
    #frame;
    #timeout;
    #navigationRequest = null;
    #subscriptions = new DisposableStack();
    #initialLoaderId;
    #terminationDeferred;
    #sameDocumentNavigationDeferred = Deferred.create();
    #lifecycleDeferred = Deferred.create();
    #newDocumentNavigationDeferred = Deferred.create();
    #hasSameDocumentNavigation;
    #swapped;
    #navigationResponseReceived;
    constructor(networkManager, frame, waitUntil, timeout2) {
      if (Array.isArray(waitUntil)) {
        waitUntil = waitUntil.slice();
      } else if (typeof waitUntil === "string") {
        waitUntil = [waitUntil];
      }
      this.#initialLoaderId = frame._loaderId;
      this.#expectedLifecycle = waitUntil.map((value) => {
        const protocolEvent = puppeteerToProtocolLifecycle.get(value);
        assert2(protocolEvent, "Unknown value for options.waitUntil: " + value);
        return protocolEvent;
      });
      this.#frame = frame;
      this.#timeout = timeout2;
      this.#subscriptions.use(
        // Revert if TODO #1 is done
        new EventSubscription(frame._frameManager, FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this))
      );
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigated, this.#navigated.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwapped, this.#frameSwapped.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this)));
      this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameDetached, this.#onFrameDetached.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Request, this.#onRequest.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Response, this.#onResponse.bind(this)));
      this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this)));
      this.#terminationDeferred = Deferred.create({
        timeout: this.#timeout,
        message: `Navigation timeout of ${this.#timeout} ms exceeded`
      });
      this.#checkLifecycleComplete();
    }
    #onRequest(request) {
      if (request.frame() !== this.#frame || !request.isNavigationRequest()) {
        return;
      }
      this.#navigationRequest = request;
      this.#navigationResponseReceived?.resolve();
      this.#navigationResponseReceived = Deferred.create();
      if (request.response() !== null) {
        this.#navigationResponseReceived?.resolve();
      }
    }
    #onRequestFailed(request) {
      if (this.#navigationRequest?._requestId !== request._requestId) {
        return;
      }
      this.#navigationResponseReceived?.resolve();
    }
    #onResponse(response) {
      if (this.#navigationRequest?._requestId !== response.request()._requestId) {
        return;
      }
      this.#navigationResponseReceived?.resolve();
    }
    #onFrameDetached(frame) {
      if (this.#frame === frame) {
        this.#terminationDeferred.resolve(new Error("Navigating frame was detached"));
        return;
      }
      this.#checkLifecycleComplete();
    }
    async navigationResponse() {
      await this.#navigationResponseReceived?.valueOrThrow();
      return this.#navigationRequest ? this.#navigationRequest.response() : null;
    }
    sameDocumentNavigationPromise() {
      return this.#sameDocumentNavigationDeferred.valueOrThrow();
    }
    newDocumentNavigationPromise() {
      return this.#newDocumentNavigationDeferred.valueOrThrow();
    }
    lifecyclePromise() {
      return this.#lifecycleDeferred.valueOrThrow();
    }
    terminationPromise() {
      return this.#terminationDeferred.valueOrThrow();
    }
    #navigatedWithinDocument() {
      this.#hasSameDocumentNavigation = true;
      this.#checkLifecycleComplete();
    }
    #navigated(navigationType) {
      if (navigationType === "BackForwardCacheRestore") {
        return this.#frameSwapped();
      }
      this.#checkLifecycleComplete();
    }
    #frameSwapped() {
      this.#swapped = true;
      this.#checkLifecycleComplete();
    }
    #checkLifecycleComplete() {
      if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {
        return;
      }
      this.#lifecycleDeferred.resolve();
      if (this.#hasSameDocumentNavigation) {
        this.#sameDocumentNavigationDeferred.resolve(void 0);
      }
      if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {
        this.#newDocumentNavigationDeferred.resolve(void 0);
      }
      function checkLifecycle(frame, expectedLifecycle) {
        for (const event of expectedLifecycle) {
          if (!frame._lifecycleEvents.has(event)) {
            return false;
          }
        }
        for (const child of frame.childFrames()) {
          if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {
            return false;
          }
        }
        return true;
      }
    }
    dispose() {
      this.#subscriptions.dispose();
      this.#terminationDeferred.resolve(new Error("LifecycleWatcher disposed"));
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Frame.js
  var __runInitializers10 = function(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i7 = 0; i7 < initializers.length; i7++) {
      value = useValue ? initializers[i7].call(thisArg, value) : initializers[i7].call(thisArg);
    }
    return useValue ? value : void 0;
  };
  var __esDecorate10 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f7) {
      if (f7 !== void 0 && typeof f7 !== "function")
        throw new TypeError("Function expected");
      return f7;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _5, done = false;
    for (var i7 = decorators.length - 1; i7 >= 0; i7--) {
      var context = {};
      for (var p8 in contextIn)
        context[p8] = p8 === "access" ? {} : contextIn[p8];
      for (var p8 in contextIn.access)
        context.access[p8] = contextIn.access[p8];
      context.addInitializer = function(f7) {
        if (done)
          throw new TypeError("Cannot add initializers after decoration has completed");
        extraInitializers.push(accept(f7 || null));
      };
      var result = (0, decorators[i7])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
        if (result === void 0)
          continue;
        if (result === null || typeof result !== "object")
          throw new TypeError("Object expected");
        if (_5 = accept(result.get))
          descriptor.get = _5;
        if (_5 = accept(result.set))
          descriptor.set = _5;
        if (_5 = accept(result.init))
          initializers.unshift(_5);
      } else if (_5 = accept(result)) {
        if (kind === "field")
          initializers.unshift(_5);
        else
          descriptor[key] = _5;
      }
    }
    if (target)
      Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
  };
  var CdpFrame = (() => {
    let _classSuper = Frame;
    let _instanceExtraInitializers = [];
    let _goto_decorators;
    let _waitForNavigation_decorators;
    let _setContent_decorators;
    let _waitForDevicePrompt_decorators;
    return class CdpFrame extends _classSuper {
      static {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;
        __esDecorate10(this, null, _goto_decorators, { kind: "method", name: "goto", static: false, private: false, access: { has: (obj) => "goto" in obj, get: (obj) => obj.goto }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate10(this, null, _waitForNavigation_decorators, { kind: "method", name: "waitForNavigation", static: false, private: false, access: { has: (obj) => "waitForNavigation" in obj, get: (obj) => obj.waitForNavigation }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate10(this, null, _setContent_decorators, { kind: "method", name: "setContent", static: false, private: false, access: { has: (obj) => "setContent" in obj, get: (obj) => obj.setContent }, metadata: _metadata }, null, _instanceExtraInitializers);
        __esDecorate10(this, null, _waitForDevicePrompt_decorators, { kind: "method", name: "waitForDevicePrompt", static: false, private: false, access: { has: (obj) => "waitForDevicePrompt" in obj, get: (obj) => obj.waitForDevicePrompt }, metadata: _metadata }, null, _instanceExtraInitializers);
        if (_metadata)
          Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
      }
      #url = (__runInitializers10(this, _instanceExtraInitializers), "");
      #detached = false;
      #client;
      _frameManager;
      _id;
      _loaderId = "";
      _lifecycleEvents = /* @__PURE__ */ new Set();
      _parentId;
      constructor(frameManager, frameId, parentFrameId, client) {
        super();
        this._frameManager = frameManager;
        this.#url = "";
        this._id = frameId;
        this._parentId = parentFrameId;
        this.#detached = false;
        this._loaderId = "";
        this.updateClient(client);
        this.on(FrameEvent.FrameSwappedByActivation, () => {
          this._onLoadingStarted();
          this._onLoadingStopped();
        });
      }
      /**
       * This is used internally in DevTools.
       *
       * @internal
       */
      _client() {
        return this.#client;
      }
      /**
       * Updates the frame ID with the new ID. This happens when the main frame is
       * replaced by a different frame.
       */
      updateId(id) {
        this._id = id;
      }
      updateClient(client, keepWorlds = false) {
        this.#client = client;
        if (!keepWorlds) {
          if (this.worlds) {
            this.worlds[MAIN_WORLD].clearContext();
            this.worlds[PUPPETEER_WORLD].clearContext();
          }
          this.worlds = {
            [MAIN_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings),
            [PUPPETEER_WORLD]: new IsolatedWorld(this, this._frameManager.timeoutSettings)
          };
        } else {
          this.worlds[MAIN_WORLD].frameUpdated();
          this.worlds[PUPPETEER_WORLD].frameUpdated();
        }
      }
      page() {
        return this._frameManager.page();
      }
      isOOPFrame() {
        return this.#client !== this._frameManager.client;
      }
      async goto(url, options = {}) {
        const { referer = this._frameManager.networkManager.extraHTTPHeaders()["referer"], referrerPolicy = this._frameManager.networkManager.extraHTTPHeaders()["referer-policy"], waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        let ensureNewDocumentNavigation = false;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        let error = await Deferred.race([
          navigate(this.#client, url, referer, referrerPolicy, this._id),
          watcher.terminationPromise()
        ]);
        if (!error) {
          error = await Deferred.race([
            watcher.terminationPromise(),
            ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
          ]);
        }
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
        async function navigate(client, url2, referrer, referrerPolicy2, frameId) {
          try {
            const response = await client.send("Page.navigate", {
              url: url2,
              referrer,
              frameId,
              referrerPolicy: referrerPolicy2
            });
            ensureNewDocumentNavigation = !!response.loaderId;
            if (response.errorText === "net::ERR_HTTP_RESPONSE_CODE_FAILURE") {
              return null;
            }
            return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
          } catch (error2) {
            if (isErrorLike(error2)) {
              return error2;
            }
            throw error2;
          }
        }
      }
      async waitForNavigation(options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        const error = await Deferred.race([
          watcher.terminationPromise(),
          watcher.sameDocumentNavigationPromise(),
          watcher.newDocumentNavigationPromise()
        ]);
        try {
          if (error) {
            throw error;
          }
          return await watcher.navigationResponse();
        } finally {
          watcher.dispose();
        }
      }
      get client() {
        return this.#client;
      }
      mainRealm() {
        return this.worlds[MAIN_WORLD];
      }
      isolatedRealm() {
        return this.worlds[PUPPETEER_WORLD];
      }
      async setContent(html, options = {}) {
        const { waitUntil = ["load"], timeout: timeout2 = this._frameManager.timeoutSettings.navigationTimeout() } = options;
        await this.setFrameContent(html);
        const watcher = new LifecycleWatcher(this._frameManager.networkManager, this, waitUntil, timeout2);
        const error = await Deferred.race([
          watcher.terminationPromise(),
          watcher.lifecyclePromise()
        ]);
        watcher.dispose();
        if (error) {
          throw error;
        }
      }
      url() {
        return this.#url;
      }
      parentFrame() {
        return this._frameManager._frameTree.parentFrame(this._id) || null;
      }
      childFrames() {
        return this._frameManager._frameTree.childFrames(this._id);
      }
      #deviceRequestPromptManager() {
        const rootFrame = this.page().mainFrame();
        if (this.isOOPFrame() || rootFrame === null) {
          return this._frameManager._deviceRequestPromptManager(this.#client);
        } else {
          return rootFrame._frameManager._deviceRequestPromptManager(this.#client);
        }
      }
      async waitForDevicePrompt(options = {}) {
        return await this.#deviceRequestPromptManager().waitForDevicePrompt(options);
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        this.#url = `${framePayload.url}${framePayload.urlFragment || ""}`;
      }
      _navigatedWithinDocument(url) {
        this.#url = url;
      }
      _onLifecycleEvent(loaderId, name2) {
        if (name2 === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name2);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      _onLoadingStarted() {
        this._hasStartedLoading = true;
      }
      get detached() {
        return this.#detached;
      }
      [(_goto_decorators = [throwIfDetached], _waitForNavigation_decorators = [throwIfDetached], _setContent_decorators = [throwIfDetached], _waitForDevicePrompt_decorators = [throwIfDetached], disposeSymbol)]() {
        if (this.#detached) {
          return;
        }
        this.#detached = true;
        this.worlds[MAIN_WORLD][disposeSymbol]();
        this.worlds[PUPPETEER_WORLD][disposeSymbol]();
      }
      exposeFunction() {
        throw new UnsupportedOperation();
      }
    };
  })();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  init_FrameTree();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_CDPSession();
  init_EventEmitter();
  init_NetworkManagerEvents();
  init_util2();
  init_assert();
  init_disposable();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPRequest.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_HTTPRequest();
  init_util2();
  init_assert();
  var CdpHTTPRequest = class extends HTTPRequest {
    #client;
    #isNavigationRequest;
    #allowInterception;
    #interceptionHandled = false;
    #url;
    #resourceType;
    #method;
    #hasPostData = false;
    #postData;
    #headers = {};
    #frame;
    #continueRequestOverrides;
    #responseForRequest = null;
    #abortErrorReason = null;
    #interceptResolutionState = {
      action: InterceptResolutionAction.None
    };
    #interceptHandlers;
    #initiator;
    get client() {
      return this.#client;
    }
    constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {
      super();
      this.#client = client;
      this._requestId = data.requestId;
      this.#isNavigationRequest = data.requestId === data.loaderId && data.type === "Document";
      this._interceptionId = interceptionId;
      this.#allowInterception = allowInterception;
      this.#url = data.request.url;
      this.#resourceType = (data.type || "other").toLowerCase();
      this.#method = data.request.method;
      this.#postData = data.request.postData;
      this.#hasPostData = data.request.hasPostData ?? false;
      this.#frame = frame;
      this._redirectChain = redirectChain;
      this.#continueRequestOverrides = {};
      this.#interceptHandlers = [];
      this.#initiator = data.initiator;
      for (const [key, value] of Object.entries(data.request.headers)) {
        this.#headers[key.toLowerCase()] = value;
      }
    }
    url() {
      return this.#url;
    }
    continueRequestOverrides() {
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      return this.#continueRequestOverrides;
    }
    responseForRequest() {
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      return this.#responseForRequest;
    }
    abortErrorReason() {
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      return this.#abortErrorReason;
    }
    interceptResolutionState() {
      if (!this.#allowInterception) {
        return { action: InterceptResolutionAction.Disabled };
      }
      if (this.#interceptionHandled) {
        return { action: InterceptResolutionAction.AlreadyHandled };
      }
      return { ...this.#interceptResolutionState };
    }
    isInterceptResolutionHandled() {
      return this.#interceptionHandled;
    }
    enqueueInterceptAction(pendingHandler) {
      this.#interceptHandlers.push(pendingHandler);
    }
    async finalizeInterceptions() {
      await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {
        return promiseChain.then(interceptAction);
      }, Promise.resolve());
      const { action } = this.interceptResolutionState();
      switch (action) {
        case "abort":
          return await this.#abort(this.#abortErrorReason);
        case "respond":
          if (this.#responseForRequest === null) {
            throw new Error("Response is missing for the interception");
          }
          return await this.#respond(this.#responseForRequest);
        case "continue":
          return await this.#continue(this.#continueRequestOverrides);
      }
    }
    resourceType() {
      return this.#resourceType;
    }
    method() {
      return this.#method;
    }
    postData() {
      return this.#postData;
    }
    hasPostData() {
      return this.#hasPostData;
    }
    async fetchPostData() {
      try {
        const result = await this.#client.send("Network.getRequestPostData", {
          requestId: this._requestId
        });
        return result.postData;
      } catch (err) {
        debugError(err);
        return;
      }
    }
    headers() {
      return this.#headers;
    }
    response() {
      return this._response;
    }
    frame() {
      return this.#frame;
    }
    isNavigationRequest() {
      return this.#isNavigationRequest;
    }
    initiator() {
      return this.#initiator;
    }
    redirectChain() {
      return this._redirectChain.slice();
    }
    failure() {
      if (!this._failureText) {
        return null;
      }
      return {
        errorText: this._failureText
      };
    }
    async continue(overrides = {}, priority) {
      if (this.#url.startsWith("data:")) {
        return;
      }
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      assert2(!this.#interceptionHandled, "Request is already handled!");
      if (priority === void 0) {
        return await this.#continue(overrides);
      }
      this.#continueRequestOverrides = overrides;
      if (this.#interceptResolutionState.priority === void 0 || priority > this.#interceptResolutionState.priority) {
        this.#interceptResolutionState = {
          action: InterceptResolutionAction.Continue,
          priority
        };
        return;
      }
      if (priority === this.#interceptResolutionState.priority) {
        if (this.#interceptResolutionState.action === "abort" || this.#interceptResolutionState.action === "respond") {
          return;
        }
        this.#interceptResolutionState.action = InterceptResolutionAction.Continue;
      }
      return;
    }
    async #continue(overrides = {}) {
      const { url, method, postData, headers } = overrides;
      this.#interceptionHandled = true;
      const postDataBinaryBase64 = postData ? Buffer2.from(postData).toString("base64") : void 0;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.continueRequest");
      }
      await this.#client.send("Fetch.continueRequest", {
        requestId: this._interceptionId,
        url,
        method,
        postData: postDataBinaryBase64,
        headers: headers ? headersArray(headers) : void 0
      }).catch((error) => {
        this.#interceptionHandled = false;
        return handleError(error);
      });
    }
    async respond(response, priority) {
      if (this.#url.startsWith("data:")) {
        return;
      }
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      assert2(!this.#interceptionHandled, "Request is already handled!");
      if (priority === void 0) {
        return await this.#respond(response);
      }
      this.#responseForRequest = response;
      if (this.#interceptResolutionState.priority === void 0 || priority > this.#interceptResolutionState.priority) {
        this.#interceptResolutionState = {
          action: InterceptResolutionAction.Respond,
          priority
        };
        return;
      }
      if (priority === this.#interceptResolutionState.priority) {
        if (this.#interceptResolutionState.action === "abort") {
          return;
        }
        this.#interceptResolutionState.action = InterceptResolutionAction.Respond;
      }
    }
    async #respond(response) {
      this.#interceptionHandled = true;
      const responseBody = response.body && isString3(response.body) ? Buffer2.from(response.body) : response.body || null;
      const responseHeaders = {};
      if (response.headers) {
        for (const header of Object.keys(response.headers)) {
          const value = response.headers[header];
          responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map((item) => {
            return String(item);
          }) : String(value);
        }
      }
      if (response.contentType) {
        responseHeaders["content-type"] = response.contentType;
      }
      if (responseBody && !("content-length" in responseHeaders)) {
        responseHeaders["content-length"] = String(Buffer2.byteLength(responseBody));
      }
      const status = response.status || 200;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest");
      }
      await this.#client.send("Fetch.fulfillRequest", {
        requestId: this._interceptionId,
        responseCode: status,
        responsePhrase: STATUS_TEXTS[status],
        responseHeaders: headersArray(responseHeaders),
        body: responseBody ? responseBody.toString("base64") : void 0
      }).catch((error) => {
        this.#interceptionHandled = false;
        return handleError(error);
      });
    }
    async abort(errorCode = "failed", priority) {
      if (this.#url.startsWith("data:")) {
        return;
      }
      const errorReason = errorReasons[errorCode];
      assert2(errorReason, "Unknown error code: " + errorCode);
      assert2(this.#allowInterception, "Request Interception is not enabled!");
      assert2(!this.#interceptionHandled, "Request is already handled!");
      if (priority === void 0) {
        return await this.#abort(errorReason);
      }
      this.#abortErrorReason = errorReason;
      if (this.#interceptResolutionState.priority === void 0 || priority >= this.#interceptResolutionState.priority) {
        this.#interceptResolutionState = {
          action: InterceptResolutionAction.Abort,
          priority
        };
        return;
      }
    }
    async #abort(errorReason) {
      this.#interceptionHandled = true;
      if (this._interceptionId === void 0) {
        throw new Error("HTTPRequest is missing _interceptionId needed for Fetch.failRequest");
      }
      await this.#client.send("Fetch.failRequest", {
        requestId: this._interceptionId,
        errorReason: errorReason || "Failed"
      }).catch(handleError);
    }
  };
  var errorReasons = {
    aborted: "Aborted",
    accessdenied: "AccessDenied",
    addressunreachable: "AddressUnreachable",
    blockedbyclient: "BlockedByClient",
    blockedbyresponse: "BlockedByResponse",
    connectionaborted: "ConnectionAborted",
    connectionclosed: "ConnectionClosed",
    connectionfailed: "ConnectionFailed",
    connectionrefused: "ConnectionRefused",
    connectionreset: "ConnectionReset",
    internetdisconnected: "InternetDisconnected",
    namenotresolved: "NameNotResolved",
    timedout: "TimedOut",
    failed: "Failed"
  };
  async function handleError(error) {
    if (["Invalid header"].includes(error.originalMessage)) {
      throw error;
    }
    debugError(error);
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_HTTPResponse();
  init_Errors();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js
  init_dirname();
  init_buffer2();
  init_process2();
  var SecurityDetails = class {
    #subjectName;
    #issuer;
    #validFrom;
    #validTo;
    #protocol;
    #sanList;
    /**
     * @internal
     */
    constructor(securityPayload) {
      this.#subjectName = securityPayload.subjectName;
      this.#issuer = securityPayload.issuer;
      this.#validFrom = securityPayload.validFrom;
      this.#validTo = securityPayload.validTo;
      this.#protocol = securityPayload.protocol;
      this.#sanList = securityPayload.sanList;
    }
    /**
     * The name of the issuer of the certificate.
     */
    issuer() {
      return this.#issuer;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the start of the certificate's validity.
     */
    validFrom() {
      return this.#validFrom;
    }
    /**
     * {@link https://en.wikipedia.org/wiki/Unix_time | Unix timestamp}
     * marking the end of the certificate's validity.
     */
    validTo() {
      return this.#validTo;
    }
    /**
     * The security protocol being used, e.g. "TLS 1.2".
     */
    protocol() {
      return this.#protocol;
    }
    /**
     * The name of the subject to which the certificate was issued.
     */
    subjectName() {
      return this.#subjectName;
    }
    /**
     * The list of {@link https://en.wikipedia.org/wiki/Subject_Alternative_Name | subject alternative names (SANs)} of the certificate.
     */
    subjectAlternativeNames() {
      return this.#sanList;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/HTTPResponse.js
  init_Deferred();
  var CdpHTTPResponse = class extends HTTPResponse {
    #client;
    #request;
    #contentPromise = null;
    #bodyLoadedDeferred = Deferred.create();
    #remoteAddress;
    #status;
    #statusText;
    #url;
    #fromDiskCache;
    #fromServiceWorker;
    #headers = {};
    #securityDetails;
    #timing;
    constructor(client, request, responsePayload, extraInfo) {
      super();
      this.#client = client;
      this.#request = request;
      this.#remoteAddress = {
        ip: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      };
      this.#statusText = this.#parseStatusTextFromExtraInfo(extraInfo) || responsePayload.statusText;
      this.#url = request.url();
      this.#fromDiskCache = !!responsePayload.fromDiskCache;
      this.#fromServiceWorker = !!responsePayload.fromServiceWorker;
      this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;
      const headers = extraInfo ? extraInfo.headers : responsePayload.headers;
      for (const [key, value] of Object.entries(headers)) {
        this.#headers[key.toLowerCase()] = value;
      }
      this.#securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
      this.#timing = responsePayload.timing || null;
    }
    #parseStatusTextFromExtraInfo(extraInfo) {
      if (!extraInfo || !extraInfo.headersText) {
        return;
      }
      const firstLine = extraInfo.headersText.split("\r", 1)[0];
      if (!firstLine) {
        return;
      }
      const match = firstLine.match(/[^ ]* [^ ]* (.*)/);
      if (!match) {
        return;
      }
      const statusText = match[1];
      if (!statusText) {
        return;
      }
      return statusText;
    }
    _resolveBody(err) {
      if (err) {
        return this.#bodyLoadedDeferred.reject(err);
      }
      return this.#bodyLoadedDeferred.resolve();
    }
    remoteAddress() {
      return this.#remoteAddress;
    }
    url() {
      return this.#url;
    }
    status() {
      return this.#status;
    }
    statusText() {
      return this.#statusText;
    }
    headers() {
      return this.#headers;
    }
    securityDetails() {
      return this.#securityDetails;
    }
    timing() {
      return this.#timing;
    }
    buffer() {
      if (!this.#contentPromise) {
        this.#contentPromise = this.#bodyLoadedDeferred.valueOrThrow().then(async () => {
          try {
            const response = await this.#client.send("Network.getResponseBody", {
              requestId: this.#request._requestId
            });
            return Buffer2.from(response.body, response.base64Encoded ? "base64" : "utf8");
          } catch (error) {
            if (error instanceof ProtocolError && error.originalMessage === "No resource with given identifier found") {
              throw new ProtocolError("Could not load body for this request. This might happen if the request is a preflight request.");
            }
            throw error;
          }
        });
      }
      return this.#contentPromise;
    }
    request() {
      return this.#request;
    }
    fromCache() {
      return this.#fromDiskCache || this.#request._fromMemoryCache;
    }
    fromServiceWorker() {
      return this.#fromServiceWorker;
    }
    frame() {
      return this.#request.frame();
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js
  init_dirname();
  init_buffer2();
  init_process2();
  var NetworkEventManager = class {
    /**
     * There are four possible orders of events:
     * A. `_onRequestWillBeSent`
     * B. `_onRequestWillBeSent`, `_onRequestPaused`
     * C. `_onRequestPaused`, `_onRequestWillBeSent`
     * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`
     * (see crbug.com/1196004)
     *
     * For `_onRequest` we need the event from `_onRequestWillBeSent` and
     * optionally the `interceptionId` from `_onRequestPaused`.
     *
     * If request interception is disabled, call `_onRequest` once per call to
     * `_onRequestWillBeSent`.
     * If request interception is enabled, call `_onRequest` once per call to
     * `_onRequestPaused` (once per `interceptionId`).
     *
     * Events are stored to allow for subsequent events to call `_onRequest`.
     *
     * Note that (chains of) redirect requests have the same `requestId` (!) as
     * the original request. We have to anticipate series of events like these:
     * A. `_onRequestWillBeSent`,
     * `_onRequestWillBeSent`, ...
     * B. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, ...
     * C. `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, ...
     * D. `_onRequestPaused`, `_onRequestWillBeSent`,
     * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,
     * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...
     * (see crbug.com/1196004)
     */
    #requestWillBeSentMap = /* @__PURE__ */ new Map();
    #requestPausedMap = /* @__PURE__ */ new Map();
    #httpRequestsMap = /* @__PURE__ */ new Map();
    /*
     * The below maps are used to reconcile Network.responseReceivedExtraInfo
     * events with their corresponding request. Each response and redirect
     * response gets an ExtraInfo event, and we don't know which will come first.
     * This means that we have to store a Response or an ExtraInfo for each
     * response, and emit the event when we get both of them. In addition, to
     * handle redirects, we have to make them Arrays to represent the chain of
     * events.
     */
    #responseReceivedExtraInfoMap = /* @__PURE__ */ new Map();
    #queuedRedirectInfoMap = /* @__PURE__ */ new Map();
    #queuedEventGroupMap = /* @__PURE__ */ new Map();
    forget(networkRequestId) {
      this.#requestWillBeSentMap.delete(networkRequestId);
      this.#requestPausedMap.delete(networkRequestId);
      this.#queuedEventGroupMap.delete(networkRequestId);
      this.#queuedRedirectInfoMap.delete(networkRequestId);
      this.#responseReceivedExtraInfoMap.delete(networkRequestId);
    }
    responseExtraInfo(networkRequestId) {
      if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {
        this.#responseReceivedExtraInfoMap.set(networkRequestId, []);
      }
      return this.#responseReceivedExtraInfoMap.get(networkRequestId);
    }
    queuedRedirectInfo(fetchRequestId) {
      if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {
        this.#queuedRedirectInfoMap.set(fetchRequestId, []);
      }
      return this.#queuedRedirectInfoMap.get(fetchRequestId);
    }
    queueRedirectInfo(fetchRequestId, redirectInfo) {
      this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);
    }
    takeQueuedRedirectInfo(fetchRequestId) {
      return this.queuedRedirectInfo(fetchRequestId).shift();
    }
    inFlightRequestsCount() {
      let inFlightRequestCounter = 0;
      for (const request of this.#httpRequestsMap.values()) {
        if (!request.response()) {
          inFlightRequestCounter++;
        }
      }
      return inFlightRequestCounter;
    }
    storeRequestWillBeSent(networkRequestId, event) {
      this.#requestWillBeSentMap.set(networkRequestId, event);
    }
    getRequestWillBeSent(networkRequestId) {
      return this.#requestWillBeSentMap.get(networkRequestId);
    }
    forgetRequestWillBeSent(networkRequestId) {
      this.#requestWillBeSentMap.delete(networkRequestId);
    }
    getRequestPaused(networkRequestId) {
      return this.#requestPausedMap.get(networkRequestId);
    }
    forgetRequestPaused(networkRequestId) {
      this.#requestPausedMap.delete(networkRequestId);
    }
    storeRequestPaused(networkRequestId, event) {
      this.#requestPausedMap.set(networkRequestId, event);
    }
    getRequest(networkRequestId) {
      return this.#httpRequestsMap.get(networkRequestId);
    }
    storeRequest(networkRequestId, request) {
      this.#httpRequestsMap.set(networkRequestId, request);
    }
    forgetRequest(networkRequestId) {
      this.#httpRequestsMap.delete(networkRequestId);
    }
    getQueuedEventGroup(networkRequestId) {
      return this.#queuedEventGroupMap.get(networkRequestId);
    }
    queueEventGroup(networkRequestId, event) {
      this.#queuedEventGroupMap.set(networkRequestId, event);
    }
    forgetQueuedEventGroup(networkRequestId) {
      this.#queuedEventGroupMap.delete(networkRequestId);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js
  var NetworkManager = class extends EventEmitter {
    #ignoreHTTPSErrors;
    #frameManager;
    #networkEventManager = new NetworkEventManager();
    #extraHTTPHeaders;
    #credentials;
    #attemptedAuthentications = /* @__PURE__ */ new Set();
    #userRequestInterceptionEnabled = false;
    #protocolRequestInterceptionEnabled = false;
    #userCacheDisabled;
    #emulatedNetworkConditions;
    #userAgent;
    #userAgentMetadata;
    #handlers = [
      ["Fetch.requestPaused", this.#onRequestPaused],
      ["Fetch.authRequired", this.#onAuthRequired],
      ["Network.requestWillBeSent", this.#onRequestWillBeSent],
      ["Network.requestServedFromCache", this.#onRequestServedFromCache],
      ["Network.responseReceived", this.#onResponseReceived],
      ["Network.loadingFinished", this.#onLoadingFinished],
      ["Network.loadingFailed", this.#onLoadingFailed],
      ["Network.responseReceivedExtraInfo", this.#onResponseReceivedExtraInfo],
      [CDPSessionEvent.Disconnected, this.#removeClient]
    ];
    #clients = /* @__PURE__ */ new Map();
    constructor(ignoreHTTPSErrors, frameManager) {
      super();
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#frameManager = frameManager;
    }
    async addClient(client) {
      if (this.#clients.has(client)) {
        return;
      }
      const subscriptions = new DisposableStack();
      this.#clients.set(client, subscriptions);
      for (const [event, handler] of this.#handlers) {
        subscriptions.use(
          // TODO: Remove any here.
          new EventSubscription(client, event, (arg) => {
            return handler.bind(this)(client, arg);
          })
        );
      }
      await Promise.all([
        this.#ignoreHTTPSErrors ? client.send("Security.setIgnoreCertificateErrors", {
          ignore: true
        }) : null,
        client.send("Network.enable"),
        this.#applyExtraHTTPHeaders(client),
        this.#applyNetworkConditions(client),
        this.#applyProtocolCacheDisabled(client),
        this.#applyProtocolRequestInterception(client),
        this.#applyUserAgent(client)
      ]);
    }
    async #removeClient(client) {
      this.#clients.get(client)?.dispose();
      this.#clients.delete(client);
    }
    async authenticate(credentials) {
      this.#credentials = credentials;
      const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
      if (enabled === this.#protocolRequestInterceptionEnabled) {
        return;
      }
      this.#protocolRequestInterceptionEnabled = enabled;
      await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async setExtraHTTPHeaders(extraHTTPHeaders) {
      this.#extraHTTPHeaders = {};
      for (const key of Object.keys(extraHTTPHeaders)) {
        const value = extraHTTPHeaders[key];
        assert2(isString3(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
        this.#extraHTTPHeaders[key.toLowerCase()] = value;
      }
      await this.#applyToAllClients(this.#applyExtraHTTPHeaders.bind(this));
    }
    async #applyExtraHTTPHeaders(client) {
      if (this.#extraHTTPHeaders === void 0) {
        return;
      }
      await client.send("Network.setExtraHTTPHeaders", {
        headers: this.#extraHTTPHeaders
      });
    }
    extraHTTPHeaders() {
      return Object.assign({}, this.#extraHTTPHeaders);
    }
    inFlightRequestsCount() {
      return this.#networkEventManager.inFlightRequestsCount();
    }
    async setOfflineMode(value) {
      if (!this.#emulatedNetworkConditions) {
        this.#emulatedNetworkConditions = {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        };
      }
      this.#emulatedNetworkConditions.offline = value;
      await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async emulateNetworkConditions(networkConditions) {
      if (!this.#emulatedNetworkConditions) {
        this.#emulatedNetworkConditions = {
          offline: false,
          upload: -1,
          download: -1,
          latency: 0
        };
      }
      this.#emulatedNetworkConditions.upload = networkConditions ? networkConditions.upload : -1;
      this.#emulatedNetworkConditions.download = networkConditions ? networkConditions.download : -1;
      this.#emulatedNetworkConditions.latency = networkConditions ? networkConditions.latency : 0;
      await this.#applyToAllClients(this.#applyNetworkConditions.bind(this));
    }
    async #applyToAllClients(fn) {
      await Promise.all(Array.from(this.#clients.keys()).map((client) => {
        return fn(client);
      }));
    }
    async #applyNetworkConditions(client) {
      if (this.#emulatedNetworkConditions === void 0) {
        return;
      }
      await client.send("Network.emulateNetworkConditions", {
        offline: this.#emulatedNetworkConditions.offline,
        latency: this.#emulatedNetworkConditions.latency,
        uploadThroughput: this.#emulatedNetworkConditions.upload,
        downloadThroughput: this.#emulatedNetworkConditions.download
      });
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      this.#userAgent = userAgent;
      this.#userAgentMetadata = userAgentMetadata;
      await this.#applyToAllClients(this.#applyUserAgent.bind(this));
    }
    async #applyUserAgent(client) {
      if (this.#userAgent === void 0) {
        return;
      }
      await client.send("Network.setUserAgentOverride", {
        userAgent: this.#userAgent,
        userAgentMetadata: this.#userAgentMetadata
      });
    }
    async setCacheEnabled(enabled) {
      this.#userCacheDisabled = !enabled;
      await this.#applyToAllClients(this.#applyProtocolCacheDisabled.bind(this));
    }
    async setRequestInterception(value) {
      this.#userRequestInterceptionEnabled = value;
      const enabled = this.#userRequestInterceptionEnabled || !!this.#credentials;
      if (enabled === this.#protocolRequestInterceptionEnabled) {
        return;
      }
      this.#protocolRequestInterceptionEnabled = enabled;
      await this.#applyToAllClients(this.#applyProtocolRequestInterception.bind(this));
    }
    async #applyProtocolRequestInterception(client) {
      if (this.#userCacheDisabled === void 0) {
        this.#userCacheDisabled = false;
      }
      if (this.#protocolRequestInterceptionEnabled) {
        await Promise.all([
          this.#applyProtocolCacheDisabled(client),
          client.send("Fetch.enable", {
            handleAuthRequests: true,
            patterns: [{ urlPattern: "*" }]
          })
        ]);
      } else {
        await Promise.all([
          this.#applyProtocolCacheDisabled(client),
          client.send("Fetch.disable")
        ]);
      }
    }
    async #applyProtocolCacheDisabled(client) {
      if (this.#userCacheDisabled === void 0) {
        return;
      }
      await client.send("Network.setCacheDisabled", {
        cacheDisabled: this.#userCacheDisabled
      });
    }
    #onRequestWillBeSent(client, event) {
      if (this.#userRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
        const { requestId: networkRequestId } = event;
        this.#networkEventManager.storeRequestWillBeSent(networkRequestId, event);
        const requestPausedEvent = this.#networkEventManager.getRequestPaused(networkRequestId);
        if (requestPausedEvent) {
          const { requestId: fetchRequestId } = requestPausedEvent;
          this.#patchRequestEventHeaders(event, requestPausedEvent);
          this.#onRequest(client, event, fetchRequestId);
          this.#networkEventManager.forgetRequestPaused(networkRequestId);
        }
        return;
      }
      this.#onRequest(client, event, void 0);
    }
    #onAuthRequired(client, event) {
      let response = "Default";
      if (this.#attemptedAuthentications.has(event.requestId)) {
        response = "CancelAuth";
      } else if (this.#credentials) {
        response = "ProvideCredentials";
        this.#attemptedAuthentications.add(event.requestId);
      }
      const { username, password } = this.#credentials || {
        username: void 0,
        password: void 0
      };
      client.send("Fetch.continueWithAuth", {
        requestId: event.requestId,
        authChallengeResponse: { response, username, password }
      }).catch(debugError);
    }
    /**
     * CDP may send a Fetch.requestPaused without or before a
     * Network.requestWillBeSent
     *
     * CDP may send multiple Fetch.requestPaused
     * for the same Network.requestWillBeSent.
     */
    #onRequestPaused(client, event) {
      if (!this.#userRequestInterceptionEnabled && this.#protocolRequestInterceptionEnabled) {
        client.send("Fetch.continueRequest", {
          requestId: event.requestId
        }).catch(debugError);
      }
      const { networkId: networkRequestId, requestId: fetchRequestId } = event;
      if (!networkRequestId) {
        this.#onRequestWithoutNetworkInstrumentation(client, event);
        return;
      }
      const requestWillBeSentEvent = (() => {
        const requestWillBeSentEvent2 = this.#networkEventManager.getRequestWillBeSent(networkRequestId);
        if (requestWillBeSentEvent2 && (requestWillBeSentEvent2.request.url !== event.request.url || requestWillBeSentEvent2.request.method !== event.request.method)) {
          this.#networkEventManager.forgetRequestWillBeSent(networkRequestId);
          return;
        }
        return requestWillBeSentEvent2;
      })();
      if (requestWillBeSentEvent) {
        this.#patchRequestEventHeaders(requestWillBeSentEvent, event);
        this.#onRequest(client, requestWillBeSentEvent, fetchRequestId);
      } else {
        this.#networkEventManager.storeRequestPaused(networkRequestId, event);
      }
    }
    #patchRequestEventHeaders(requestWillBeSentEvent, requestPausedEvent) {
      requestWillBeSentEvent.request.headers = {
        ...requestWillBeSentEvent.request.headers,
        // includes extra headers, like: Accept, Origin
        ...requestPausedEvent.request.headers
      };
    }
    #onRequestWithoutNetworkInstrumentation(client, event) {
      const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
      const request = new CdpHTTPRequest(client, frame, event.requestId, this.#userRequestInterceptionEnabled, event, []);
      this.emit(NetworkManagerEvent.Request, request);
      void request.finalizeInterceptions();
    }
    #onRequest(client, event, fetchRequestId) {
      let redirectChain = [];
      if (event.redirectResponse) {
        let redirectResponseExtraInfo = null;
        if (event.redirectHasExtraInfo) {
          redirectResponseExtraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
          if (!redirectResponseExtraInfo) {
            this.#networkEventManager.queueRedirectInfo(event.requestId, {
              event,
              fetchRequestId
            });
            return;
          }
        }
        const request2 = this.#networkEventManager.getRequest(event.requestId);
        if (request2) {
          this.#handleRequestRedirect(client, request2, event.redirectResponse, redirectResponseExtraInfo);
          redirectChain = request2._redirectChain;
        }
      }
      const frame = event.frameId ? this.#frameManager.frame(event.frameId) : null;
      const request = new CdpHTTPRequest(client, frame, fetchRequestId, this.#userRequestInterceptionEnabled, event, redirectChain);
      this.#networkEventManager.storeRequest(event.requestId, request);
      this.emit(NetworkManagerEvent.Request, request);
      void request.finalizeInterceptions();
    }
    #onRequestServedFromCache(_client, event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (request) {
        request._fromMemoryCache = true;
      }
      this.emit(NetworkManagerEvent.RequestServedFromCache, request);
    }
    #handleRequestRedirect(client, request, responsePayload, extraInfo) {
      const response = new CdpHTTPResponse(client, request, responsePayload, extraInfo);
      request._response = response;
      request._redirectChain.push(request);
      response._resolveBody(new Error("Response body is unavailable for redirect responses"));
      this.#forgetRequest(request, false);
      this.emit(NetworkManagerEvent.Response, response);
      this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #emitResponseEvent(client, responseReceived, extraInfo) {
      const request = this.#networkEventManager.getRequest(responseReceived.requestId);
      if (!request) {
        return;
      }
      const extraInfos = this.#networkEventManager.responseExtraInfo(responseReceived.requestId);
      if (extraInfos.length) {
        debugError(new Error("Unexpected extraInfo events for request " + responseReceived.requestId));
      }
      if (responseReceived.response.fromDiskCache) {
        extraInfo = null;
      }
      const response = new CdpHTTPResponse(client, request, responseReceived.response, extraInfo);
      request._response = response;
      this.emit(NetworkManagerEvent.Response, response);
    }
    #onResponseReceived(client, event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      let extraInfo = null;
      if (request && !request._fromMemoryCache && event.hasExtraInfo) {
        extraInfo = this.#networkEventManager.responseExtraInfo(event.requestId).shift();
        if (!extraInfo) {
          this.#networkEventManager.queueEventGroup(event.requestId, {
            responseReceivedEvent: event
          });
          return;
        }
      }
      this.#emitResponseEvent(client, event, extraInfo);
    }
    #onResponseReceivedExtraInfo(client, event) {
      const redirectInfo = this.#networkEventManager.takeQueuedRedirectInfo(event.requestId);
      if (redirectInfo) {
        this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
        this.#onRequest(client, redirectInfo.event, redirectInfo.fetchRequestId);
        return;
      }
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        this.#networkEventManager.forgetQueuedEventGroup(event.requestId);
        this.#emitResponseEvent(client, queuedEvents.responseReceivedEvent, event);
        if (queuedEvents.loadingFinishedEvent) {
          this.#emitLoadingFinished(queuedEvents.loadingFinishedEvent);
        }
        if (queuedEvents.loadingFailedEvent) {
          this.#emitLoadingFailed(queuedEvents.loadingFailedEvent);
        }
        return;
      }
      this.#networkEventManager.responseExtraInfo(event.requestId).push(event);
    }
    #forgetRequest(request, events) {
      const requestId = request._requestId;
      const interceptionId = request._interceptionId;
      this.#networkEventManager.forgetRequest(requestId);
      interceptionId !== void 0 && this.#attemptedAuthentications.delete(interceptionId);
      if (events) {
        this.#networkEventManager.forget(requestId);
      }
    }
    #onLoadingFinished(_client, event) {
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFinishedEvent = event;
      } else {
        this.#emitLoadingFinished(event);
      }
    }
    #emitLoadingFinished(event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (!request) {
        return;
      }
      if (request.response()) {
        request.response()?._resolveBody();
      }
      this.#forgetRequest(request, true);
      this.emit(NetworkManagerEvent.RequestFinished, request);
    }
    #onLoadingFailed(_client, event) {
      const queuedEvents = this.#networkEventManager.getQueuedEventGroup(event.requestId);
      if (queuedEvents) {
        queuedEvents.loadingFailedEvent = event;
      } else {
        this.#emitLoadingFailed(event);
      }
    }
    #emitLoadingFailed(event) {
      const request = this.#networkEventManager.getRequest(event.requestId);
      if (!request) {
        return;
      }
      request._failureText = event.errorText;
      const response = request.response();
      if (response) {
        response._resolveBody();
      }
      this.#forgetRequest(request, true);
      this.emit(NetworkManagerEvent.RequestFailed, request);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js
  var TIME_FOR_WAITING_FOR_SWAP = 100;
  var FrameManager = class extends EventEmitter {
    #page;
    #networkManager;
    #timeoutSettings;
    #contextIdToContext = /* @__PURE__ */ new Map();
    #isolatedWorlds = /* @__PURE__ */ new Set();
    #client;
    _frameTree = new FrameTree();
    /**
     * Set of frame IDs stored to indicate if a frame has received a
     * frameNavigated event so that frame tree responses could be ignored as the
     * frameNavigated event usually contains the latest information.
     */
    #frameNavigatedReceived = /* @__PURE__ */ new Set();
    #deviceRequestPromptManagerMap = /* @__PURE__ */ new WeakMap();
    #frameTreeHandled;
    get timeoutSettings() {
      return this.#timeoutSettings;
    }
    get networkManager() {
      return this.#networkManager;
    }
    get client() {
      return this.#client;
    }
    constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
      super();
      this.#client = client;
      this.#page = page;
      this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);
      this.#timeoutSettings = timeoutSettings;
      this.setupEventListeners(this.#client);
      client.once(CDPSessionEvent.Disconnected, () => {
        this.#onClientDisconnect().catch(debugError);
      });
    }
    /**
     * Called when the frame's client is disconnected. We don't know if the
     * disconnect means that the frame is removed or if it will be replaced by a
     * new frame. Therefore, we wait for a swap event.
     */
    async #onClientDisconnect() {
      const mainFrame = this._frameTree.getMainFrame();
      if (!mainFrame) {
        return;
      }
      for (const child of mainFrame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
      const swapped = Deferred.create({
        timeout: TIME_FOR_WAITING_FOR_SWAP,
        message: "Frame was not swapped"
      });
      mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {
        swapped.resolve();
      });
      try {
        await swapped.valueOrThrow();
      } catch (err) {
        this.#removeFramesRecursively(mainFrame);
      }
    }
    /**
     * When the main frame is replaced by another main frame,
     * we maintain the main frame object identity while updating
     * its frame tree and ID.
     */
    async swapFrameTree(client) {
      this.#onExecutionContextsCleared(this.#client);
      this.#client = client;
      assert2(this.#client instanceof CdpCDPSession, "CDPSession is not an instance of CDPSessionImpl.");
      const frame = this._frameTree.getMainFrame();
      if (frame) {
        this.#frameNavigatedReceived.add(this.#client._target()._targetId);
        this._frameTree.removeFrame(frame);
        frame.updateId(this.#client._target()._targetId);
        frame.mainRealm().clearContext();
        frame.isolatedRealm().clearContext();
        this._frameTree.addFrame(frame);
        frame.updateClient(client, true);
      }
      this.setupEventListeners(client);
      client.once(CDPSessionEvent.Disconnected, () => {
        this.#onClientDisconnect().catch(debugError);
      });
      await this.initialize(client);
      await this.#networkManager.addClient(client);
      if (frame) {
        frame.emit(FrameEvent.FrameSwappedByActivation, void 0);
      }
    }
    async registerSpeculativeSession(client) {
      await this.#networkManager.addClient(client);
    }
    setupEventListeners(session) {
      session.on("Page.frameAttached", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameAttached(session, event.frameId, event.parentFrameId);
      });
      session.on("Page.frameNavigated", async (event) => {
        this.#frameNavigatedReceived.add(event.frame.id);
        await this.#frameTreeHandled?.valueOrThrow();
        void this.#onFrameNavigated(event.frame, event.type);
      });
      session.on("Page.navigatedWithinDocument", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameNavigatedWithinDocument(event.frameId, event.url);
      });
      session.on("Page.frameDetached", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameDetached(event.frameId, event.reason);
      });
      session.on("Page.frameStartedLoading", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameStartedLoading(event.frameId);
      });
      session.on("Page.frameStoppedLoading", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onFrameStoppedLoading(event.frameId);
      });
      session.on("Runtime.executionContextCreated", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextCreated(event.context, session);
      });
      session.on("Runtime.executionContextDestroyed", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextDestroyed(event.executionContextId, session);
      });
      session.on("Runtime.executionContextsCleared", async () => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onExecutionContextsCleared(session);
      });
      session.on("Page.lifecycleEvent", async (event) => {
        await this.#frameTreeHandled?.valueOrThrow();
        this.#onLifecycleEvent(event);
      });
    }
    async initialize(client) {
      try {
        this.#frameTreeHandled?.resolve();
        this.#frameTreeHandled = Deferred.create();
        await Promise.all([
          this.#networkManager.addClient(client),
          client.send("Page.enable"),
          client.send("Page.getFrameTree").then(({ frameTree }) => {
            this.#handleFrameTree(client, frameTree);
            this.#frameTreeHandled?.resolve();
          }),
          client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
          client.send("Runtime.enable").then(() => {
            return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);
          })
        ]);
      } catch (error) {
        this.#frameTreeHandled?.resolve();
        if (isErrorLike(error) && isTargetClosedError(error)) {
          return;
        }
        throw error;
      }
    }
    executionContextById(contextId, session = this.#client) {
      const context = this.getExecutionContextById(contextId, session);
      assert2(context, "INTERNAL ERROR: missing context with id = " + contextId);
      return context;
    }
    getExecutionContextById(contextId, session = this.#client) {
      return this.#contextIdToContext.get(`${session.id()}:${contextId}`);
    }
    page() {
      return this.#page;
    }
    mainFrame() {
      const mainFrame = this._frameTree.getMainFrame();
      assert2(mainFrame, "Requesting main frame too early!");
      return mainFrame;
    }
    frames() {
      return Array.from(this._frameTree.frames());
    }
    frame(frameId) {
      return this._frameTree.getById(frameId) || null;
    }
    onAttachedToTarget(target) {
      if (target._getTargetInfo().type !== "iframe") {
        return;
      }
      const frame = this.frame(target._getTargetInfo().targetId);
      if (frame) {
        frame.updateClient(target._session());
      }
      this.setupEventListeners(target._session());
      void this.initialize(target._session());
    }
    _deviceRequestPromptManager(client) {
      let manager = this.#deviceRequestPromptManagerMap.get(client);
      if (manager === void 0) {
        manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);
        this.#deviceRequestPromptManagerMap.set(client, manager);
      }
      return manager;
    }
    #onLifecycleEvent(event) {
      const frame = this.frame(event.frameId);
      if (!frame) {
        return;
      }
      frame._onLifecycleEvent(event.loaderId, event.name);
      this.emit(FrameManagerEvent.LifecycleEvent, frame);
      frame.emit(FrameEvent.LifecycleEvent, void 0);
    }
    #onFrameStartedLoading(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStarted();
    }
    #onFrameStoppedLoading(frameId) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._onLoadingStopped();
      this.emit(FrameManagerEvent.LifecycleEvent, frame);
      frame.emit(FrameEvent.LifecycleEvent, void 0);
    }
    #handleFrameTree(session, frameTree) {
      if (frameTree.frame.parentId) {
        this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);
      }
      if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {
        void this.#onFrameNavigated(frameTree.frame, "Navigation");
      } else {
        this.#frameNavigatedReceived.delete(frameTree.frame.id);
      }
      if (!frameTree.childFrames) {
        return;
      }
      for (const child of frameTree.childFrames) {
        this.#handleFrameTree(session, child);
      }
    }
    #onFrameAttached(session, frameId, parentFrameId) {
      let frame = this.frame(frameId);
      if (frame) {
        if (session && frame.isOOPFrame()) {
          frame.updateClient(session);
        }
        return;
      }
      frame = new CdpFrame(this, frameId, parentFrameId, session);
      this._frameTree.addFrame(frame);
      this.emit(FrameManagerEvent.FrameAttached, frame);
    }
    async #onFrameNavigated(framePayload, navigationType) {
      const frameId = framePayload.id;
      const isMainFrame = !framePayload.parentId;
      let frame = this._frameTree.getById(frameId);
      if (frame) {
        for (const child of frame.childFrames()) {
          this.#removeFramesRecursively(child);
        }
      }
      if (isMainFrame) {
        if (frame) {
          this._frameTree.removeFrame(frame);
          frame._id = frameId;
        } else {
          frame = new CdpFrame(this, frameId, void 0, this.#client);
        }
        this._frameTree.addFrame(frame);
      }
      frame = await this._frameTree.waitForFrame(frameId);
      frame._navigated(framePayload);
      this.emit(FrameManagerEvent.FrameNavigated, frame);
      frame.emit(FrameEvent.FrameNavigated, navigationType);
    }
    async #createIsolatedWorld(session, name2) {
      const key = `${session.id()}:${name2}`;
      if (this.#isolatedWorlds.has(key)) {
        return;
      }
      await session.send("Page.addScriptToEvaluateOnNewDocument", {
        source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,
        worldName: name2
      });
      await Promise.all(this.frames().filter((frame) => {
        return frame.client === session;
      }).map((frame) => {
        return session.send("Page.createIsolatedWorld", {
          frameId: frame._id,
          worldName: name2,
          grantUniveralAccess: true
        }).catch(debugError);
      }));
      this.#isolatedWorlds.add(key);
    }
    #onFrameNavigatedWithinDocument(frameId, url) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      frame._navigatedWithinDocument(url);
      this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);
      frame.emit(FrameEvent.FrameNavigatedWithinDocument, void 0);
      this.emit(FrameManagerEvent.FrameNavigated, frame);
      frame.emit(FrameEvent.FrameNavigated, "Navigation");
    }
    #onFrameDetached(frameId, reason) {
      const frame = this.frame(frameId);
      if (!frame) {
        return;
      }
      switch (reason) {
        case "remove":
          this.#removeFramesRecursively(frame);
          break;
        case "swap":
          this.emit(FrameManagerEvent.FrameSwapped, frame);
          frame.emit(FrameEvent.FrameSwapped, void 0);
          break;
      }
    }
    #onExecutionContextCreated(contextPayload, session) {
      const auxData = contextPayload.auxData;
      const frameId = auxData && auxData.frameId;
      const frame = typeof frameId === "string" ? this.frame(frameId) : void 0;
      let world;
      if (frame) {
        if (frame.client !== session) {
          return;
        }
        if (contextPayload.auxData && contextPayload.auxData["isDefault"]) {
          world = frame.worlds[MAIN_WORLD];
        } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {
          world = frame.worlds[PUPPETEER_WORLD];
        }
      }
      if (!world) {
        return;
      }
      const context = new ExecutionContext(frame?.client || this.#client, contextPayload, world);
      if (world) {
        world.setContext(context);
      }
      const key = `${session.id()}:${contextPayload.id}`;
      this.#contextIdToContext.set(key, context);
    }
    #onExecutionContextDestroyed(executionContextId, session) {
      const key = `${session.id()}:${executionContextId}`;
      const context = this.#contextIdToContext.get(key);
      if (!context) {
        return;
      }
      this.#contextIdToContext.delete(key);
      if (context._world) {
        context._world.clearContext();
      }
    }
    #onExecutionContextsCleared(session) {
      for (const [key, context] of this.#contextIdToContext.entries()) {
        if (context._client !== session) {
          continue;
        }
        if (context._world) {
          context._world.clearContext();
        }
        this.#contextIdToContext.delete(key);
      }
    }
    #removeFramesRecursively(frame) {
      for (const child of frame.childFrames()) {
        this.#removeFramesRecursively(child);
      }
      frame[disposeSymbol]();
      this._frameTree.removeFrame(frame);
      this.emit(FrameManagerEvent.FrameDetached, frame);
      frame.emit(FrameEvent.FrameDetached, frame);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_Input();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js
  init_dirname();
  init_buffer2();
  init_process2();
  var _keyDefinitions = {
    "0": { keyCode: 48, key: "0", code: "Digit0" },
    "1": { keyCode: 49, key: "1", code: "Digit1" },
    "2": { keyCode: 50, key: "2", code: "Digit2" },
    "3": { keyCode: 51, key: "3", code: "Digit3" },
    "4": { keyCode: 52, key: "4", code: "Digit4" },
    "5": { keyCode: 53, key: "5", code: "Digit5" },
    "6": { keyCode: 54, key: "6", code: "Digit6" },
    "7": { keyCode: 55, key: "7", code: "Digit7" },
    "8": { keyCode: 56, key: "8", code: "Digit8" },
    "9": { keyCode: 57, key: "9", code: "Digit9" },
    Power: { key: "Power", code: "Power" },
    Eject: { key: "Eject", code: "Eject" },
    Abort: { keyCode: 3, code: "Abort", key: "Cancel" },
    Help: { keyCode: 6, code: "Help", key: "Help" },
    Backspace: { keyCode: 8, code: "Backspace", key: "Backspace" },
    Tab: { keyCode: 9, code: "Tab", key: "Tab" },
    Numpad5: {
      keyCode: 12,
      shiftKeyCode: 101,
      key: "Clear",
      code: "Numpad5",
      shiftKey: "5",
      location: 3
    },
    NumpadEnter: {
      keyCode: 13,
      code: "NumpadEnter",
      key: "Enter",
      text: "\r",
      location: 3
    },
    Enter: { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\r": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    "\n": { keyCode: 13, code: "Enter", key: "Enter", text: "\r" },
    ShiftLeft: { keyCode: 16, code: "ShiftLeft", key: "Shift", location: 1 },
    ShiftRight: { keyCode: 16, code: "ShiftRight", key: "Shift", location: 2 },
    ControlLeft: {
      keyCode: 17,
      code: "ControlLeft",
      key: "Control",
      location: 1
    },
    ControlRight: {
      keyCode: 17,
      code: "ControlRight",
      key: "Control",
      location: 2
    },
    AltLeft: { keyCode: 18, code: "AltLeft", key: "Alt", location: 1 },
    AltRight: { keyCode: 18, code: "AltRight", key: "Alt", location: 2 },
    Pause: { keyCode: 19, code: "Pause", key: "Pause" },
    CapsLock: { keyCode: 20, code: "CapsLock", key: "CapsLock" },
    Escape: { keyCode: 27, code: "Escape", key: "Escape" },
    Convert: { keyCode: 28, code: "Convert", key: "Convert" },
    NonConvert: { keyCode: 29, code: "NonConvert", key: "NonConvert" },
    Space: { keyCode: 32, code: "Space", key: " " },
    Numpad9: {
      keyCode: 33,
      shiftKeyCode: 105,
      key: "PageUp",
      code: "Numpad9",
      shiftKey: "9",
      location: 3
    },
    PageUp: { keyCode: 33, code: "PageUp", key: "PageUp" },
    Numpad3: {
      keyCode: 34,
      shiftKeyCode: 99,
      key: "PageDown",
      code: "Numpad3",
      shiftKey: "3",
      location: 3
    },
    PageDown: { keyCode: 34, code: "PageDown", key: "PageDown" },
    End: { keyCode: 35, code: "End", key: "End" },
    Numpad1: {
      keyCode: 35,
      shiftKeyCode: 97,
      key: "End",
      code: "Numpad1",
      shiftKey: "1",
      location: 3
    },
    Home: { keyCode: 36, code: "Home", key: "Home" },
    Numpad7: {
      keyCode: 36,
      shiftKeyCode: 103,
      key: "Home",
      code: "Numpad7",
      shiftKey: "7",
      location: 3
    },
    ArrowLeft: { keyCode: 37, code: "ArrowLeft", key: "ArrowLeft" },
    Numpad4: {
      keyCode: 37,
      shiftKeyCode: 100,
      key: "ArrowLeft",
      code: "Numpad4",
      shiftKey: "4",
      location: 3
    },
    Numpad8: {
      keyCode: 38,
      shiftKeyCode: 104,
      key: "ArrowUp",
      code: "Numpad8",
      shiftKey: "8",
      location: 3
    },
    ArrowUp: { keyCode: 38, code: "ArrowUp", key: "ArrowUp" },
    ArrowRight: { keyCode: 39, code: "ArrowRight", key: "ArrowRight" },
    Numpad6: {
      keyCode: 39,
      shiftKeyCode: 102,
      key: "ArrowRight",
      code: "Numpad6",
      shiftKey: "6",
      location: 3
    },
    Numpad2: {
      keyCode: 40,
      shiftKeyCode: 98,
      key: "ArrowDown",
      code: "Numpad2",
      shiftKey: "2",
      location: 3
    },
    ArrowDown: { keyCode: 40, code: "ArrowDown", key: "ArrowDown" },
    Select: { keyCode: 41, code: "Select", key: "Select" },
    Open: { keyCode: 43, code: "Open", key: "Execute" },
    PrintScreen: { keyCode: 44, code: "PrintScreen", key: "PrintScreen" },
    Insert: { keyCode: 45, code: "Insert", key: "Insert" },
    Numpad0: {
      keyCode: 45,
      shiftKeyCode: 96,
      key: "Insert",
      code: "Numpad0",
      shiftKey: "0",
      location: 3
    },
    Delete: { keyCode: 46, code: "Delete", key: "Delete" },
    NumpadDecimal: {
      keyCode: 46,
      shiftKeyCode: 110,
      code: "NumpadDecimal",
      key: "\0",
      shiftKey: ".",
      location: 3
    },
    Digit0: { keyCode: 48, code: "Digit0", shiftKey: ")", key: "0" },
    Digit1: { keyCode: 49, code: "Digit1", shiftKey: "!", key: "1" },
    Digit2: { keyCode: 50, code: "Digit2", shiftKey: "@", key: "2" },
    Digit3: { keyCode: 51, code: "Digit3", shiftKey: "#", key: "3" },
    Digit4: { keyCode: 52, code: "Digit4", shiftKey: "$", key: "4" },
    Digit5: { keyCode: 53, code: "Digit5", shiftKey: "%", key: "5" },
    Digit6: { keyCode: 54, code: "Digit6", shiftKey: "^", key: "6" },
    Digit7: { keyCode: 55, code: "Digit7", shiftKey: "&", key: "7" },
    Digit8: { keyCode: 56, code: "Digit8", shiftKey: "*", key: "8" },
    Digit9: { keyCode: 57, code: "Digit9", shiftKey: "(", key: "9" },
    KeyA: { keyCode: 65, code: "KeyA", shiftKey: "A", key: "a" },
    KeyB: { keyCode: 66, code: "KeyB", shiftKey: "B", key: "b" },
    KeyC: { keyCode: 67, code: "KeyC", shiftKey: "C", key: "c" },
    KeyD: { keyCode: 68, code: "KeyD", shiftKey: "D", key: "d" },
    KeyE: { keyCode: 69, code: "KeyE", shiftKey: "E", key: "e" },
    KeyF: { keyCode: 70, code: "KeyF", shiftKey: "F", key: "f" },
    KeyG: { keyCode: 71, code: "KeyG", shiftKey: "G", key: "g" },
    KeyH: { keyCode: 72, code: "KeyH", shiftKey: "H", key: "h" },
    KeyI: { keyCode: 73, code: "KeyI", shiftKey: "I", key: "i" },
    KeyJ: { keyCode: 74, code: "KeyJ", shiftKey: "J", key: "j" },
    KeyK: { keyCode: 75, code: "KeyK", shiftKey: "K", key: "k" },
    KeyL: { keyCode: 76, code: "KeyL", shiftKey: "L", key: "l" },
    KeyM: { keyCode: 77, code: "KeyM", shiftKey: "M", key: "m" },
    KeyN: { keyCode: 78, code: "KeyN", shiftKey: "N", key: "n" },
    KeyO: { keyCode: 79, code: "KeyO", shiftKey: "O", key: "o" },
    KeyP: { keyCode: 80, code: "KeyP", shiftKey: "P", key: "p" },
    KeyQ: { keyCode: 81, code: "KeyQ", shiftKey: "Q", key: "q" },
    KeyR: { keyCode: 82, code: "KeyR", shiftKey: "R", key: "r" },
    KeyS: { keyCode: 83, code: "KeyS", shiftKey: "S", key: "s" },
    KeyT: { keyCode: 84, code: "KeyT", shiftKey: "T", key: "t" },
    KeyU: { keyCode: 85, code: "KeyU", shiftKey: "U", key: "u" },
    KeyV: { keyCode: 86, code: "KeyV", shiftKey: "V", key: "v" },
    KeyW: { keyCode: 87, code: "KeyW", shiftKey: "W", key: "w" },
    KeyX: { keyCode: 88, code: "KeyX", shiftKey: "X", key: "x" },
    KeyY: { keyCode: 89, code: "KeyY", shiftKey: "Y", key: "y" },
    KeyZ: { keyCode: 90, code: "KeyZ", shiftKey: "Z", key: "z" },
    MetaLeft: { keyCode: 91, code: "MetaLeft", key: "Meta", location: 1 },
    MetaRight: { keyCode: 92, code: "MetaRight", key: "Meta", location: 2 },
    ContextMenu: { keyCode: 93, code: "ContextMenu", key: "ContextMenu" },
    NumpadMultiply: {
      keyCode: 106,
      code: "NumpadMultiply",
      key: "*",
      location: 3
    },
    NumpadAdd: { keyCode: 107, code: "NumpadAdd", key: "+", location: 3 },
    NumpadSubtract: {
      keyCode: 109,
      code: "NumpadSubtract",
      key: "-",
      location: 3
    },
    NumpadDivide: { keyCode: 111, code: "NumpadDivide", key: "/", location: 3 },
    F1: { keyCode: 112, code: "F1", key: "F1" },
    F2: { keyCode: 113, code: "F2", key: "F2" },
    F3: { keyCode: 114, code: "F3", key: "F3" },
    F4: { keyCode: 115, code: "F4", key: "F4" },
    F5: { keyCode: 116, code: "F5", key: "F5" },
    F6: { keyCode: 117, code: "F6", key: "F6" },
    F7: { keyCode: 118, code: "F7", key: "F7" },
    F8: { keyCode: 119, code: "F8", key: "F8" },
    F9: { keyCode: 120, code: "F9", key: "F9" },
    F10: { keyCode: 121, code: "F10", key: "F10" },
    F11: { keyCode: 122, code: "F11", key: "F11" },
    F12: { keyCode: 123, code: "F12", key: "F12" },
    F13: { keyCode: 124, code: "F13", key: "F13" },
    F14: { keyCode: 125, code: "F14", key: "F14" },
    F15: { keyCode: 126, code: "F15", key: "F15" },
    F16: { keyCode: 127, code: "F16", key: "F16" },
    F17: { keyCode: 128, code: "F17", key: "F17" },
    F18: { keyCode: 129, code: "F18", key: "F18" },
    F19: { keyCode: 130, code: "F19", key: "F19" },
    F20: { keyCode: 131, code: "F20", key: "F20" },
    F21: { keyCode: 132, code: "F21", key: "F21" },
    F22: { keyCode: 133, code: "F22", key: "F22" },
    F23: { keyCode: 134, code: "F23", key: "F23" },
    F24: { keyCode: 135, code: "F24", key: "F24" },
    NumLock: { keyCode: 144, code: "NumLock", key: "NumLock" },
    ScrollLock: { keyCode: 145, code: "ScrollLock", key: "ScrollLock" },
    AudioVolumeMute: {
      keyCode: 173,
      code: "AudioVolumeMute",
      key: "AudioVolumeMute"
    },
    AudioVolumeDown: {
      keyCode: 174,
      code: "AudioVolumeDown",
      key: "AudioVolumeDown"
    },
    AudioVolumeUp: { keyCode: 175, code: "AudioVolumeUp", key: "AudioVolumeUp" },
    MediaTrackNext: {
      keyCode: 176,
      code: "MediaTrackNext",
      key: "MediaTrackNext"
    },
    MediaTrackPrevious: {
      keyCode: 177,
      code: "MediaTrackPrevious",
      key: "MediaTrackPrevious"
    },
    MediaStop: { keyCode: 178, code: "MediaStop", key: "MediaStop" },
    MediaPlayPause: {
      keyCode: 179,
      code: "MediaPlayPause",
      key: "MediaPlayPause"
    },
    Semicolon: { keyCode: 186, code: "Semicolon", shiftKey: ":", key: ";" },
    Equal: { keyCode: 187, code: "Equal", shiftKey: "+", key: "=" },
    NumpadEqual: { keyCode: 187, code: "NumpadEqual", key: "=", location: 3 },
    Comma: { keyCode: 188, code: "Comma", shiftKey: "<", key: "," },
    Minus: { keyCode: 189, code: "Minus", shiftKey: "_", key: "-" },
    Period: { keyCode: 190, code: "Period", shiftKey: ">", key: "." },
    Slash: { keyCode: 191, code: "Slash", shiftKey: "?", key: "/" },
    Backquote: { keyCode: 192, code: "Backquote", shiftKey: "~", key: "`" },
    BracketLeft: { keyCode: 219, code: "BracketLeft", shiftKey: "{", key: "[" },
    Backslash: { keyCode: 220, code: "Backslash", shiftKey: "|", key: "\\" },
    BracketRight: { keyCode: 221, code: "BracketRight", shiftKey: "}", key: "]" },
    Quote: { keyCode: 222, code: "Quote", shiftKey: '"', key: "'" },
    AltGraph: { keyCode: 225, code: "AltGraph", key: "AltGraph" },
    Props: { keyCode: 247, code: "Props", key: "CrSel" },
    Cancel: { keyCode: 3, key: "Cancel", code: "Abort" },
    Clear: { keyCode: 12, key: "Clear", code: "Numpad5", location: 3 },
    Shift: { keyCode: 16, key: "Shift", code: "ShiftLeft", location: 1 },
    Control: { keyCode: 17, key: "Control", code: "ControlLeft", location: 1 },
    Alt: { keyCode: 18, key: "Alt", code: "AltLeft", location: 1 },
    Accept: { keyCode: 30, key: "Accept" },
    ModeChange: { keyCode: 31, key: "ModeChange" },
    " ": { keyCode: 32, key: " ", code: "Space" },
    Print: { keyCode: 42, key: "Print" },
    Execute: { keyCode: 43, key: "Execute", code: "Open" },
    "\0": { keyCode: 46, key: "\0", code: "NumpadDecimal", location: 3 },
    a: { keyCode: 65, key: "a", code: "KeyA" },
    b: { keyCode: 66, key: "b", code: "KeyB" },
    c: { keyCode: 67, key: "c", code: "KeyC" },
    d: { keyCode: 68, key: "d", code: "KeyD" },
    e: { keyCode: 69, key: "e", code: "KeyE" },
    f: { keyCode: 70, key: "f", code: "KeyF" },
    g: { keyCode: 71, key: "g", code: "KeyG" },
    h: { keyCode: 72, key: "h", code: "KeyH" },
    i: { keyCode: 73, key: "i", code: "KeyI" },
    j: { keyCode: 74, key: "j", code: "KeyJ" },
    k: { keyCode: 75, key: "k", code: "KeyK" },
    l: { keyCode: 76, key: "l", code: "KeyL" },
    m: { keyCode: 77, key: "m", code: "KeyM" },
    n: { keyCode: 78, key: "n", code: "KeyN" },
    o: { keyCode: 79, key: "o", code: "KeyO" },
    p: { keyCode: 80, key: "p", code: "KeyP" },
    q: { keyCode: 81, key: "q", code: "KeyQ" },
    r: { keyCode: 82, key: "r", code: "KeyR" },
    s: { keyCode: 83, key: "s", code: "KeyS" },
    t: { keyCode: 84, key: "t", code: "KeyT" },
    u: { keyCode: 85, key: "u", code: "KeyU" },
    v: { keyCode: 86, key: "v", code: "KeyV" },
    w: { keyCode: 87, key: "w", code: "KeyW" },
    x: { keyCode: 88, key: "x", code: "KeyX" },
    y: { keyCode: 89, key: "y", code: "KeyY" },
    z: { keyCode: 90, key: "z", code: "KeyZ" },
    Meta: { keyCode: 91, key: "Meta", code: "MetaLeft", location: 1 },
    "*": { keyCode: 106, key: "*", code: "NumpadMultiply", location: 3 },
    "+": { keyCode: 107, key: "+", code: "NumpadAdd", location: 3 },
    "-": { keyCode: 109, key: "-", code: "NumpadSubtract", location: 3 },
    "/": { keyCode: 111, key: "/", code: "NumpadDivide", location: 3 },
    ";": { keyCode: 186, key: ";", code: "Semicolon" },
    "=": { keyCode: 187, key: "=", code: "Equal" },
    ",": { keyCode: 188, key: ",", code: "Comma" },
    ".": { keyCode: 190, key: ".", code: "Period" },
    "`": { keyCode: 192, key: "`", code: "Backquote" },
    "[": { keyCode: 219, key: "[", code: "BracketLeft" },
    "\\": { keyCode: 220, key: "\\", code: "Backslash" },
    "]": { keyCode: 221, key: "]", code: "BracketRight" },
    "'": { keyCode: 222, key: "'", code: "Quote" },
    Attn: { keyCode: 246, key: "Attn" },
    CrSel: { keyCode: 247, key: "CrSel", code: "Props" },
    ExSel: { keyCode: 248, key: "ExSel" },
    EraseEof: { keyCode: 249, key: "EraseEof" },
    Play: { keyCode: 250, key: "Play" },
    ZoomOut: { keyCode: 251, key: "ZoomOut" },
    ")": { keyCode: 48, key: ")", code: "Digit0" },
    "!": { keyCode: 49, key: "!", code: "Digit1" },
    "@": { keyCode: 50, key: "@", code: "Digit2" },
    "#": { keyCode: 51, key: "#", code: "Digit3" },
    $: { keyCode: 52, key: "$", code: "Digit4" },
    "%": { keyCode: 53, key: "%", code: "Digit5" },
    "^": { keyCode: 54, key: "^", code: "Digit6" },
    "&": { keyCode: 55, key: "&", code: "Digit7" },
    "(": { keyCode: 57, key: "(", code: "Digit9" },
    A: { keyCode: 65, key: "A", code: "KeyA" },
    B: { keyCode: 66, key: "B", code: "KeyB" },
    C: { keyCode: 67, key: "C", code: "KeyC" },
    D: { keyCode: 68, key: "D", code: "KeyD" },
    E: { keyCode: 69, key: "E", code: "KeyE" },
    F: { keyCode: 70, key: "F", code: "KeyF" },
    G: { keyCode: 71, key: "G", code: "KeyG" },
    H: { keyCode: 72, key: "H", code: "KeyH" },
    I: { keyCode: 73, key: "I", code: "KeyI" },
    J: { keyCode: 74, key: "J", code: "KeyJ" },
    K: { keyCode: 75, key: "K", code: "KeyK" },
    L: { keyCode: 76, key: "L", code: "KeyL" },
    M: { keyCode: 77, key: "M", code: "KeyM" },
    N: { keyCode: 78, key: "N", code: "KeyN" },
    O: { keyCode: 79, key: "O", code: "KeyO" },
    P: { keyCode: 80, key: "P", code: "KeyP" },
    Q: { keyCode: 81, key: "Q", code: "KeyQ" },
    R: { keyCode: 82, key: "R", code: "KeyR" },
    S: { keyCode: 83, key: "S", code: "KeyS" },
    T: { keyCode: 84, key: "T", code: "KeyT" },
    U: { keyCode: 85, key: "U", code: "KeyU" },
    V: { keyCode: 86, key: "V", code: "KeyV" },
    W: { keyCode: 87, key: "W", code: "KeyW" },
    X: { keyCode: 88, key: "X", code: "KeyX" },
    Y: { keyCode: 89, key: "Y", code: "KeyY" },
    Z: { keyCode: 90, key: "Z", code: "KeyZ" },
    ":": { keyCode: 186, key: ":", code: "Semicolon" },
    "<": { keyCode: 188, key: "<", code: "Comma" },
    _: { keyCode: 189, key: "_", code: "Minus" },
    ">": { keyCode: 190, key: ">", code: "Period" },
    "?": { keyCode: 191, key: "?", code: "Slash" },
    "~": { keyCode: 192, key: "~", code: "Backquote" },
    "{": { keyCode: 219, key: "{", code: "BracketLeft" },
    "|": { keyCode: 220, key: "|", code: "Backslash" },
    "}": { keyCode: 221, key: "}", code: "BracketRight" },
    '"': { keyCode: 222, key: '"', code: "Quote" },
    SoftLeft: { key: "SoftLeft", code: "SoftLeft", location: 4 },
    SoftRight: { key: "SoftRight", code: "SoftRight", location: 4 },
    Camera: { keyCode: 44, key: "Camera", code: "Camera", location: 4 },
    Call: { key: "Call", code: "Call", location: 4 },
    EndCall: { keyCode: 95, key: "EndCall", code: "EndCall", location: 4 },
    VolumeDown: {
      keyCode: 182,
      key: "VolumeDown",
      code: "VolumeDown",
      location: 4
    },
    VolumeUp: { keyCode: 183, key: "VolumeUp", code: "VolumeUp", location: 4 }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Input.js
  init_assert();
  var CdpKeyboard = class extends Keyboard {
    #client;
    #pressedKeys = /* @__PURE__ */ new Set();
    _modifiers = 0;
    constructor(client) {
      super();
      this.#client = client;
    }
    updateClient(client) {
      this.#client = client;
    }
    async down(key, options = {
      text: void 0,
      commands: []
    }) {
      const description = this.#keyDescriptionForString(key);
      const autoRepeat = this.#pressedKeys.has(description.code);
      this.#pressedKeys.add(description.code);
      this._modifiers |= this.#modifierBit(description.key);
      const text = options.text === void 0 ? description.text : options.text;
      await this.#client.send("Input.dispatchKeyEvent", {
        type: text ? "keyDown" : "rawKeyDown",
        modifiers: this._modifiers,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        key: description.key,
        text,
        unmodifiedText: text,
        autoRepeat,
        location: description.location,
        isKeypad: description.location === 3,
        commands: options.commands
      });
    }
    #modifierBit(key) {
      if (key === "Alt") {
        return 1;
      }
      if (key === "Control") {
        return 2;
      }
      if (key === "Meta") {
        return 4;
      }
      if (key === "Shift") {
        return 8;
      }
      return 0;
    }
    #keyDescriptionForString(keyString) {
      const shift = this._modifiers & 8;
      const description = {
        key: "",
        keyCode: 0,
        code: "",
        text: "",
        location: 0
      };
      const definition = _keyDefinitions[keyString];
      assert2(definition, `Unknown key: "${keyString}"`);
      if (definition.key) {
        description.key = definition.key;
      }
      if (shift && definition.shiftKey) {
        description.key = definition.shiftKey;
      }
      if (definition.keyCode) {
        description.keyCode = definition.keyCode;
      }
      if (shift && definition.shiftKeyCode) {
        description.keyCode = definition.shiftKeyCode;
      }
      if (definition.code) {
        description.code = definition.code;
      }
      if (definition.location) {
        description.location = definition.location;
      }
      if (description.key.length === 1) {
        description.text = description.key;
      }
      if (definition.text) {
        description.text = definition.text;
      }
      if (shift && definition.shiftText) {
        description.text = definition.shiftText;
      }
      if (this._modifiers & ~8) {
        description.text = "";
      }
      return description;
    }
    async up(key) {
      const description = this.#keyDescriptionForString(key);
      this._modifiers &= ~this.#modifierBit(description.key);
      this.#pressedKeys.delete(description.code);
      await this.#client.send("Input.dispatchKeyEvent", {
        type: "keyUp",
        modifiers: this._modifiers,
        key: description.key,
        windowsVirtualKeyCode: description.keyCode,
        code: description.code,
        location: description.location
      });
    }
    async sendCharacter(char) {
      await this.#client.send("Input.insertText", { text: char });
    }
    charIsKey(char) {
      return !!_keyDefinitions[char];
    }
    async type(text, options = {}) {
      const delay = options.delay || void 0;
      for (const char of text) {
        if (this.charIsKey(char)) {
          await this.press(char, { delay });
        } else {
          if (delay) {
            await new Promise((f7) => {
              return setTimeout(f7, delay);
            });
          }
          await this.sendCharacter(char);
        }
      }
    }
    async press(key, options = {}) {
      const { delay = null } = options;
      await this.down(key, options);
      if (delay) {
        await new Promise((f7) => {
          return setTimeout(f7, options.delay);
        });
      }
      await this.up(key);
    }
  };
  var getFlag = (button) => {
    switch (button) {
      case MouseButton.Left:
        return 1;
      case MouseButton.Right:
        return 2;
      case MouseButton.Middle:
        return 4;
      case MouseButton.Back:
        return 8;
      case MouseButton.Forward:
        return 16;
    }
  };
  var getButtonFromPressedButtons = (buttons) => {
    if (buttons & 1) {
      return MouseButton.Left;
    } else if (buttons & 2) {
      return MouseButton.Right;
    } else if (buttons & 4) {
      return MouseButton.Middle;
    } else if (buttons & 8) {
      return MouseButton.Back;
    } else if (buttons & 16) {
      return MouseButton.Forward;
    }
    return "none";
  };
  var CdpMouse = class extends Mouse {
    #client;
    #keyboard;
    constructor(client, keyboard) {
      super();
      this.#client = client;
      this.#keyboard = keyboard;
    }
    updateClient(client) {
      this.#client = client;
    }
    #_state = {
      position: { x: 0, y: 0 },
      buttons: 0
    };
    get #state() {
      return Object.assign({ ...this.#_state }, ...this.#transactions);
    }
    // Transactions can run in parallel, so we store each of thme in this array.
    #transactions = [];
    #createTransaction() {
      const transaction = {};
      this.#transactions.push(transaction);
      const popTransaction = () => {
        this.#transactions.splice(this.#transactions.indexOf(transaction), 1);
      };
      return {
        update: (updates) => {
          Object.assign(transaction, updates);
        },
        commit: () => {
          this.#_state = { ...this.#_state, ...transaction };
          popTransaction();
        },
        rollback: popTransaction
      };
    }
    /**
     * This is a shortcut for a typical update, commit/rollback lifecycle based on
     * the error of the action.
     */
    async #withTransaction(action) {
      const { update, commit, rollback } = this.#createTransaction();
      try {
        await action(update);
        commit();
      } catch (error) {
        rollback();
        throw error;
      }
    }
    async reset() {
      const actions = [];
      for (const [flag, button] of [
        [1, MouseButton.Left],
        [4, MouseButton.Middle],
        [2, MouseButton.Right],
        [16, MouseButton.Forward],
        [8, MouseButton.Back]
      ]) {
        if (this.#state.buttons & flag) {
          actions.push(this.up({ button }));
        }
      }
      if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {
        actions.push(this.move(0, 0));
      }
      await Promise.all(actions);
    }
    async move(x4, y6, options = {}) {
      const { steps = 1 } = options;
      const from = this.#state.position;
      const to = { x: x4, y: y6 };
      for (let i7 = 1; i7 <= steps; i7++) {
        await this.#withTransaction((updateState) => {
          updateState({
            position: {
              x: from.x + (to.x - from.x) * (i7 / steps),
              y: from.y + (to.y - from.y) * (i7 / steps)
            }
          });
          const { buttons, position } = this.#state;
          return this.#client.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            modifiers: this.#keyboard._modifiers,
            buttons,
            button: getButtonFromPressedButtons(buttons),
            ...position
          });
        });
      }
    }
    async down(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (this.#state.buttons & flag) {
        throw new Error(`'${button}' is already pressed.`);
      }
      await this.#withTransaction((updateState) => {
        updateState({
          buttons: this.#state.buttons | flag
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          modifiers: this.#keyboard._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async up(options = {}) {
      const { button = MouseButton.Left, clickCount = 1 } = options;
      const flag = getFlag(button);
      if (!flag) {
        throw new Error(`Unsupported mouse button: ${button}`);
      }
      if (!(this.#state.buttons & flag)) {
        throw new Error(`'${button}' is not pressed.`);
      }
      await this.#withTransaction((updateState) => {
        updateState({
          buttons: this.#state.buttons & ~flag
        });
        const { buttons, position } = this.#state;
        return this.#client.send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          modifiers: this.#keyboard._modifiers,
          clickCount,
          buttons,
          button,
          ...position
        });
      });
    }
    async click(x4, y6, options = {}) {
      const { delay, count = 1, clickCount = count } = options;
      if (count < 1) {
        throw new Error("Click must occur a positive number of times.");
      }
      const actions = [this.move(x4, y6)];
      if (clickCount === count) {
        for (let i7 = 1; i7 < count; ++i7) {
          actions.push(this.down({ ...options, clickCount: i7 }), this.up({ ...options, clickCount: i7 }));
        }
      }
      actions.push(this.down({ ...options, clickCount }));
      if (typeof delay === "number") {
        await Promise.all(actions);
        actions.length = 0;
        await new Promise((resolve3) => {
          setTimeout(resolve3, delay);
        });
      }
      actions.push(this.up({ ...options, clickCount }));
      await Promise.all(actions);
    }
    async wheel(options = {}) {
      const { deltaX = 0, deltaY = 0 } = options;
      const { position, buttons } = this.#state;
      await this.#client.send("Input.dispatchMouseEvent", {
        type: "mouseWheel",
        pointerType: "mouse",
        modifiers: this.#keyboard._modifiers,
        deltaY,
        deltaX,
        buttons,
        ...position
      });
    }
    async drag(start, target) {
      const promise = new Promise((resolve3) => {
        this.#client.once("Input.dragIntercepted", (event) => {
          return resolve3(event.data);
        });
      });
      await this.move(start.x, start.y);
      await this.down();
      await this.move(target.x, target.y);
      return await promise;
    }
    async dragEnter(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "dragEnter",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async dragOver(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "dragOver",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async drop(target, data) {
      await this.#client.send("Input.dispatchDragEvent", {
        type: "drop",
        x: target.x,
        y: target.y,
        modifiers: this.#keyboard._modifiers,
        data
      });
    }
    async dragAndDrop(start, target, options = {}) {
      const { delay = null } = options;
      const data = await this.drag(start, target);
      await this.dragEnter(target, data);
      await this.dragOver(target, data);
      if (delay) {
        await new Promise((resolve3) => {
          return setTimeout(resolve3, delay);
        });
      }
      await this.drop(target, data);
      await this.up();
    }
  };
  var CdpTouchscreen = class extends Touchscreen {
    #client;
    #keyboard;
    constructor(client, keyboard) {
      super();
      this.#client = client;
      this.#keyboard = keyboard;
    }
    updateClient(client) {
      this.#client = client;
    }
    async touchStart(x4, y6) {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchStart",
        touchPoints: [
          {
            x: Math.round(x4),
            y: Math.round(y6),
            radiusX: 0.5,
            radiusY: 0.5
          }
        ],
        modifiers: this.#keyboard._modifiers
      });
    }
    async touchMove(x4, y6) {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchMove",
        touchPoints: [
          {
            x: Math.round(x4),
            y: Math.round(y6),
            radiusX: 0.5,
            radiusY: 0.5
          }
        ],
        modifiers: this.#keyboard._modifiers
      });
    }
    async touchEnd() {
      await this.#client.send("Input.dispatchTouchEvent", {
        type: "touchEnd",
        touchPoints: [],
        modifiers: this.#keyboard._modifiers
      });
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  init_Tracing();

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/WebWorker.js
  init_dirname();
  init_buffer2();
  init_process2();

  // node_modules/puppeteer-core/lib/esm/puppeteer/api/WebWorker.js
  init_dirname();
  init_buffer2();
  init_process2();
  init_EventEmitter();
  init_TimeoutSettings();
  init_util2();
  var WebWorker = class extends EventEmitter {
    /**
     * @internal
     */
    timeoutSettings = new TimeoutSettings();
    #url;
    /**
     * @internal
     */
    constructor(url) {
      super();
      this.#url = url;
    }
    /**
     * The URL of this web worker.
     */
    url() {
      return this.#url;
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * As a rule of thumb, if the return value of the given function is more
     * complicated than a JSON object (e.g. most classes), then
     * {@link WebWorker.evaluate | evaluate} will _likely_ return some truncated
     * value (or `{}`). This is because we are not returning the actual return
     * value, but a deserialized version as a result of transferring the return
     * value through a protocol to Puppeteer.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns The result of `func`.
     */
    async evaluate(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluate.name, func);
      return await this.mainRealm().evaluate(func, ...args);
    }
    /**
     * Evaluates a given function in the {@link WebWorker | worker}.
     *
     * @remarks If the given function returns a promise,
     * {@link WebWorker.evaluate | evaluate} will wait for the promise to resolve.
     *
     * In general, you should use
     * {@link WebWorker.evaluateHandle | evaluateHandle} if
     * {@link WebWorker.evaluate | evaluate} cannot serialize the return value
     * properly or you need a mutable {@link JSHandle | handle} to the return
     * object.
     *
     * @param func - Function to be evaluated.
     * @param args - Arguments to pass into `func`.
     * @returns A {@link JSHandle | handle} to the return value of `func`.
     */
    async evaluateHandle(func, ...args) {
      func = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, func);
      return await this.mainRealm().evaluateHandle(func, ...args);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/WebWorker.js
  init_TimeoutSettings();
  init_util2();
  var CdpWebWorker = class extends WebWorker {
    #world;
    #client;
    constructor(client, url, consoleAPICalled, exceptionThrown) {
      super(url);
      this.#client = client;
      this.#world = new IsolatedWorld(this, new TimeoutSettings());
      this.#client.once("Runtime.executionContextCreated", async (event) => {
        this.#world.setContext(new ExecutionContext(client, event.context, this.#world));
      });
      this.#client.on("Runtime.consoleAPICalled", async (event) => {
        try {
          return consoleAPICalled(event.type, event.args.map((object) => {
            return new CdpJSHandle(this.#world, object);
          }), event.stackTrace);
        } catch (err) {
          debugError(err);
        }
      });
      this.#client.on("Runtime.exceptionThrown", exceptionThrown);
      this.#client.send("Runtime.enable").catch(debugError);
    }
    mainRealm() {
      return this.#world;
    }
    get client() {
      return this.#client;
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Page.js
  var __addDisposableResource13 = function(env2, value, async) {
    if (value !== null && value !== void 0) {
      if (typeof value !== "object" && typeof value !== "function")
        throw new TypeError("Object expected.");
      var dispose;
      if (async) {
        if (!Symbol.asyncDispose)
          throw new TypeError("Symbol.asyncDispose is not defined.");
        dispose = value[Symbol.asyncDispose];
      }
      if (dispose === void 0) {
        if (!Symbol.dispose)
          throw new TypeError("Symbol.dispose is not defined.");
        dispose = value[Symbol.dispose];
      }
      if (typeof dispose !== "function")
        throw new TypeError("Object not disposable.");
      env2.stack.push({ value, dispose, async });
    } else if (async) {
      env2.stack.push({ async: true });
    }
    return value;
  };
  var __disposeResources13 = /* @__PURE__ */ function(SuppressedError2) {
    return function(env2) {
      function fail2(e9) {
        env2.error = env2.hasError ? new SuppressedError2(e9, env2.error, "An error was suppressed during disposal.") : e9;
        env2.hasError = true;
      }
      function next() {
        while (env2.stack.length) {
          var rec = env2.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e9) {
                fail2(e9);
                return next();
              });
          } catch (e9) {
            fail2(e9);
          }
        }
        if (env2.hasError)
          throw env2.error;
      }
      return next();
    };
  }(typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e9 = new Error(message);
    return e9.name = "SuppressedError", e9.error = error, e9.suppressed = suppressed, e9;
  });
  var CdpPage = class _CdpPage extends Page {
    static async _create(client, target, ignoreHTTPSErrors, defaultViewport) {
      const page = new _CdpPage(client, target, ignoreHTTPSErrors);
      await page.#initialize();
      if (defaultViewport) {
        try {
          await page.setViewport(defaultViewport);
        } catch (err) {
          if (isErrorLike(err) && isTargetClosedError(err)) {
            debugError(err);
          } else {
            throw err;
          }
        }
      }
      return page;
    }
    #closed = false;
    #targetManager;
    #primaryTargetClient;
    #primaryTarget;
    #tabTargetClient;
    #tabTarget;
    #keyboard;
    #mouse;
    #touchscreen;
    #accessibility;
    #frameManager;
    #emulationManager;
    #tracing;
    #bindings = /* @__PURE__ */ new Map();
    #exposedFunctions = /* @__PURE__ */ new Map();
    #coverage;
    #viewport;
    #workers = /* @__PURE__ */ new Map();
    #fileChooserDeferreds = /* @__PURE__ */ new Set();
    #sessionCloseDeferred = Deferred.create();
    #serviceWorkerBypassed = false;
    #userDragInterceptionEnabled = false;
    #frameManagerHandlers = [
      [
        FrameManagerEvent.FrameAttached,
        (frame) => {
          this.emit("frameattached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameDetached,
        (frame) => {
          this.emit("framedetached", frame);
        }
      ],
      [
        FrameManagerEvent.FrameNavigated,
        (frame) => {
          this.emit("framenavigated", frame);
        }
      ]
    ];
    #networkManagerHandlers = [
      [
        NetworkManagerEvent.Request,
        (request) => {
          this.emit("request", request);
        }
      ],
      [
        NetworkManagerEvent.RequestServedFromCache,
        (request) => {
          this.emit("requestservedfromcache", request);
        }
      ],
      [
        NetworkManagerEvent.Response,
        (response) => {
          this.emit("response", response);
        }
      ],
      [
        NetworkManagerEvent.RequestFailed,
        (request) => {
          this.emit("requestfailed", request);
        }
      ],
      [
        NetworkManagerEvent.RequestFinished,
        (request) => {
          this.emit("requestfinished", request);
        }
      ]
    ];
    #sessionHandlers = [
      [
        CDPSessionEvent.Disconnected,
        () => {
          this.#sessionCloseDeferred.reject(new TargetCloseError("Target closed"));
        }
      ],
      [
        "Page.domContentEventFired",
        () => {
          return this.emit("domcontentloaded", void 0);
        }
      ],
      [
        "Page.loadEventFired",
        () => {
          return this.emit("load", void 0);
        }
      ],
      ["Runtime.consoleAPICalled", this.#onConsoleAPI.bind(this)],
      ["Runtime.bindingCalled", this.#onBindingCalled.bind(this)],
      ["Page.javascriptDialogOpening", this.#onDialog.bind(this)],
      ["Runtime.exceptionThrown", this.#handleException.bind(this)],
      ["Inspector.targetCrashed", this.#onTargetCrashed.bind(this)],
      ["Performance.metrics", this.#emitMetrics.bind(this)],
      ["Log.entryAdded", this.#onLogEntryAdded.bind(this)],
      ["Page.fileChooserOpened", this.#onFileChooser.bind(this)]
    ];
    constructor(client, target, ignoreHTTPSErrors) {
      super();
      this.#primaryTargetClient = client;
      this.#tabTargetClient = client.parentSession();
      assert2(this.#tabTargetClient, "Tab target session is not defined.");
      this.#tabTarget = this.#tabTargetClient._target();
      assert2(this.#tabTarget, "Tab target is not defined.");
      this.#primaryTarget = target;
      this.#targetManager = target._targetManager();
      this.#keyboard = new CdpKeyboard(client);
      this.#mouse = new CdpMouse(client, this.#keyboard);
      this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);
      this.#accessibility = new Accessibility(client);
      this.#frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
      this.#emulationManager = new EmulationManager(client);
      this.#tracing = new Tracing(client);
      this.#coverage = new Coverage(client);
      this.#viewport = null;
      for (const [eventName, handler] of this.#frameManagerHandlers) {
        this.#frameManager.on(eventName, handler);
      }
      for (const [eventName, handler] of this.#networkManagerHandlers) {
        this.#frameManager.networkManager.on(eventName, handler);
      }
      this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));
      this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));
      this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
      this.#tabTarget._isClosedDeferred.valueOrThrow().then(() => {
        this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
        this.emit("close", void 0);
        this.#closed = true;
      }).catch(debugError);
      this.#setupPrimaryTargetListeners();
    }
    async #onActivation(newSession) {
      this.#primaryTargetClient = newSession;
      assert2(this.#primaryTargetClient instanceof CdpCDPSession, "CDPSession is not instance of CDPSessionImpl");
      this.#primaryTarget = this.#primaryTargetClient._target();
      assert2(this.#primaryTarget, "Missing target on swap");
      this.#keyboard.updateClient(newSession);
      this.#mouse.updateClient(newSession);
      this.#touchscreen.updateClient(newSession);
      this.#accessibility.updateClient(newSession);
      this.#emulationManager.updateClient(newSession);
      this.#tracing.updateClient(newSession);
      this.#coverage.updateClient(newSession);
      await this.#frameManager.swapFrameTree(newSession);
      this.#setupPrimaryTargetListeners();
    }
    async #onSecondaryTarget(session) {
      assert2(session instanceof CdpCDPSession);
      if (session._target()._subtype() !== "prerender") {
        return;
      }
      this.#frameManager.registerSpeculativeSession(session).catch(debugError);
      this.#emulationManager.registerSpeculativeSession(session).catch(debugError);
    }
    /**
     * Sets up listeners for the primary target. The primary target can change
     * during a navigation to a prerended page.
     */
    #setupPrimaryTargetListeners() {
      this.#primaryTargetClient.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
      for (const [eventName, handler] of this.#sessionHandlers) {
        this.#primaryTargetClient.on(eventName, handler);
      }
    }
    #onDetachedFromTarget = (target) => {
      const sessionId = target._session()?.id();
      const worker = this.#workers.get(sessionId);
      if (!worker) {
        return;
      }
      this.#workers.delete(sessionId);
      this.emit("workerdestroyed", worker);
    };
    #onAttachedToTarget = (session) => {
      assert2(session instanceof CdpCDPSession);
      this.#frameManager.onAttachedToTarget(session._target());
      if (session._target()._getTargetInfo().type === "worker") {
        const worker = new CdpWebWorker(session, session._target().url(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));
        this.#workers.set(session.id(), worker);
        this.emit("workercreated", worker);
      }
      session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);
    };
    async #initialize() {
      try {
        await Promise.all([
          this.#frameManager.initialize(this.#primaryTargetClient),
          this.#primaryTargetClient.send("Performance.enable"),
          this.#primaryTargetClient.send("Log.enable")
        ]);
      } catch (err) {
        if (isErrorLike(err) && isTargetClosedError(err)) {
          debugError(err);
        } else {
          throw err;
        }
      }
    }
    async #onFileChooser(event) {
      const env_1 = { stack: [], error: void 0, hasError: false };
      try {
        if (!this.#fileChooserDeferreds.size) {
          return;
        }
        const frame = this.#frameManager.frame(event.frameId);
        assert2(frame, "This should never happen.");
        const handle = __addDisposableResource13(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);
        const fileChooser = new FileChooser(handle.move(), event);
        for (const promise of this.#fileChooserDeferreds) {
          promise.resolve(fileChooser);
        }
        this.#fileChooserDeferreds.clear();
      } catch (e_1) {
        env_1.error = e_1;
        env_1.hasError = true;
      } finally {
        __disposeResources13(env_1);
      }
    }
    _client() {
      return this.#primaryTargetClient;
    }
    isServiceWorkerBypassed() {
      return this.#serviceWorkerBypassed;
    }
    isDragInterceptionEnabled() {
      return this.#userDragInterceptionEnabled;
    }
    isJavaScriptEnabled() {
      return this.#emulationManager.javascriptEnabled;
    }
    async waitForFileChooser(options = {}) {
      const needsEnable = this.#fileChooserDeferreds.size === 0;
      const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
      const deferred = Deferred.create({
        message: `Waiting for \`FileChooser\` failed: ${timeout2}ms exceeded`,
        timeout: timeout2
      });
      this.#fileChooserDeferreds.add(deferred);
      let enablePromise;
      if (needsEnable) {
        enablePromise = this.#primaryTargetClient.send("Page.setInterceptFileChooserDialog", {
          enabled: true
        });
      }
      try {
        const [result] = await Promise.all([
          deferred.valueOrThrow(),
          enablePromise
        ]);
        return result;
      } catch (error) {
        this.#fileChooserDeferreds.delete(deferred);
        throw error;
      }
    }
    async setGeolocation(options) {
      return await this.#emulationManager.setGeolocation(options);
    }
    target() {
      return this.#primaryTarget;
    }
    browser() {
      return this.#primaryTarget.browser();
    }
    browserContext() {
      return this.#primaryTarget.browserContext();
    }
    #onTargetCrashed() {
      this.emit("error", new Error("Page crashed!"));
    }
    #onLogEntryAdded(event) {
      const { level, text, args, source: source2, url, lineNumber } = event.entry;
      if (args) {
        args.map((arg) => {
          void releaseObject(this.#primaryTargetClient, arg);
        });
      }
      if (source2 !== "worker") {
        this.emit("console", new ConsoleMessage(level, text, [], [{ url, lineNumber }]));
      }
    }
    mainFrame() {
      return this.#frameManager.mainFrame();
    }
    get keyboard() {
      return this.#keyboard;
    }
    get touchscreen() {
      return this.#touchscreen;
    }
    get coverage() {
      return this.#coverage;
    }
    get tracing() {
      return this.#tracing;
    }
    get accessibility() {
      return this.#accessibility;
    }
    frames() {
      return this.#frameManager.frames();
    }
    workers() {
      return Array.from(this.#workers.values());
    }
    async setRequestInterception(value) {
      return await this.#frameManager.networkManager.setRequestInterception(value);
    }
    async setBypassServiceWorker(bypass) {
      this.#serviceWorkerBypassed = bypass;
      return await this.#primaryTargetClient.send("Network.setBypassServiceWorker", { bypass });
    }
    async setDragInterception(enabled) {
      this.#userDragInterceptionEnabled = enabled;
      return await this.#primaryTargetClient.send("Input.setInterceptDrags", {
        enabled
      });
    }
    async setOfflineMode(enabled) {
      return await this.#frameManager.networkManager.setOfflineMode(enabled);
    }
    async emulateNetworkConditions(networkConditions) {
      return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);
    }
    setDefaultNavigationTimeout(timeout2) {
      this._timeoutSettings.setDefaultNavigationTimeout(timeout2);
    }
    setDefaultTimeout(timeout2) {
      this._timeoutSettings.setDefaultTimeout(timeout2);
    }
    getDefaultTimeout() {
      return this._timeoutSettings.timeout();
    }
    async queryObjects(prototypeHandle) {
      assert2(!prototypeHandle.disposed, "Prototype JSHandle is disposed!");
      assert2(prototypeHandle.id, "Prototype JSHandle must not be referencing primitive value");
      const response = await this.mainFrame().client.send("Runtime.queryObjects", {
        prototypeObjectId: prototypeHandle.id
      });
      return createCdpHandle(this.mainFrame().mainRealm(), response.objects);
    }
    async cookies(...urls) {
      const originalCookies = (await this.#primaryTargetClient.send("Network.getCookies", {
        urls: urls.length ? urls : [this.url()]
      })).cookies;
      const unsupportedCookieAttributes = ["priority"];
      const filterUnsupportedAttributes = (cookie) => {
        for (const attr of unsupportedCookieAttributes) {
          delete cookie[attr];
        }
        return cookie;
      };
      return originalCookies.map(filterUnsupportedAttributes);
    }
    async deleteCookie(...cookies) {
      const pageURL = this.url();
      for (const cookie of cookies) {
        const item = Object.assign({}, cookie);
        if (!cookie.url && pageURL.startsWith("http")) {
          item.url = pageURL;
        }
        await this.#primaryTargetClient.send("Network.deleteCookies", item);
      }
    }
    async setCookie(...cookies) {
      const pageURL = this.url();
      const startsWithHTTP = pageURL.startsWith("http");
      const items = cookies.map((cookie) => {
        const item = Object.assign({}, cookie);
        if (!item.url && startsWithHTTP) {
          item.url = pageURL;
        }
        assert2(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
        assert2(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
        return item;
      });
      await this.deleteCookie(...items);
      if (items.length) {
        await this.#primaryTargetClient.send("Network.setCookies", {
          cookies: items
        });
      }
    }
    async exposeFunction(name2, pptrFunction) {
      if (this.#bindings.has(name2)) {
        throw new Error(`Failed to add page binding with name ${name2}: window['${name2}'] already exists!`);
      }
      let binding2;
      switch (typeof pptrFunction) {
        case "function":
          binding2 = new Binding(name2, pptrFunction);
          break;
        default:
          binding2 = new Binding(name2, pptrFunction.default);
          break;
      }
      this.#bindings.set(name2, binding2);
      const expression = pageBindingInitString("exposedFun", name2);
      await this.#primaryTargetClient.send("Runtime.addBinding", { name: name2 });
      const { identifier } = await this.#primaryTargetClient.send("Page.addScriptToEvaluateOnNewDocument", {
        source: expression
      });
      this.#exposedFunctions.set(name2, identifier);
      await Promise.all(this.frames().map((frame) => {
        if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
          return;
        }
        return frame.evaluate(expression).catch(debugError);
      }));
    }
    async removeExposedFunction(name2) {
      const exposedFun = this.#exposedFunctions.get(name2);
      if (!exposedFun) {
        throw new Error(`Failed to remove page binding with name ${name2}: window['${name2}'] does not exists!`);
      }
      await this.#primaryTargetClient.send("Runtime.removeBinding", { name: name2 });
      await this.removeScriptToEvaluateOnNewDocument(exposedFun);
      await Promise.all(this.frames().map((frame) => {
        if (frame !== this.mainFrame() && !frame._hasStartedLoading) {
          return;
        }
        return frame.evaluate((name3) => {
          globalThis[name3] = void 0;
        }, name2).catch(debugError);
      }));
      this.#exposedFunctions.delete(name2);
      this.#bindings.delete(name2);
    }
    async authenticate(credentials) {
      return await this.#frameManager.networkManager.authenticate(credentials);
    }
    async setExtraHTTPHeaders(headers) {
      return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);
    }
    async setUserAgent(userAgent, userAgentMetadata) {
      return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);
    }
    async metrics() {
      const response = await this.#primaryTargetClient.send("Performance.getMetrics");
      return this.#buildMetricsObject(response.metrics);
    }
    #emitMetrics(event) {
      this.emit("metrics", {
        title: event.title,
        metrics: this.#buildMetricsObject(event.metrics)
      });
    }
    #buildMetricsObject(metrics) {
      const result = {};
      for (const metric of metrics || []) {
        if (supportedMetrics.has(metric.name)) {
          result[metric.name] = metric.value;
        }
      }
      return result;
    }
    #handleException(exception) {
      this.emit("pageerror", createClientError(exception.exceptionDetails));
    }
    async #onConsoleAPI(event) {
      if (event.executionContextId === 0) {
        return;
      }
      const context = this.#frameManager.getExecutionContextById(event.executionContextId, this.#primaryTargetClient);
      if (!context) {
        debugError(new Error(`ExecutionContext not found for a console message: ${JSON.stringify(event)}`));
        return;
      }
      const values = event.args.map((arg) => {
        return createCdpHandle(context._world, arg);
      });
      this.#addConsoleMessage(event.type, values, event.stackTrace);
    }
    async #onBindingCalled(event) {
      let payload;
      try {
        payload = JSON.parse(event.payload);
      } catch {
        return;
      }
      const { type, name: name2, seq, args, isTrivial } = payload;
      if (type !== "exposedFun") {
        return;
      }
      const context = this.#frameManager.executionContextById(event.executionContextId, this.#primaryTargetClient);
      if (!context) {
        return;
      }
      const binding2 = this.#bindings.get(name2);
      await binding2?.run(context, seq, args, isTrivial);
    }
    #addConsoleMessage(eventType, args, stackTrace) {
      if (!this.listenerCount(
        "console"
        /* PageEvent.Console */
      )) {
        args.forEach((arg) => {
          return arg.dispose();
        });
        return;
      }
      const textTokens = [];
      for (const arg of args) {
        const remoteObject = arg.remoteObject();
        if (remoteObject.objectId) {
          textTokens.push(arg.toString());
        } else {
          textTokens.push(valueFromRemoteObject(remoteObject));
        }
      }
      const stackTraceLocations = [];
      if (stackTrace) {
        for (const callFrame of stackTrace.callFrames) {
          stackTraceLocations.push({
            url: callFrame.url,
            lineNumber: callFrame.lineNumber,
            columnNumber: callFrame.columnNumber
          });
        }
      }
      const message = new ConsoleMessage(eventType, textTokens.join(" "), args, stackTraceLocations);
      this.emit("console", message);
    }
    #onDialog(event) {
      const type = validateDialogType(event.type);
      const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);
      this.emit("dialog", dialog);
    }
    async reload(options) {
      const [result] = await Promise.all([
        this.waitForNavigation(options),
        this.#primaryTargetClient.send("Page.reload")
      ]);
      return result;
    }
    async createCDPSession() {
      return await this.target().createCDPSession();
    }
    async waitForRequest(urlOrPredicate, options = {}) {
      const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
      return await waitForHTTP(this.#frameManager.networkManager, NetworkManagerEvent.Request, urlOrPredicate, timeout2, this.#sessionCloseDeferred);
    }
    async waitForResponse(urlOrPredicate, options = {}) {
      const { timeout: timeout2 = this._timeoutSettings.timeout() } = options;
      return await waitForHTTP(this.#frameManager.networkManager, NetworkManagerEvent.Response, urlOrPredicate, timeout2, this.#sessionCloseDeferred);
    }
    async waitForNetworkIdle(options = {}) {
      const { idleTime = NETWORK_IDLE_TIME, timeout: ms = this._timeoutSettings.timeout() } = options;
      await fe(this._waitForNetworkIdle(this.#frameManager.networkManager, idleTime).pipe(Oe(timeout(ms), j(this.#sessionCloseDeferred.valueOrThrow()))));
    }
    async goBack(options = {}) {
      return await this.#go(-1, options);
    }
    async goForward(options = {}) {
      return await this.#go(1, options);
    }
    async #go(delta, options) {
      const history = await this.#primaryTargetClient.send("Page.getNavigationHistory");
      const entry = history.entries[history.currentIndex + delta];
      if (!entry) {
        return null;
      }
      const result = await Promise.all([
        this.waitForNavigation(options),
        this.#primaryTargetClient.send("Page.navigateToHistoryEntry", {
          entryId: entry.id
        })
      ]);
      return result[0];
    }
    async bringToFront() {
      await this.#primaryTargetClient.send("Page.bringToFront");
    }
    async setJavaScriptEnabled(enabled) {
      return await this.#emulationManager.setJavaScriptEnabled(enabled);
    }
    async setBypassCSP(enabled) {
      await this.#primaryTargetClient.send("Page.setBypassCSP", { enabled });
    }
    async emulateMediaType(type) {
      return await this.#emulationManager.emulateMediaType(type);
    }
    async emulateCPUThrottling(factor) {
      return await this.#emulationManager.emulateCPUThrottling(factor);
    }
    async emulateMediaFeatures(features2) {
      return await this.#emulationManager.emulateMediaFeatures(features2);
    }
    async emulateTimezone(timezoneId) {
      return await this.#emulationManager.emulateTimezone(timezoneId);
    }
    async emulateIdleState(overrides) {
      return await this.#emulationManager.emulateIdleState(overrides);
    }
    async emulateVisionDeficiency(type) {
      return await this.#emulationManager.emulateVisionDeficiency(type);
    }
    async setViewport(viewport) {
      const needsReload = await this.#emulationManager.emulateViewport(viewport);
      this.#viewport = viewport;
      if (needsReload) {
        await this.reload();
      }
    }
    viewport() {
      return this.#viewport;
    }
    async evaluateOnNewDocument(pageFunction, ...args) {
      const source2 = evaluationString(pageFunction, ...args);
      const { identifier } = await this.#primaryTargetClient.send("Page.addScriptToEvaluateOnNewDocument", {
        source: source2
      });
      return { identifier };
    }
    async removeScriptToEvaluateOnNewDocument(identifier) {
      await this.#primaryTargetClient.send("Page.removeScriptToEvaluateOnNewDocument", {
        identifier
      });
    }
    async setCacheEnabled(enabled = true) {
      await this.#frameManager.networkManager.setCacheEnabled(enabled);
    }
    async _screenshot(options) {
      const env_2 = { stack: [], error: void 0, hasError: false };
      try {
        const { fromSurface, omitBackground, optimizeForSpeed, quality, clip: userClip, type, captureBeyondViewport } = options;
        const isFirefox = this.target()._targetManager() instanceof FirefoxTargetManager;
        const stack = __addDisposableResource13(env_2, new AsyncDisposableStack(), true);
        if (!isFirefox && omitBackground && (type === "png" || type === "webp")) {
          await this.#emulationManager.setTransparentBackgroundColor();
          stack.defer(async () => {
            await this.#emulationManager.resetDefaultBackgroundColor().catch(debugError);
          });
        }
        let clip = userClip;
        if (clip && !captureBeyondViewport) {
          const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {
            const { height, pageLeft: x4, pageTop: y6, width } = window.visualViewport;
            return { x: x4, y: y6, height, width };
          });
          clip = getIntersectionRect(clip, viewport);
        }
        const { data } = await this.#primaryTargetClient.send("Page.captureScreenshot", {
          format: type,
          ...optimizeForSpeed ? { optimizeForSpeed } : {},
          ...quality !== void 0 ? { quality: Math.round(quality) } : {},
          ...clip ? { clip: { ...clip, scale: clip.scale ?? 1 } } : {},
          ...!fromSurface ? { fromSurface } : {},
          captureBeyondViewport
        });
        return data;
      } catch (e_2) {
        env_2.error = e_2;
        env_2.hasError = true;
      } finally {
        const result_1 = __disposeResources13(env_2);
        if (result_1)
          await result_1;
      }
    }
    async createPDFStream(options = {}) {
      const { landscape, displayHeaderFooter, headerTemplate, footerTemplate, printBackground, scale, width: paperWidth, height: paperHeight, margin, pageRanges, preferCSSPageSize, omitBackground, timeout: ms, tagged: generateTaggedPDF } = this._getPDFOptions(options);
      if (omitBackground) {
        await this.#emulationManager.setTransparentBackgroundColor();
      }
      const printCommandPromise = this.#primaryTargetClient.send("Page.printToPDF", {
        transferMode: "ReturnAsStream",
        landscape,
        displayHeaderFooter,
        headerTemplate,
        footerTemplate,
        printBackground,
        scale,
        paperWidth,
        paperHeight,
        marginTop: margin.top,
        marginBottom: margin.bottom,
        marginLeft: margin.left,
        marginRight: margin.right,
        pageRanges,
        preferCSSPageSize,
        generateTaggedPDF
      });
      const result = await fe(j(printCommandPromise).pipe(Oe(timeout(ms))));
      if (omitBackground) {
        await this.#emulationManager.resetDefaultBackgroundColor();
      }
      assert2(result.stream, "`stream` is missing from `Page.printToPDF");
      return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);
    }
    async pdf(options = {}) {
      const { path: path2 = void 0 } = options;
      const readable = await this.createPDFStream(options);
      const buffer2 = await getReadableAsBuffer(readable, path2);
      assert2(buffer2, "Could not create buffer");
      return buffer2;
    }
    async close(options = { runBeforeUnload: void 0 }) {
      const connection = this.#primaryTargetClient.connection();
      assert2(connection, "Protocol error: Connection closed. Most likely the page has been closed.");
      const runBeforeUnload = !!options.runBeforeUnload;
      if (runBeforeUnload) {
        await this.#primaryTargetClient.send("Page.close");
      } else {
        await connection.send("Target.closeTarget", {
          targetId: this.#primaryTarget._targetId
        });
        await this.#tabTarget._isClosedDeferred.valueOrThrow();
      }
    }
    isClosed() {
      return this.#closed;
    }
    get mouse() {
      return this.#mouse;
    }
    /**
     * This method is typically coupled with an action that triggers a device
     * request from an api such as WebBluetooth.
     *
     * :::caution
     *
     * This must be called before the device request is made. It will not return a
     * currently active device prompt.
     *
     * :::
     *
     * @example
     *
     * ```ts
     * const [devicePrompt] = Promise.all([
     *   page.waitForDevicePrompt(),
     *   page.click('#connect-bluetooth'),
     * ]);
     * await devicePrompt.select(
     *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))
     * );
     * ```
     */
    async waitForDevicePrompt(options = {}) {
      return await this.mainFrame().waitForDevicePrompt(options);
    }
  };
  var supportedMetrics = /* @__PURE__ */ new Set([
    "Timestamp",
    "Documents",
    "Frames",
    "JSEventListeners",
    "Nodes",
    "LayoutCount",
    "RecalcStyleCount",
    "LayoutDuration",
    "RecalcStyleDuration",
    "ScriptDuration",
    "TaskDuration",
    "JSHeapUsedSize",
    "JSHeapTotalSize"
  ]);
  function getIntersectionRect(clip, viewport) {
    const x4 = Math.max(clip.x, viewport.x);
    const y6 = Math.max(clip.y, viewport.y);
    return {
      x: x4,
      y: y6,
      width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x4, 0),
      height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y6, 0)
    };
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Target.js
  var InitializationStatus;
  (function(InitializationStatus2) {
    InitializationStatus2["SUCCESS"] = "success";
    InitializationStatus2["ABORTED"] = "aborted";
  })(InitializationStatus || (InitializationStatus = {}));
  var CdpTarget = class extends Target {
    #browserContext;
    #session;
    #targetInfo;
    #targetManager;
    #sessionFactory;
    _initializedDeferred = Deferred.create();
    _isClosedDeferred = Deferred.create();
    _targetId;
    /**
     * To initialize the target for use, call initialize.
     *
     * @internal
     */
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory) {
      super();
      this.#session = session;
      this.#targetManager = targetManager;
      this.#targetInfo = targetInfo;
      this.#browserContext = browserContext;
      this._targetId = targetInfo.targetId;
      this.#sessionFactory = sessionFactory;
      if (this.#session && this.#session instanceof CdpCDPSession) {
        this.#session._setTarget(this);
      }
    }
    async asPage() {
      const session = this._session();
      if (!session) {
        return await this.createCDPSession().then((client) => {
          return CdpPage._create(client, this, false, null);
        });
      }
      return await CdpPage._create(session, this, false, null);
    }
    _subtype() {
      return this.#targetInfo.subtype;
    }
    _session() {
      return this.#session;
    }
    _sessionFactory() {
      if (!this.#sessionFactory) {
        throw new Error("sessionFactory is not initialized");
      }
      return this.#sessionFactory;
    }
    createCDPSession() {
      if (!this.#sessionFactory) {
        throw new Error("sessionFactory is not initialized");
      }
      return this.#sessionFactory(false).then((session) => {
        session._setTarget(this);
        return session;
      });
    }
    url() {
      return this.#targetInfo.url;
    }
    type() {
      const type = this.#targetInfo.type;
      switch (type) {
        case "page":
          return TargetType.PAGE;
        case "background_page":
          return TargetType.BACKGROUND_PAGE;
        case "service_worker":
          return TargetType.SERVICE_WORKER;
        case "shared_worker":
          return TargetType.SHARED_WORKER;
        case "browser":
          return TargetType.BROWSER;
        case "webview":
          return TargetType.WEBVIEW;
        case "tab":
          return TargetType.TAB;
        default:
          return TargetType.OTHER;
      }
    }
    _targetManager() {
      if (!this.#targetManager) {
        throw new Error("targetManager is not initialized");
      }
      return this.#targetManager;
    }
    _getTargetInfo() {
      return this.#targetInfo;
    }
    browser() {
      if (!this.#browserContext) {
        throw new Error("browserContext is not initialised");
      }
      return this.#browserContext.browser();
    }
    browserContext() {
      if (!this.#browserContext) {
        throw new Error("browserContext is not initialised");
      }
      return this.#browserContext;
    }
    opener() {
      const { openerId } = this.#targetInfo;
      if (!openerId) {
        return;
      }
      return this.browser().targets().find((target) => {
        return target._targetId === openerId;
      });
    }
    _targetInfoChanged(targetInfo) {
      this.#targetInfo = targetInfo;
      this._checkIfInitialized();
    }
    _initialize() {
      this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
    }
    _isTargetExposed() {
      return this.type() !== TargetType.TAB && !this._subtype();
    }
    _checkIfInitialized() {
      if (!this._initializedDeferred.resolved()) {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  };
  var PageTarget = class _PageTarget extends CdpTarget {
    #defaultViewport;
    pagePromise;
    #ignoreHTTPSErrors;
    constructor(targetInfo, session, browserContext, targetManager, sessionFactory, ignoreHTTPSErrors, defaultViewport) {
      super(targetInfo, session, browserContext, targetManager, sessionFactory);
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#defaultViewport = defaultViewport ?? void 0;
    }
    _initialize() {
      this._initializedDeferred.valueOrThrow().then(async (result) => {
        if (result === InitializationStatus.ABORTED) {
          return;
        }
        const opener = this.opener();
        if (!(opener instanceof _PageTarget)) {
          return;
        }
        if (!opener || !opener.pagePromise || this.type() !== "page") {
          return true;
        }
        const openerPage = await opener.pagePromise;
        if (!openerPage.listenerCount(
          "popup"
          /* PageEvent.Popup */
        )) {
          return true;
        }
        const popupPage = await this.page();
        openerPage.emit("popup", popupPage);
        return true;
      }).catch(debugError);
      this._checkIfInitialized();
    }
    async page() {
      if (!this.pagePromise) {
        const session = this._session();
        this.pagePromise = (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client) => {
          return CdpPage._create(client, this, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
        });
      }
      return await this.pagePromise ?? null;
    }
    _checkIfInitialized() {
      if (this._initializedDeferred.resolved()) {
        return;
      }
      if (this._getTargetInfo().url !== "") {
        this._initializedDeferred.resolve(InitializationStatus.SUCCESS);
      }
    }
  };
  var DevToolsTarget = class extends PageTarget {
  };
  var WorkerTarget = class extends CdpTarget {
    #workerPromise;
    async worker() {
      if (!this.#workerPromise) {
        const session = this._session();
        this.#workerPromise = (session ? Promise.resolve(session) : this._sessionFactory()(
          /* isAutoAttachEmulated=*/
          false
        )).then((client) => {
          return new CdpWebWorker(
            client,
            this._getTargetInfo().url,
            () => {
            },
            () => {
            }
            /* exceptionThrown */
          );
        });
      }
      return await this.#workerPromise;
    }
  };
  var OtherTarget = class extends CdpTarget {
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js
  function isPageTargetBecomingPrimary(target, newTargetInfo) {
    return Boolean(target._subtype()) && !newTargetInfo.subtype;
  }
  var ChromeTargetManager = class extends EventEmitter {
    #connection;
    /**
     * Keeps track of the following events: 'Target.targetCreated',
     * 'Target.targetDestroyed', 'Target.targetInfoChanged'.
     *
     * A target becomes discovered when 'Target.targetCreated' is received.
     * A target is removed from this map once 'Target.targetDestroyed' is
     * received.
     *
     * `targetFilterCallback` has no effect on this map.
     */
    #discoveredTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * A target is added to this map once ChromeTargetManager has created
     * a Target and attached at least once to it.
     */
    #attachedTargetsByTargetId = /* @__PURE__ */ new Map();
    /**
     * Tracks which sessions attach to which target.
     */
    #attachedTargetsBySessionId = /* @__PURE__ */ new Map();
    /**
     * If a target was filtered out by `targetFilterCallback`, we still receive
     * events about it from CDP, but we don't forward them to the rest of Puppeteer.
     */
    #ignoredTargets = /* @__PURE__ */ new Set();
    #targetFilterCallback;
    #targetFactory;
    #attachedToTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #detachedFromTargetListenersBySession = /* @__PURE__ */ new WeakMap();
    #initializeDeferred = Deferred.create();
    #targetsIdsForInit = /* @__PURE__ */ new Set();
    #waitForInitiallyDiscoveredTargets = true;
    #discoveryFilter = [{}];
    constructor(connection, targetFactory, targetFilterCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      this.#connection = connection;
      this.#targetFilterCallback = targetFilterCallback;
      this.#targetFactory = targetFactory;
      this.#waitForInitiallyDiscoveredTargets = waitForInitiallyDiscoveredTargets;
      this.#connection.on("Target.targetCreated", this.#onTargetCreated);
      this.#connection.on("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.on("Target.targetInfoChanged", this.#onTargetInfoChanged);
      this.#connection.on(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.#setupAttachmentListeners(this.#connection);
    }
    #storeExistingTargetsForInit = () => {
      if (!this.#waitForInitiallyDiscoveredTargets) {
        return;
      }
      for (const [targetId, targetInfo] of this.#discoveredTargetsByTargetId.entries()) {
        const targetForFilter = new CdpTarget(targetInfo, void 0, void 0, this, void 0);
        if ((!this.#targetFilterCallback || this.#targetFilterCallback(targetForFilter)) && targetInfo.type !== "browser") {
          this.#targetsIdsForInit.add(targetId);
        }
      }
    };
    async initialize() {
      await this.#connection.send("Target.setDiscoverTargets", {
        discover: true,
        filter: this.#discoveryFilter
      });
      this.#storeExistingTargetsForInit();
      await this.#connection.send("Target.setAutoAttach", {
        waitForDebuggerOnStart: true,
        flatten: true,
        autoAttach: true,
        filter: [
          {
            type: "page",
            exclude: true
          },
          ...this.#discoveryFilter
        ]
      });
      this.#finishInitializationIfReady();
      await this.#initializeDeferred.valueOrThrow();
    }
    dispose() {
      this.#connection.off("Target.targetCreated", this.#onTargetCreated);
      this.#connection.off("Target.targetDestroyed", this.#onTargetDestroyed);
      this.#connection.off("Target.targetInfoChanged", this.#onTargetInfoChanged);
      this.#connection.off(CDPSessionEvent.SessionDetached, this.#onSessionDetached);
      this.#removeAttachmentListeners(this.#connection);
    }
    getAvailableTargets() {
      return this.#attachedTargetsByTargetId;
    }
    #setupAttachmentListeners(session) {
      const listener = (event) => {
        void this.#onAttachedToTarget(session, event);
      };
      assert2(!this.#attachedToTargetListenersBySession.has(session));
      this.#attachedToTargetListenersBySession.set(session, listener);
      session.on("Target.attachedToTarget", listener);
      const detachedListener = (event) => {
        return this.#onDetachedFromTarget(session, event);
      };
      assert2(!this.#detachedFromTargetListenersBySession.has(session));
      this.#detachedFromTargetListenersBySession.set(session, detachedListener);
      session.on("Target.detachedFromTarget", detachedListener);
    }
    #removeAttachmentListeners(session) {
      const listener = this.#attachedToTargetListenersBySession.get(session);
      if (listener) {
        session.off("Target.attachedToTarget", listener);
        this.#attachedToTargetListenersBySession.delete(session);
      }
      if (this.#detachedFromTargetListenersBySession.has(session)) {
        session.off("Target.detachedFromTarget", this.#detachedFromTargetListenersBySession.get(session));
        this.#detachedFromTargetListenersBySession.delete(session);
      }
    }
    #onSessionDetached = (session) => {
      this.#removeAttachmentListeners(session);
    };
    #onTargetCreated = async (event) => {
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      this.emit("targetDiscovered", event.targetInfo);
      if (event.targetInfo.type === "browser" && event.targetInfo.attached) {
        if (this.#attachedTargetsByTargetId.has(event.targetInfo.targetId)) {
          return;
        }
        const target = this.#targetFactory(event.targetInfo, void 0);
        target._initialize();
        this.#attachedTargetsByTargetId.set(event.targetInfo.targetId, target);
      }
    };
    #onTargetDestroyed = (event) => {
      const targetInfo = this.#discoveredTargetsByTargetId.get(event.targetId);
      this.#discoveredTargetsByTargetId.delete(event.targetId);
      this.#finishInitializationIfReady(event.targetId);
      if (targetInfo?.type === "service_worker" && this.#attachedTargetsByTargetId.has(event.targetId)) {
        const target = this.#attachedTargetsByTargetId.get(event.targetId);
        if (target) {
          this.emit("targetGone", target);
          this.#attachedTargetsByTargetId.delete(event.targetId);
        }
      }
    };
    #onTargetInfoChanged = (event) => {
      this.#discoveredTargetsByTargetId.set(event.targetInfo.targetId, event.targetInfo);
      if (this.#ignoredTargets.has(event.targetInfo.targetId) || !this.#attachedTargetsByTargetId.has(event.targetInfo.targetId) || !event.targetInfo.attached) {
        return;
      }
      const target = this.#attachedTargetsByTargetId.get(event.targetInfo.targetId);
      if (!target) {
        return;
      }
      const previousURL = target.url();
      const wasInitialized = target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      if (isPageTargetBecomingPrimary(target, event.targetInfo)) {
        const session = target?._session();
        assert2(session, "Target that is being activated is missing a CDPSession.");
        session.parentSession()?.emit(CDPSessionEvent.Swapped, session);
      }
      target._targetInfoChanged(event.targetInfo);
      if (wasInitialized && previousURL !== target.url()) {
        this.emit("targetChanged", {
          target,
          wasInitialized,
          previousURL
        });
      }
    };
    #onAttachedToTarget = async (parentSession, event) => {
      const targetInfo = event.targetInfo;
      const session = this.#connection.session(event.sessionId);
      if (!session) {
        throw new Error(`Session ${event.sessionId} was not created.`);
      }
      const silentDetach = async () => {
        await session.send("Runtime.runIfWaitingForDebugger").catch(debugError);
        await parentSession.send("Target.detachFromTarget", {
          sessionId: session.id()
        }).catch(debugError);
      };
      if (!this.#connection.isAutoAttached(targetInfo.targetId)) {
        return;
      }
      if (targetInfo.type === "service_worker") {
        this.#finishInitializationIfReady(targetInfo.targetId);
        await silentDetach();
        if (this.#attachedTargetsByTargetId.has(targetInfo.targetId)) {
          return;
        }
        const target2 = this.#targetFactory(targetInfo);
        target2._initialize();
        this.#attachedTargetsByTargetId.set(targetInfo.targetId, target2);
        this.emit("targetAvailable", target2);
        return;
      }
      const isExistingTarget = this.#attachedTargetsByTargetId.has(targetInfo.targetId);
      const target = isExistingTarget ? this.#attachedTargetsByTargetId.get(targetInfo.targetId) : this.#targetFactory(targetInfo, session, parentSession instanceof CDPSession ? parentSession : void 0);
      if (this.#targetFilterCallback && !this.#targetFilterCallback(target)) {
        this.#ignoredTargets.add(targetInfo.targetId);
        this.#finishInitializationIfReady(targetInfo.targetId);
        await silentDetach();
        return;
      }
      this.#setupAttachmentListeners(session);
      if (isExistingTarget) {
        session._setTarget(target);
        this.#attachedTargetsBySessionId.set(session.id(), this.#attachedTargetsByTargetId.get(targetInfo.targetId));
      } else {
        target._initialize();
        this.#attachedTargetsByTargetId.set(targetInfo.targetId, target);
        this.#attachedTargetsBySessionId.set(session.id(), target);
      }
      if (parentSession instanceof CDPSession) {
        parentSession.emit(CDPSessionEvent.Ready, session);
      } else {
        parentSession.emit(CDPSessionEvent.Ready, session);
      }
      this.#targetsIdsForInit.delete(target._targetId);
      if (!isExistingTarget) {
        this.emit("targetAvailable", target);
      }
      this.#finishInitializationIfReady();
      await Promise.all([
        session.send("Target.setAutoAttach", {
          waitForDebuggerOnStart: true,
          flatten: true,
          autoAttach: true,
          filter: this.#discoveryFilter
        }),
        session.send("Runtime.runIfWaitingForDebugger")
      ]).catch(debugError);
    };
    #finishInitializationIfReady(targetId) {
      targetId !== void 0 && this.#targetsIdsForInit.delete(targetId);
      if (this.#targetsIdsForInit.size === 0) {
        this.#initializeDeferred.resolve();
      }
    }
    #onDetachedFromTarget = (_parentSession, event) => {
      const target = this.#attachedTargetsBySessionId.get(event.sessionId);
      this.#attachedTargetsBySessionId.delete(event.sessionId);
      if (!target) {
        return;
      }
      this.#attachedTargetsByTargetId.delete(target._targetId);
      this.emit("targetGone", target);
    };
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/Browser.js
  var CdpBrowser = class _CdpBrowser extends Browser {
    protocol = "cdp";
    static async _create(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      const browser = new _CdpBrowser(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets);
      await browser._attach();
      return browser;
    }
    #ignoreHTTPSErrors;
    #defaultViewport;
    #process;
    #connection;
    #closeCallback;
    #targetFilterCallback;
    #isPageTargetCallback;
    #defaultContext;
    #contexts = /* @__PURE__ */ new Map();
    #targetManager;
    constructor(product, connection, contextIds, ignoreHTTPSErrors, defaultViewport, process3, closeCallback, targetFilterCallback, isPageTargetCallback, waitForInitiallyDiscoveredTargets = true) {
      super();
      product = product || "chrome";
      this.#ignoreHTTPSErrors = ignoreHTTPSErrors;
      this.#defaultViewport = defaultViewport;
      this.#process = process3;
      this.#connection = connection;
      this.#closeCallback = closeCallback || function() {
      };
      this.#targetFilterCallback = targetFilterCallback || (() => {
        return true;
      });
      this.#setIsPageTargetCallback(isPageTargetCallback);
      if (product === "firefox") {
        this.#targetManager = new FirefoxTargetManager(connection, this.#createTarget, this.#targetFilterCallback);
      } else {
        this.#targetManager = new ChromeTargetManager(connection, this.#createTarget, this.#targetFilterCallback, waitForInitiallyDiscoveredTargets);
      }
      this.#defaultContext = new CdpBrowserContext(this.#connection, this);
      for (const contextId of contextIds) {
        this.#contexts.set(contextId, new CdpBrowserContext(this.#connection, this, contextId));
      }
    }
    #emitDisconnected = () => {
      this.emit("disconnected", void 0);
    };
    async _attach() {
      this.#connection.on(CDPSessionEvent.Disconnected, this.#emitDisconnected);
      this.#targetManager.on("targetAvailable", this.#onAttachedToTarget);
      this.#targetManager.on("targetGone", this.#onDetachedFromTarget);
      this.#targetManager.on("targetChanged", this.#onTargetChanged);
      this.#targetManager.on("targetDiscovered", this.#onTargetDiscovered);
      await this.#targetManager.initialize();
    }
    _detach() {
      this.#connection.off(CDPSessionEvent.Disconnected, this.#emitDisconnected);
      this.#targetManager.off("targetAvailable", this.#onAttachedToTarget);
      this.#targetManager.off("targetGone", this.#onDetachedFromTarget);
      this.#targetManager.off("targetChanged", this.#onTargetChanged);
      this.#targetManager.off("targetDiscovered", this.#onTargetDiscovered);
    }
    process() {
      return this.#process ?? null;
    }
    _targetManager() {
      return this.#targetManager;
    }
    #setIsPageTargetCallback(isPageTargetCallback) {
      this.#isPageTargetCallback = isPageTargetCallback || ((target) => {
        return target.type() === "page" || target.type() === "background_page" || target.type() === "webview";
      });
    }
    _getIsPageTargetCallback() {
      return this.#isPageTargetCallback;
    }
    async createIncognitoBrowserContext(options = {}) {
      const { proxyServer, proxyBypassList } = options;
      const { browserContextId } = await this.#connection.send("Target.createBrowserContext", {
        proxyServer,
        proxyBypassList: proxyBypassList && proxyBypassList.join(",")
      });
      const context = new CdpBrowserContext(this.#connection, this, browserContextId);
      this.#contexts.set(browserContextId, context);
      return context;
    }
    browserContexts() {
      return [this.#defaultContext, ...Array.from(this.#contexts.values())];
    }
    defaultBrowserContext() {
      return this.#defaultContext;
    }
    async _disposeContext(contextId) {
      if (!contextId) {
        return;
      }
      await this.#connection.send("Target.disposeBrowserContext", {
        browserContextId: contextId
      });
      this.#contexts.delete(contextId);
    }
    #createTarget = (targetInfo, session) => {
      const { browserContextId } = targetInfo;
      const context = browserContextId && this.#contexts.has(browserContextId) ? this.#contexts.get(browserContextId) : this.#defaultContext;
      if (!context) {
        throw new Error("Missing browser context");
      }
      const createSession = (isAutoAttachEmulated) => {
        return this.#connection._createSession(targetInfo, isAutoAttachEmulated);
      };
      const otherTarget = new OtherTarget(targetInfo, session, context, this.#targetManager, createSession);
      if (targetInfo.url?.startsWith("devtools://")) {
        return new DevToolsTarget(targetInfo, session, context, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
      }
      if (this.#isPageTargetCallback(otherTarget)) {
        return new PageTarget(targetInfo, session, context, this.#targetManager, createSession, this.#ignoreHTTPSErrors, this.#defaultViewport ?? null);
      }
      if (targetInfo.type === "service_worker" || targetInfo.type === "shared_worker") {
        return new WorkerTarget(targetInfo, session, context, this.#targetManager, createSession);
      }
      return otherTarget;
    };
    #onAttachedToTarget = async (target) => {
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetcreated", target);
        target.browserContext().emit("targetcreated", target);
      }
    };
    #onDetachedFromTarget = async (target) => {
      target._initializedDeferred.resolve(InitializationStatus.ABORTED);
      target._isClosedDeferred.resolve();
      if (target._isTargetExposed() && await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS) {
        this.emit("targetdestroyed", target);
        target.browserContext().emit("targetdestroyed", target);
      }
    };
    #onTargetChanged = ({ target }) => {
      this.emit("targetchanged", target);
      target.browserContext().emit("targetchanged", target);
    };
    #onTargetDiscovered = (targetInfo) => {
      this.emit("targetdiscovered", targetInfo);
    };
    wsEndpoint() {
      return this.#connection.url();
    }
    async newPage() {
      return await this.#defaultContext.newPage();
    }
    async _createPageInContext(contextId) {
      const { targetId } = await this.#connection.send("Target.createTarget", {
        url: "about:blank",
        browserContextId: contextId || void 0
      });
      const target = await this.waitForTarget((t8) => {
        return t8._targetId === targetId;
      });
      if (!target) {
        throw new Error(`Missing target for page (id = ${targetId})`);
      }
      const initialized = await target._initializedDeferred.valueOrThrow() === InitializationStatus.SUCCESS;
      if (!initialized) {
        throw new Error(`Failed to create target for page (id = ${targetId})`);
      }
      const page = await target.page();
      if (!page) {
        throw new Error(`Failed to create a page for context (id = ${contextId})`);
      }
      return page;
    }
    targets() {
      return Array.from(this.#targetManager.getAvailableTargets().values()).filter((target) => {
        return target._isTargetExposed() && target._initializedDeferred.value() === InitializationStatus.SUCCESS;
      });
    }
    target() {
      const browserTarget = this.targets().find((target) => {
        return target.type() === "browser";
      });
      if (!browserTarget) {
        throw new Error("Browser target is not found");
      }
      return browserTarget;
    }
    async version() {
      const version2 = await this.#getVersion();
      return version2.product;
    }
    async userAgent() {
      const version2 = await this.#getVersion();
      return version2.userAgent;
    }
    async close() {
      await this.#closeCallback.call(null);
      await this.disconnect();
    }
    disconnect() {
      this.#targetManager.dispose();
      this.#connection.dispose();
      this._detach();
      return Promise.resolve();
    }
    get connected() {
      return !this.#connection._closed;
    }
    #getVersion() {
      return this.#connection.send("Browser.getVersion");
    }
  };
  var CdpBrowserContext = class extends BrowserContext {
    #connection;
    #browser;
    #id;
    constructor(connection, browser, contextId) {
      super();
      this.#connection = connection;
      this.#browser = browser;
      this.#id = contextId;
    }
    get id() {
      return this.#id;
    }
    targets() {
      return this.#browser.targets().filter((target) => {
        return target.browserContext() === this;
      });
    }
    waitForTarget(predicate, options = {}) {
      return this.#browser.waitForTarget((target) => {
        return target.browserContext() === this && predicate(target);
      }, options);
    }
    async pages() {
      const pages = await Promise.all(this.targets().filter((target) => {
        return target.type() === "page" || target.type() === "other" && this.#browser._getIsPageTargetCallback()?.(target);
      }).map((target) => {
        return target.page();
      }));
      return pages.filter((page) => {
        return !!page;
      });
    }
    isIncognito() {
      return !!this.#id;
    }
    async overridePermissions(origin, permissions) {
      const protocolPermissions = permissions.map((permission) => {
        const protocolPermission = WEB_PERMISSION_TO_PROTOCOL_PERMISSION.get(permission);
        if (!protocolPermission) {
          throw new Error("Unknown permission: " + permission);
        }
        return protocolPermission;
      });
      await this.#connection.send("Browser.grantPermissions", {
        origin,
        browserContextId: this.#id || void 0,
        permissions: protocolPermissions
      });
    }
    async clearPermissionOverrides() {
      await this.#connection.send("Browser.resetPermissions", {
        browserContextId: this.#id || void 0
      });
    }
    newPage() {
      return this.#browser._createPageInContext(this.#id);
    }
    browser() {
      return this.#browser;
    }
    async close() {
      assert2(this.#id, "Non-incognito profiles cannot be closed!");
      await this.#browser._disposeContext(this.#id);
    }
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js
  async function _connectToCdpBrowser(connectionTransport, url, options) {
    const { ignoreHTTPSErrors = false, defaultViewport = DEFAULT_VIEWPORT, targetFilter, _isPageTarget: isPageTarget, slowMo = 0, protocolTimeout } = options;
    const connection = new Connection(url, connectionTransport, slowMo, protocolTimeout);
    const version2 = await connection.send("Browser.getVersion");
    const product = version2.product.toLowerCase().includes("firefox") ? "firefox" : "chrome";
    const { browserContextIds } = await connection.send("Target.getBrowserContexts");
    const browser = await CdpBrowser._create(product || "chrome", connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, void 0, () => {
      return connection.send("Browser.close").catch(debugError);
    }, targetFilter, isPageTarget);
    return browser;
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js
  init_environment();
  init_assert();
  init_ErrorLike();

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/fetch.js
  init_dirname();
  init_buffer2();
  init_process2();
  var getFetch = async () => {
    return globalThis.fetch || (await Promise.resolve().then(() => __toESM(require_browser_ponyfill(), 1))).fetch;
  };

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js
  var getWebSocketTransportClass = async () => {
    return isNode ? (await Promise.resolve().then(() => (init_NodeWebSocketTransport(), NodeWebSocketTransport_exports))).NodeWebSocketTransport : (await Promise.resolve().then(() => (init_BrowserWebSocketTransport(), BrowserWebSocketTransport_exports))).BrowserWebSocketTransport;
  };
  async function _connectToBrowser(options) {
    const { connectionTransport, endpointUrl } = await getConnectionTransport(options);
    if (options.protocol === "webDriverBiDi") {
      const bidiBrowser = await _connectToBiDiBrowser(connectionTransport, endpointUrl, options);
      return bidiBrowser;
    } else {
      const cdpBrowser = await _connectToCdpBrowser(connectionTransport, endpointUrl, options);
      return cdpBrowser;
    }
  }
  async function getConnectionTransport(options) {
    const { browserWSEndpoint, browserURL, transport, headers = {} } = options;
    assert2(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
    if (transport) {
      return { connectionTransport: transport, endpointUrl: "" };
    } else if (browserWSEndpoint) {
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(browserWSEndpoint, headers);
      return {
        connectionTransport,
        endpointUrl: browserWSEndpoint
      };
    } else if (browserURL) {
      const connectionURL = await getWSEndpoint(browserURL);
      const WebSocketClass = await getWebSocketTransportClass();
      const connectionTransport = await WebSocketClass.create(connectionURL);
      return {
        connectionTransport,
        endpointUrl: connectionURL
      };
    }
    throw new Error("Invalid connection options");
  }
  async function getWSEndpoint(browserURL) {
    const endpointURL = new URL("/json/version", browserURL);
    const fetch2 = await getFetch();
    try {
      const result = await fetch2(endpointURL.toString(), {
        method: "GET"
      });
      if (!result.ok) {
        throw new Error(`HTTP ${result.statusText}`);
      }
      const data = await result.json();
      return data.webSocketDebuggerUrl;
    } catch (error) {
      if (isErrorLike(error)) {
        error.message = `Failed to fetch browser webSocket URL from ${endpointURL}: ` + error.message;
      }
      throw error;
    }
  }

  // node_modules/puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js
  init_CustomQueryHandler();
  var Puppeteer = class {
    /**
     * Operations for {@link CustomQueryHandler | custom query handlers}. See
     * {@link CustomQueryHandlerRegistry}.
     *
     * @internal
     */
    static customQueryHandlers = customQueryHandlers;
    /**
     * Registers a {@link CustomQueryHandler | custom query handler}.
     *
     * @remarks
     * After registration, the handler can be used everywhere where a selector is
     * expected by prepending the selection string with `<name>/`. The name is only
     * allowed to consist of lower- and upper case latin letters.
     *
     * @example
     *
     * ```
     * puppeteer.registerCustomQueryHandler('text', { … });
     * const aHandle = await page.$('text/…');
     * ```
     *
     * @param name - The name that the custom query handler will be registered
     * under.
     * @param queryHandler - The {@link CustomQueryHandler | custom query handler}
     * to register.
     *
     * @public
     */
    static registerCustomQueryHandler(name2, queryHandler) {
      return this.customQueryHandlers.register(name2, queryHandler);
    }
    /**
     * Unregisters a custom query handler for a given name.
     */
    static unregisterCustomQueryHandler(name2) {
      return this.customQueryHandlers.unregister(name2);
    }
    /**
     * Gets the names of all custom query handlers.
     */
    static customQueryHandlerNames() {
      return this.customQueryHandlers.names();
    }
    /**
     * Unregisters all custom query handlers.
     */
    static clearCustomQueryHandlers() {
      return this.customQueryHandlers.clear();
    }
    /**
     * @internal
     */
    _isPuppeteerCore;
    /**
     * @internal
     */
    _changedProduct = false;
    /**
     * @internal
     */
    constructor(settings) {
      this._isPuppeteerCore = settings.isPuppeteerCore;
      this.connect = this.connect.bind(this);
    }
    /**
     * This method attaches Puppeteer to an existing browser instance.
     *
     * @remarks
     *
     * @param options - Set of configurable options to set on the browser.
     * @returns Promise which resolves to browser instance.
     */
    connect(options) {
      return _connectToBrowser(options);
    }
  };

  // extension/background.mjs
  var import_puppeteer_extension_transport = __toESM(require_lib2(), 1);
  var puppeteerCore = new Puppeteer({ isPuppeteerCore: true });
  var origins = ["https://rynomad.github.io", "http://localhost:3000"];
  chrome.webNavigation.onCommitted.addListener(function(details) {
    const obj = new URL(details.url);
    if (origins.includes(obj.origin)) {
      chrome.scripting.executeScript({
        target: { tabId: details.tabId },
        function: (value) => {
          localStorage.setItem("PROXY_EXTENSION_ID", value);
        },
        args: [chrome.runtime.id]
      });
    }
  });
  self.fetchServer = new Server(
    fetch,
    "fetch",
    new ChromeExtensionBackgroundTransport()
  );
})();
/*! Bundled license information:

@jspm/core/nodelibs/browser/buffer.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

puppeteer-core/lib/esm/third_party/mitt/mitt.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/disposable.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/EventEmitter.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Errors.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/ErrorLike.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/third_party/rxjs/rxjs.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/environment.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/assert.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Debug.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

@jspm/core/nodelibs/browser/chunk-44e51b61.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/assert.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

puppeteer-core/lib/esm/puppeteer/common/util.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CallbackRegistry.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/Function.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Deserializer.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandleSymbol.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/HandleIterator.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/LazyArg.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/QueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/AriaQueryHandler.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/CustomQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PierceQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TextQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/XPathQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/GetQueryHandler.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/util/decorators.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/util.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/JSHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/ElementHandle.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Serializer.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Connection.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BidiOverCdp.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/BrowserContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BrowserContext.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/NetworkManagerEvents.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/PDFOptions.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/TimeoutSettings.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/node/ScreenRecorder.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Accessibility.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Coverage.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameTree.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/ConsoleMessage.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/ExposedFunction.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/WaitTask.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Realm.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Sandbox.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Frame.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/HTTPResponse.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/NetworkManager.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Page.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Target.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/Browser.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/bidi.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/node/NodeWebSocketTransport.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/CDPSession.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Connection.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/bidi/BrowserConnector.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/FileChooser.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Dialog.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/JSHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ElementHandle.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ExecutionContext.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FirefoxTargetManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/DeviceRequestPrompt.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorld.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/IsolatedWorlds.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManagerEvents.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/LifecycleWatcher.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Frame.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/SecurityDetails.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkEventManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/NetworkManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/FrameManager.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/USKeyboardLayout.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Input.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/api/WebWorker.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Page.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Target.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/ChromeTargetManager.js:
  (**
   * @license
   * Copyright 2022 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/Browser.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/cdp/BrowserConnector.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/fetch.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/BrowserConnector.js:
  (**
   * @license
   * Copyright 2023 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)

puppeteer-core/lib/esm/puppeteer/common/Puppeteer.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
